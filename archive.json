{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-06-29T00:58:57.613957+00:00",
  "repo": "ietf-wg-mimi/mimi-protocol",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "consensus-required",
      "description": "",
      "color": "C2EE85"
    },
    {
      "name": "IETF-119",
      "description": "",
      "color": "fef2c0"
    },
    {
      "name": "WG reviewed",
      "description": "Issue has been reviewed in a MIMI WG meeting",
      "color": "B28596"
    },
    {
      "name": "has-PR",
      "description": "",
      "color": "E2A946"
    },
    {
      "name": "ready-for-PR",
      "description": "",
      "color": "217D80"
    },
    {
      "name": "chore",
      "description": "",
      "color": "000000"
    }
  ],
  "issues": [
    {
      "number": 6,
      "id": "I_kwDOKZ8QO851kCPb",
      "title": "Prepare document for IETF 118",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/6",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [
        "WG reviewed"
      ],
      "body": "Tasks:\r\n\r\n- [x] #7\r\n- [x] #9\r\n- [ ] Merge m.room.create event and m.room.participant_list into single event?\r\n- [x] #11\r\n- [ ] Define struct to use for fan-out messages, or better even a general MIMI message struct, which can contain an event or a fan-out message\r\n- [ ] Update #3 by replacing the individual structs with links to various parts of the document\r\n- [ ] Go over introduction and abstract\r\n\r\nMaybe move to after IETF 118\r\n- [ ] Change event naming scheme away from `m.xxx.yyy`?\r\n- [ ] Add section on Adds (representing a \"forced join\")\r\n- [ ] Allow patch-style operation instead of the current one-change-at-a time mechanism in m.room.user event\r\n- [ ] Figure out if KeyPackage retrieval should be tied to a room (at least optionally)",
      "createdAt": "2023-11-01T13:26:46Z",
      "updatedAt": "2024-05-08T17:47:00Z",
      "closedAt": "2024-05-08T17:46:18Z",
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "body": "IETF 118 is long over, everything here is stale per Richard.",
          "createdAt": "2024-05-08T17:46:18Z",
          "updatedAt": "2024-05-08T17:46:18Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOKZ8QO851kCSU",
      "title": "Move to MLS proposals as struct for room-state changing events",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/7",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-01T13:26:53Z",
      "updatedAt": "2023-11-02T14:48:17Z",
      "closedAt": "2023-11-02T14:48:17Z",
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOKZ8QO851plgi",
      "title": "Split MIMI DS operations into multiple events",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/9",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-02T09:24:25Z",
      "updatedAt": "2023-11-03T10:25:28Z",
      "closedAt": "2023-11-03T10:25:28Z",
      "comments": []
    },
    {
      "number": 11,
      "id": "I_kwDOKZ8QO851qU9n",
      "title": "Change language in Section on \"Invites\" to reflect that atomic operations are possible",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/11",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WG reviewed"
      ],
      "body": "",
      "createdAt": "2023-11-02T11:17:26Z",
      "updatedAt": "2024-05-08T17:46:59Z",
      "closedAt": "2024-05-08T17:46:59Z",
      "comments": []
    },
    {
      "number": 23,
      "id": "I_kwDOKZ8QO852UXde",
      "title": "Tracking arbitary state?",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/23",
      "state": "OPEN",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "consensus-required",
        "WG reviewed"
      ],
      "body": "Room name, etc",
      "createdAt": "2023-11-09T08:05:59Z",
      "updatedAt": "2025-03-19T01:06:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "Do we want to support this? How arbitrary is arbitrary?",
          "createdAt": "2023-11-09T12:55:44Z",
          "updatedAt": "2023-11-09T12:55:44Z"
        },
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposal would be to include a new event: `m.room.state`. That event carries a \"state key\" and arbitrary blob of data (with a limit?). The state key would be namespaced so we can add reserved values, like room name, topic, etc, as well as support metadata appended by messaging providers/clients/users. \r\n\r\nThe state included by `m.room.state` is shared in the same places a user participant list is shared, and would be subject to policy on who can add/update the arbitrary state. For example, when becoming involved in a room, the follower server would have visibility on it.\r\n\r\nOpen question on whether it should be encrypted or not. Suggestion is *optionally* encrypted, to more easily allow providers to attach provider-specific (but useful to others) metadata.",
          "createdAt": "2023-11-10T09:09:29Z",
          "updatedAt": "2023-11-10T09:09:29Z"
        },
        {
          "author": "dkg",
          "authorAssociation": "NONE",
          "body": "We should clearly support encrypted room state.  Yes, that means that changing epochs will require some sort of update of the encrypted room state.\r\n\r\nIf we have arbitrary named attributes for room state (e.g. \"name\", \"avatar\", etc...), be aware that any non-encrypted attributes will be visible to the server.  Furthermore, if encryption is done on a per-attribute basis, the names themselves are likely to be visible to the server, which can itself be an unwanted leak.  Better to have one encrypted bundle for room metadata that has arbitrary named attributes within it.",
          "createdAt": "2023-11-10T14:44:08Z",
          "updatedAt": "2023-11-10T14:44:08Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should first have a discussion about what information goes into room policy and room state. \r\n\r\nwe also need to enumerate what information we are talking about and decide if it needs to be inspected by the hub, and if it needs to be inspected by other providers.",
          "createdAt": "2023-11-12T13:32:40Z",
          "updatedAt": "2023-11-12T13:32:40Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed new room metadata state (which could be encrypted only for members) in draft-mahy-mimi-room-policy. This appears to be separate from mimi-protocol, but will be tracked here for now.",
          "createdAt": "2024-11-07T08:29:32Z",
          "updatedAt": "2024-11-07T08:29:32Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "body": "Rohan says there is a mechanism in room-policy that addresses this. Rohan to follow up on-list to make sure that issue originators are satisfied with that.",
          "createdAt": "2024-12-04T17:04:42Z",
          "updatedAt": "2024-12-04T17:04:42Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we now have this capability, to keep extensible state in a MIMI room in the GroupContext using app_data_dictionary. Some of it may need to be encrypted for members only, which is functionality also needed for minimal metadata rooms #101 ",
          "createdAt": "2025-03-19T01:06:44Z",
          "updatedAt": "2025-03-19T01:06:44Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOKZ8QO852VBff",
      "title": "Support external media requests",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/24",
      "state": "OPEN",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WG reviewed",
        "has-PR"
      ],
      "body": "Where we assume the external attachment blob (\"media\") is stored on a follower server, another server/the hub needs a way to fetch that media on behalf of its local clients.\r\n\r\nWe do not want to support clients requesting the media directly.\r\n\r\nTODO: Discuss authentication/right to download.",
      "createdAt": "2023-11-09T09:37:53Z",
      "updatedAt": "2025-03-18T14:41:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "An option articulated in #75",
          "createdAt": "2024-10-21T02:34:09Z",
          "updatedAt": "2024-10-21T02:34:09Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "body": "Making progress here is blocked on writing down a proper threat model, tracked in #93.",
          "createdAt": "2024-12-04T17:08:26Z",
          "updatedAt": "2024-12-04T17:08:26Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "See now #111 ",
          "createdAt": "2025-03-18T14:41:33Z",
          "updatedAt": "2025-03-18T14:41:33Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOKZ8QO852WF9h",
      "title": "Binary encoding for MIMI transport",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/25",
      "state": "OPEN",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "consensus-required",
        "WG reviewed"
      ],
      "body": "> **ISSUE**: Come to consensus on a specific binary encoding for the MIMI\r\n> transport protocol.\r\n\r\nCurrently we use TLS-serialized structs.",
      "createdAt": "2023-11-09T12:17:51Z",
      "updatedAt": "2025-03-19T08:01:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "anoadragon453",
          "authorAssociation": "NONE",
          "body": "The following four encoding options were mentioned in @rohan-wire's IETF 118 slides:\r\n\r\n* [TLS Presentation Language](https://datatracker.ietf.org/doc/html/rfc8446#section-3) (RFC8446)\r\n* [CBOR](https://datatracker.ietf.org/doc/html/rfc7049) (RFC7049)\r\n* [Protobuf](https://protobuf.dev/programming-guides/encoding/) (which [edition](https://protobuf.dev/editions/overview/)?)\r\n* [MessagePack](https://github.com/msgpack/msgpack/blob/master/spec.md)\r\n\r\n## Language support\r\n\r\nPart of our goals with MIMI is to create a protocol that is easy for people to implement in order to drive rapid adoption (and developer happiness!). A mature, well-tested encoding library ensures correctness and speed when deployed at scale.\r\n\r\n* TLS Presentation Language: library availability in programming languages is very underwhelming. Searching for \"TLS presentation language\" on crates.io, npm and PyPI yield zero relevant results. Presumably TLS libraries have support for this encoding, but it's unlikely that they'll expose that bit as a general interface.\r\n* CBOR: Healthy library support. Numerous libraries (some focusing on speed, others on correctness) appear on npm, PyPi and crates.io.\r\n* Protobuf: Healthy library support, with many implementations maintained by Google themselves.\r\n* MessagePack: Healthy library support. [msgpack-rust](https://github.com/3Hren/msgpack-rust) for Rust, [msgpackr](https://github.com/kriszyp/msgpackr) for JS and [msgpack](https://pypi.org/project/msgpack/) for Python.\r\n\r\n## Encoded output size and schema-required encodings\r\n\r\nEncoding schemes which do not include the structure as part of the encoded output will naturally have a small footprint. The downside is that the receiver must know the schema before decoding the payload.\r\n\r\nThis can cause issues in some areas regarding forwards-compatibility. For instance, if we have the following struct (taken from [draft-ietf-mimi-content-01](https://www.ietf.org/archive/id/draft-ietf-mimi-content-01.html#section-4.1)):\r\n\r\n```c++\r\nstruct MimiContent {\r\n    MessageId messageId;\r\n    uint64 timestamp;\r\n    MessageId replaces;\r\n    Octets topicId;\r\n    uint32 expires;\r\n    ReplyToInfo inReplyTo;\r\n    NestablePart body;\r\n};\r\n```\r\n\r\nand want to add a new field:\r\n\r\n```\r\n    std::vector<MessageId> lastSeen;\r\n```\r\n\r\n...old clients will not be able to deserialise a `MimiContent` struct with the new field. Adding new fields to top-level structs is likely to be an infrequent affair however. We can also scope these changes to a specific version of a chat room (similar to how Matrix [room versions](https://spec.matrix.org/v1.8/rooms/) specify which new features can be used in a room) in order to require clients to update to support the new schemas before participating in a chat room that uses them.\r\n\r\nI was initially more concerned about the extensibility of messaging content, as we would like to support vendors adding custom message types. This is also useful when testing new message types in real implementations before adding them to an upcoming MIMI protocol version.\r\n\r\nHowever, we can get around this by encoding message content using a separate schema struct. The current draft semantics already cover this, where a [`SinglePart`](https://www.ietf.org/archive/id/draft-ietf-mimi-content-01.html#section-4.4) looks like:\r\n\r\n```c++\r\nstruct SinglePart {\r\n    String contentType;   // An IANA media type {10}\r\n    Octets content;       // The actual content\r\n};\r\n```\r\n\r\nwith `content` being opaque to the top-level scheme. An client implementation can look at the `contentType` and check whether it recognises it. If so, it uses the schema it has for that `contentType` to decode `content`. Otherwise, it does not attend to decode it. This is similar to a client looking at a type and refusing to parse the associated JSON body - it doesn't understand the type, so why do so?\r\n\r\nThus I don't believe using an encoding which requires a schema (Protobuf, TLS Presentation Language) is an issue.\r\n\r\n## Types\r\n\r\nCBOR, Protobuf and MessagePack all have types such as `string`, `map`, `boolean` defined. TLS Presentation language does not define these, instead giving the user a `number`, `array`, `enum` and `struct` types to play with. You have the same functionality at the end, but the former are nicer to work with when designing a schema.\r\n\r\n## Field ordering\r\n\r\nWhile not important for deserialising a binary format, this *is* important for MIMI as being able to verify the signature of an encoded message when received at the server level is a useful property. Encodings such as CBOR and MessagePack may struggle here, as ordering of fields is not canonical (you'll end up with different binary representations of the same data). Protobuf's docs also [call this out](https://protobuf.dev/overview/#not-good-fit) as a shortcoming, stating \"You cannot compare two messages for equality without fully parsing them\". Parsing messages before verifying their contents came from the expected source is not efficient.\r\n\r\nWe ran into this problem in Matrix, which currently uses JSON, and solved it by defining [_Canonical_ JSON](https://spec.matrix.org/v1.8/appendices/#canonical-json), thus requiring JSON fields be sorted before sending them over the wire, and when verifying them.\r\n\r\nCBOR has [a suggestion for canonicalisation in the spec](https://datatracker.ietf.org/doc/html/rfc7049#section-3.9), which we could mandate. The `cbor-rust` library has [implemented support](https://github.com/enarx/ciborium/issues/28) for it.\r\n\r\nMessagePack appears to have support for canonical field ordering in [some libraries](https://py-algorand-sdk.readthedocs.io/en/latest/algosdk/encoding.html), but [not others](https://github.com/3Hren/msgpack-rust/issues/299).\r\n\r\nThe spec for TLS Presentation Language does not mandate field order, so library support (hah) for it may be spotty. But if we need to write libraries anyway, then we can mandate a canonical version.\r\n\r\n## Encoding and Decoding Speed\r\n\r\nThis is easy enough to test with a benchmark, but I suspect we should consider other merits initially. I don't believe any of these would be significantly faster or slower than the other.\r\n\r\nA note: I did start to write a micro-benchmark in Python. TLS Presentation Language was the hardest to support as it has no readily-available library!\r\n\r\n## Initial questions\r\n* Do we care about the encoding scheme being defined by an existing RFC?\r\n    * If this is a blocker, why are we considering options other than TLS Presentation Language or CBOR?\r\n    * Similarly, if this is a blocker, it severely limits our options. What would we need to do to use, say, Protobufs. Would we need to get the encoding spec into an I-D?\r\n* Is a canonical representation of the data on the wire a hard requirement?",
          "createdAt": "2023-11-10T11:30:26Z",
          "updatedAt": "2023-11-10T12:20:37Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "If I remember correctly, one of the considerations is that it must be defined either by the WG itself or elsewhere in the IETF.",
          "createdAt": "2023-11-10T11:36:23Z",
          "updatedAt": "2023-11-10T11:36:23Z"
        },
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "Ideally elsewhere, if I remember correctly. While MIMI is specifying protocols for interoperability, it could be considered out of scope to also define an encoding specification.",
          "createdAt": "2023-11-10T11:37:28Z",
          "updatedAt": "2023-11-10T11:37:28Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point!",
          "createdAt": "2023-11-10T11:38:07Z",
          "updatedAt": "2023-11-10T11:38:07Z"
        },
        {
          "author": "anoadragon453",
          "authorAssociation": "NONE",
          "body": "I've updated my comment above :)",
          "createdAt": "2023-11-10T12:20:25Z",
          "updatedAt": "2023-11-10T12:20:25Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for putting this together! A few comments:\r\n\r\nForward compatibility: The way MLS solves this is by including a protocol version field in the highest level message struct, as well as in the room state, which I think is what you suggest, too. If there should be a need to change structs independent of protocol versions, we could do this via per-room extensions, which would be part of what would be called a room version in Matrix terminology.\r\n\r\nAvailability of libraries: I can't speak for other languages, but there is the `tls_codec` crate that implements the encoding of rust structs. It works quite well in OpenMLS and also (I believe) mls-rs.\r\n\r\nErgonomics: If we feel that it's useful, we should be able to extend the TLS presentation language to a certain degree. At least we've done so for MLS and it didn't turn out to be problematic.\r\n\r\nField order: The TLS presentation language does mandate field order. The way I read it, structs are just a convenient way of representing an (ordered) sequence of fields.\r\n\r\nYou already mentioned the requirement for fields to be ordered for signing and verification. At this point, I don't see an advantage in choosing something that is not ordered.\r\n\r\nI don't have a strong preference for the TLS presentation language, but it's served us well so far in TLS and MLS, so I'm somewhat biased towards that option. Also, MIMI stacks will either already have TLS presentation language encoding/decoding in their stack, because they use MLS, or they will have it in their stack at some point when they make the switch from DR. If we find a better performing option without significant drawbacks, I'm happy to change my mind, though.",
          "createdAt": "2023-11-10T13:43:12Z",
          "updatedAt": "2023-11-10T13:43:12Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If I remember correctly, one of the considerations is that it must be defined either by the WG itself or elsewhere in the IETF.\r\n\r\nIt requires a \"stable reference\". Protobuf 3 probably does not qualify because it is still being changed. Protobuf 2 probably qualifies.",
          "createdAt": "2023-11-12T13:40:37Z",
          "updatedAt": "2023-11-12T13:40:37Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Cons of TLS:\r\nThis is less an issue for the transport protocol than for the content format, but I was unable to locate a javascript TLS presentation language parser that seems to be actively maintained. The most obvious TLS library for js, [forge](https://github.com/digitalbazaar/forge) still mentions Flash in its README and the last commit was in spring of 2022. \r\nAlso, TLS unfortunately does not have typedefs, so when you define a type for reuse or clarity, you have to access it through the type.\r\n\r\nFrankly, I think none of these 4 encodings is really focused on what we would need for a gatekeeper to gatekeeper implementation, which is parsing speed \u00fcber alles. Protobuf base-128 encodes all its integers. CBOR shares its type and length in many cases in the same byte. These are efficiencies for compactness which are undesirable in the MIMI case.",
          "createdAt": "2023-11-13T06:24:17Z",
          "updatedAt": "2023-11-13T06:24:17Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks Andrew for sending out a nice summary.\r\n\r\nAndrew said:\r\n>    Do we care about the encoding scheme being defined by an existing RFC?\r\n>        If this is a blocker, why are we considering options other than TLS Presentation Language or CBOR?\r\n>        Similarly, if this is a blocker, it severely limits our options. What would we need to do to use, say, Protobufs. Would we need to get the encoding spec into an I-D?\r\n\r\nIf we have a good reason to use non-IETF specs, we can as long as there is a stable reference. The key here is the requirements. \r\n\r\n>    Is a canonical representation of the data on the wire a hard requirement?\r\nYes, I think so.  I want to point out that a solution/compromise to this problem in CBOR is to define an array of the mandatory types (so those fields are always in order), and then a map of extensions (which could be empty). This allows safe extensions with only limited impact on speed (you only look for an extension when you need one). You can probably do this in TLS if you juggle the fields hard enough, but it is not especially natural.\r\n",
          "createdAt": "2023-11-13T06:32:32Z",
          "updatedAt": "2023-11-13T06:32:32Z"
        },
        {
          "author": "Alexis211",
          "authorAssociation": "NONE",
          "body": "This is my first time posting in a MIMI discussion, so please bear with me if I write things that are wrong or irrelevant, but I would still like to share my opinion as a developer of distributed systems.\r\n\r\nI would put a strong emphasis on using a serialization protocol that is defined by an RFC or another formal standard published by a recognized organism, which leaves CBOR and TLS presentation language (TLS-PL) as good options.\r\n\r\nGiven the scope of the task that MIMI aims for, I think we would all agree that making a protocol that can be upgraded and extended is a strong requirement. At first glance, CBOR looks like it would be a good option, as field names are serialized with the data, and new fields can therefore be added easily. However this is relatively dangerous and can break down when the interpretation of existing fields change, leading to the following rule : _the context in which a message should be interpreted must be specified outside of the message itself_. This can be done using protocol versions, but I believe this outcome can be achieved in a much more versatile way by standardizing individual message structures (the equivalent of protobuf schemas), and assigning IDs to these types in the RFCs, which would then be prepended to each individual message. Once a message type has been published with its corresponding schema and type identifier, it cannot be changed anymore, and updated/extended versions must be published as separate schemas with a different type identifier. This does not need to be coordinated on a global scale using protocol versions (only the attribution of non-overlapping type IDs has to be coordinated), and individual RFCs could be published with specific extensions or updated message types (with such a process, the RFC numbers could be embedded in type identifiers to ensure that they are non-overlapping). Implementations would be required to still support older message type (unless they are specifically made obsolete by a new RFC), and their semantics can be upgraded on-the-fly to newer protocol semantics. This is the solution I've converged to in [the software I develop](https://garagehq.deuxfleurs.fr), albeit for internal data storage formats with support for migration, and not for a public interchange protocol.\r\n\r\nAs a consequence of using exterior type identifiers to determine the semantics of encoded messages, the value proposition of CBOR that encodes fields names is much less relevant and TLS-PL becomes a compelling option as well. Since both are standardized, I believe they are relatively equivalent in their merits, and the remaining distinctions are relatively minor. I'd argue that CBOR might be a better option due to seemingly better library availability for many mainstream programming languages, and semantics that are quite similar to JSON, which is known by everyone, so it might be a better choice to ease the implementation of the MIMI standard and help it to be deployed widely as soon as possible. While TLS-PL might have better compactness and encoding/decoding performance, I'm not sure this is is a very relevant argument, given that CBOR is already orders of magnitude faster than JSON, and there will be many costs at other places (storage access times, network delays, conversion to other formats including JSON in the various proprietary client-server APIs, ...).\r\n\r\nConcerning the need for a canonical representation in order to be able to compute and verify signatures, I feel that this whole mess is fundamentally caused by misuse of serialization and signing primitives, and could be totally avoided by storing the signature outside and next to the serialized message, in a second layer of serialization. A signed message would always be a tuple (signature, data bytes), serialized in any relevant way (potentially embedded in a larger struct with other data), where the data bytes would always be a byte slice of the signed message, serialized previously in a separate step, and that would always be transmitted as a single unit next to its signature and never modified. Not respecting this principle when building serialization formats is the cause for needless headaches such as needing to determine what a \"canonical representation\" means, and also exposes to higher risk of security flaws by misuse of cryptographic primitives. Of course, there would be significant performance issues when doing this with text-based encoding formats such as JSON, but for binary encoding formats that support inline byte slices, this can be very efficiently implemented without the need for binary encoding/decoding such as base64 and excessive memory copies. In fact, this could even help achieve better performance as sub-serialized fields would not need to be deserialized in all cases, and in particular not when interpreting their content is not needed.\r\n\r\nHope this helps.",
          "createdAt": "2023-12-27T17:10:55Z",
          "updatedAt": "2023-12-27T17:15:33Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "A comment on Protobuf: Some popular implementations do not fully support Protobuf 2, but only the subset of features that is also present in Protobuf 3. Groups being the most popular example. Also Protobuf 2 support is considered deprecated in some implementations, so specifying the use of Protobuf 2 at this point seems weird.\r\n\r\nBoth CBOR and TLS-PL seem to be reasonable options to me.",
          "createdAt": "2024-02-07T12:26:24Z",
          "updatedAt": "2024-02-07T12:26:24Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "The WG came to consensus on CBOR for MIMI-content, and I believe we have consensus to continue with TLS encoding for MIMI-protocol. @tgeoghegan ?",
          "createdAt": "2024-07-25T19:04:01Z",
          "updatedAt": "2024-07-25T19:04:01Z"
        },
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure we've had the transport debate yet as a working group. There's several open questions about whether HTTP, TLS-PL, etc are correct - the current stuff was presented as 'notional'.",
          "createdAt": "2024-07-26T00:09:30Z",
          "updatedAt": "2024-07-26T00:09:30Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "body": "Action here (for @rohanmahy)  is to go to the list to formally establish consensus on (1) TLS encoding for MIMI-protocol and (2) HTTP as a transport.",
          "createdAt": "2024-12-04T17:10:31Z",
          "updatedAt": "2024-12-04T17:10:31Z"
        },
        {
          "author": "Neustradamus",
          "authorAssociation": "NONE",
          "body": "To follow this ticket.",
          "createdAt": "2025-03-05T05:54:41Z",
          "updatedAt": "2025-03-05T05:54:41Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Emailed the list. Will close unless credible alternate proposed by April 3",
          "createdAt": "2025-03-19T08:01:41Z",
          "updatedAt": "2025-03-19T08:01:41Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOKZ8QO852WHQd",
      "title": "Transport semantics",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/26",
      "state": "OPEN",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "consensus-required",
        "WG reviewed"
      ],
      "body": "> **ISSUE**: Come to consensus on a specific set of MIMI transport protocol\r\n> semantics.",
      "createdAt": "2023-11-09T12:21:07Z",
      "updatedAt": "2025-03-19T08:01:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "body": "Action here is the same as for #25 (https://github.com/ietf-wg-mimi/mimi-protocol/issues/25#issuecomment-2518054125)",
          "createdAt": "2024-12-04T17:11:57Z",
          "updatedAt": "2024-12-04T17:11:57Z"
        },
        {
          "author": "Neustradamus",
          "authorAssociation": "NONE",
          "body": "To follow this important ticket.",
          "createdAt": "2025-03-05T05:49:56Z",
          "updatedAt": "2025-03-05T05:49:56Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Emailed the list. Will close unless credible alternate proposed by April 3",
          "createdAt": "2025-03-19T08:01:10Z",
          "updatedAt": "2025-03-19T08:01:10Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOKZ8QO852WOFo",
      "title": "Notions of consent",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/27",
      "state": "CLOSED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "consensus-required"
      ],
      "body": "Can Alice see Bob's clients? Under what conditions? Other forms of consent?",
      "createdAt": "2023-11-09T12:37:37Z",
      "updatedAt": "2024-07-25T18:59:04Z",
      "closedAt": "2024-07-25T18:59:03Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in #78. Closing.",
          "createdAt": "2024-07-25T18:59:03Z",
          "updatedAt": "2024-07-25T18:59:03Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOKZ8QO852WPWq",
      "title": "Request key packages based on user ID? (or send many DSRequests)",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/28",
      "state": "CLOSED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "consensus-required"
      ],
      "body": "> **TODO**: For now, the event fetches key packages based on client identifiers,\r\n> not user identifiers. This is because KeyPackage fetching is part of MIMI DS,\r\n> which doesn't know what a user is. We could, however, send multiple MIMI DS\r\n> requests in a single MIMI protocol request.",
      "createdAt": "2023-11-09T12:40:49Z",
      "updatedAt": "2024-11-07T08:35:28Z",
      "closedAt": "2024-11-07T08:35:28Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "This is actually no longer the case. the current document fetches based on user. Closing.",
          "createdAt": "2024-11-07T08:35:28Z",
          "updatedAt": "2024-11-07T08:35:28Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOKZ8QO852WP3r",
      "title": "Shape of policy",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/29",
      "state": "CLOSED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "consensus-required",
        "WG reviewed"
      ],
      "body": "Incorporate mahy-group-chat and ralston-policy documents, deduplicate ideas.",
      "createdAt": "2023-11-09T12:42:09Z",
      "updatedAt": "2024-12-04T17:14:25Z",
      "closedAt": "2024-12-04T17:14:19Z",
      "comments": [
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "Related questions include how to communicate the policy to servers/users. This could be an IANA registry to contain descriptors for policy as a whole.",
          "createdAt": "2023-11-09T12:44:06Z",
          "updatedAt": "2023-11-09T12:44:06Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "presented at IETF120 on draft-mahy-mimi-room-policy as a strawperson policy concept. \r\n\r\nNoted that ABAC (Attribute-based access control) was not universally understood and it was unclear if what I proposed is role-based or attribute-based. There are not fixed roles, but it could still be described as role-based by some reasonable definition.",
          "createdAt": "2024-07-25T19:53:22Z",
          "updatedAt": "2024-07-25T19:53:22Z"
        },
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "fwiw, at the meeting I was mostly using the [Wikipedia article on ABAC](https://en.wikipedia.org/wiki/Attribute-based_access_control) to compare it to RBAC. Wikipedia is far from the definition authority here, but doesn't make any effort to distinguish RBAC as needing fixed or dynamic roles to qualify, indicating that at least the general population wouldn't make that distinction.\r\n\r\nI think both ABAC and RBAC are probably fine approaches, though we should decide on what the policy actually needs to cover before trying to fit a structure onto it. We may find that as we work through what actually needs enforcing, those permissions do (or don't) require significant structure like dynamic roles.\r\n\r\nor tldr: I think we should write out what we feel needs to be permissible before deciding on a access control approaches.",
          "createdAt": "2024-07-25T22:35:04Z",
          "updatedAt": "2024-07-25T22:35:04Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Travis. Maybe we can try to go over the user cases during one of the upcoming interims?",
          "createdAt": "2024-07-25T22:48:13Z",
          "updatedAt": "2024-07-25T22:48:13Z"
        },
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "that would be great! Let's do it.",
          "createdAt": "2024-07-25T23:39:55Z",
          "updatedAt": "2024-07-25T23:39:55Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "body": "We now have a room policy document adopted, so there's nothing more to be done in the protocol doc. Closing this issue.",
          "createdAt": "2024-12-04T17:14:19Z",
          "updatedAt": "2024-12-04T17:14:19Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOKZ8QO852WQ7n",
      "title": "Clarify fanout throughout",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/30",
      "state": "CLOSED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "turt2live"
      ],
      "labels": [],
      "body": "Which events are sent to who, and how? Specifically DS Welcome events.",
      "createdAt": "2023-11-09T12:44:45Z",
      "updatedAt": "2024-11-07T09:04:43Z",
      "closedAt": "2024-11-07T09:04:43Z",
      "comments": [
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "> **TODO**: Especially when adding new clients, we will want to forward a\r\n> `ds.commit` event selectively, as existing group members will only be\r\n> interested in the actual commit, whereas new group members only need the\r\n> Welcome.",
          "createdAt": "2023-11-09T12:47:10Z",
          "updatedAt": "2023-11-09T12:47:10Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is now pretty clear. I propose we close this one. ",
          "createdAt": "2024-10-21T02:34:41Z",
          "updatedAt": "2024-10-21T02:34:41Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOKZ8QO852WSKb",
      "title": "Security properties of GroupInfo",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/31",
      "state": "CLOSED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "consensus-required"
      ],
      "body": "> **TODO**: in the MLS case, what security properties are needed to protect a\r\n> GroupInfo object in the MIMI context are still under discussion. It is\r\n> possible that the requester only needs to prove possession of their private\r\n> key. The GroupInfo in another context might be sufficiently sensitive that it\r\n> should be encrypted from the end client to the hub provider (unreadable by the\r\n> local provider).",
      "createdAt": "2023-11-09T12:47:50Z",
      "updatedAt": "2024-11-07T09:04:22Z",
      "closedAt": "2024-11-07T09:04:22Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "The same security should probably apply to an `m.room.info` event proposed in #23.",
          "createdAt": "2023-11-10T09:33:56Z",
          "updatedAt": "2023-11-10T09:33:56Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "GroupInfo is now protected from the external joiner's provider during fetch in #86 . It can be protected from the committer's provider in #85 . Closing. ",
          "createdAt": "2024-11-07T09:04:22Z",
          "updatedAt": "2024-11-07T09:04:22Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOKZ8QO852WSr7",
      "title": "Event sender changes",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/32",
      "state": "CLOSED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "consensus-required"
      ],
      "body": "> **TODO**: Consider splitting `sender` into an object of `{type, identifier}`.\r\n\r\n> **TODO**: The `sender` field might be a bit redundant now that signaling is\r\n> largely handled through MLS proposals.",
      "createdAt": "2023-11-09T12:49:07Z",
      "updatedAt": "2024-11-07T09:01:41Z",
      "closedAt": "2024-11-07T09:01:41Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "This is no longer relevant in the current formulation. Closing. ",
          "createdAt": "2024-11-07T09:01:41Z",
          "updatedAt": "2024-11-07T09:01:41Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDOKZ8QO852WTGV",
      "title": "Continue fetching key packages directly?",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/33",
      "state": "CLOSED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "consensus-required",
        "WG reviewed"
      ],
      "body": "> **TODO**: For now, we assume that KeyPackages are fetched directly, i.e. not in the\r\n> context of a room and via a Hub. This might change in the future. If it does\r\n> change, this event needs an additional authentication mechanism.",
      "createdAt": "2023-11-09T12:50:08Z",
      "updatedAt": "2024-12-04T17:15:19Z",
      "closedAt": "2024-12-04T17:15:10Z",
      "comments": [
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "In previous discussions, the working group indicated that it's preferred to route everything through the hub: does this still hold true? \r\n\r\nProposal from my side would be to route traffic through the hub, though authentication of the proxied material may require direct pokes. This would likely apply for #24 as well (with authentication being a hash in the message, to prevent modified downloads)",
          "createdAt": "2023-11-10T09:03:09Z",
          "updatedAt": "2023-11-10T09:03:09Z"
        },
        {
          "author": "beltram",
          "authorAssociation": "NONE",
          "body": "tl;dr: fetch KeyPackages from the Hub.\r\n\r\nConsider the case of expirable credentials (X509, VCs): they have to be rotated at some point.\r\n\r\nIf a KeyPackage is not fetched from the Hub consistently then a client might fetch a KeyPackage which corresponding private key has been deleted by the emitter. This would lead to the creation of a Welcome whose receiver would be unable to decrypt, becoming a ghost client.",
          "createdAt": "2023-11-13T10:06:28Z",
          "updatedAt": "2023-11-13T10:06:28Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see where the routing (i.e. via the Hub or directly) makes a difference in the context of KeyPackage or Credential expiration. In both cases the KeyPackage from Bob's server will reach Alice at almost the same time.\r\n\r\nFrom what I understood, the biggest concern is that direct fetching \"violates\" star-shaped topology and can thus lead to situations, where Alice wants to fetch a KeyPackage from Bob, but her provider doesn't allow direct contact. Alice would thus have to fetch through a Hub. However, if Alice and Bob can only connect through that Hub, the Alice probably shouldn't be able to obtain KeyPackages from Bob in the first place.\r\n\r\nFor authentication key material, I suggest (for now) we assume that the credential in each KeyPackage contains a full chain that everyone can verify against their local (web) root of trust.",
          "createdAt": "2023-11-13T12:59:18Z",
          "updatedAt": "2023-11-13T12:59:18Z"
        },
        {
          "author": "beltram",
          "authorAssociation": "NONE",
          "body": "Here is the scenario I have in mind. If we want to strictly prevent ghost clients we have to fetch KeyPackages from the Hub. We could relax that rule for Basic KeyPackages or in the presence of a `PreventGhostClients=false` RoomPolicy.\r\n\r\n```mermaid\r\nsequenceDiagram\r\n  participant B as Bob\r\n  participant HP as Hub Provider\r\n  participant GP as Guest Provider\r\n  participant A as Alice\r\n  B ->>+ HP: Replace its KeyPackages\r\n  HP ->>- B: Ok KeyPackages replaced\r\n  B ->> B: Deletes asociated private keys\r\n  A ->>+ GP: Fetch Bob (old) KeyPackage\r\n  GP ->>- A: Here is 1 KeyPackage from Bob\r\n  HP ->>+ GP: Bob's KeyPackage have changed\r\n  A ->> A: Create Add Commit + Welcome\r\n  A ->> GP: Send Welcome\r\n  GP ->> HP: Fanout Welcome\r\n  HP ->> B: Receive Welcome\r\n  B ->> B: Decryption error\r\n```",
          "createdAt": "2023-11-13T14:37:16Z",
          "updatedAt": "2023-11-13T14:37:16Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "What I don't understand is why the guest provider would buffer Bob's KeyPackages instead of just forwarding Alice's Query to Bob's server (which in this case is the Hub)? KeyPackages are (for the most part) single-use. Or are you talking about last-resort KeyPackages?",
          "createdAt": "2023-11-13T15:22:46Z",
          "updatedAt": "2023-11-13T15:22:46Z"
        },
        {
          "author": "beltram",
          "authorAssociation": "NONE",
          "body": "You're right it does not make sense for Alice's Provider to buffer other Provider's KeyPackage. Let me redact my example. Here if the Hub is not responsible for the KeyPackages of the room, then it would validate the Add Commit of an already deleted KeyPackage. I concede this example is an edge-case but it could still occur.\r\n\r\n```mermaid\r\nsequenceDiagram\r\n  participant B as Bob\r\n  participant GPB as Guest Provider Bob\r\n  participant HP as Hub Provider\r\n  participant GPA as Guest Provider Alice\r\n  participant A as Alice\r\n  A ->>+ GPB: Fetch Bob KeyPackage\r\n  GPB ->>- A: Bob KeyPackage\r\n  A ->> A: Create Add Commit + Welcome\r\n  B ->>+ GPB: Replace its KeyPackages\r\n  A ->> HP: Send Add Commit + Welcome\r\n  GPB ->>- B: Ok KeyPackages replaced\r\n  B ->> B: Deletes asociated private keys\r\n  HP ->> GPB: Fanout Welcome\r\n  GPB ->> B: Receive Welcome\r\n  B ->> B: Decryption error\r\n```",
          "createdAt": "2023-11-13T17:31:23Z",
          "updatedAt": "2023-11-13T17:31:23Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I see now what you mean, thanks! A few comments:\r\n\r\nIf we follow what I think you suggest, then Bob would have to upload KeyPackages to every Hub he is involved in and, more generally, Hubs would (have to) manage key material for every client that is in one of their groups. This introduces quite a bit of complexity as Bob now has to track where he uploaded which KeyPackages.\r\n\r\nEven if we implement that solution, we would still have the same problem in cases where Bob doesn't have any KeyPackages on Alice's Hub (because he is not a participant of any groups there). Then Alice has to fetch KeyPackages from Bob's server (through her Hub) and Bob can replace that KeyPackage while Alice is creating the Add, leading to the same situation.\r\n\r\nI don't think we can completely solve this issue. However, Bob can recover from this situation by doing an external commit. He may have missed a few messages, but he can recover. Also, Bob can mitigate this issue by keeping the key material around for a short while after replacing KeyPackages on the server. After all, Alice is not going to wait a very long time between fetching a KeyPackage and performing the Add operation.\r\n\r\nTo summarize, I don't think the problem is that bad, because there is a mitigation and a recovery mechanism. Instead of taking the complexity hit of keeping KeyPackages on every Hub, we should instead focus on a simpler solution (fetching via the Hub, or fetching directly from Bob's server).",
          "createdAt": "2023-11-14T07:33:02Z",
          "updatedAt": "2023-11-14T07:33:02Z"
        },
        {
          "author": "dkasak",
          "authorAssociation": "NONE",
          "body": "It seems to me that the problem presented here would largely be avoided if instead of key package replacement we were talking about key package *replenishment*.\r\n\r\nReplacement implies we're dropping already published but supposedly unused key packages, which then turn out to have actually been used, triggering the issue. On the other hand, replenishment (up to a given max total) never drops already published key packages before they're used, only adds new ones. This then mostly avoids the problem of dropping key packages prematurely.\r\n\r\nUnder this view, the key package fetching operation is to be considered to be consuming the key package, thereby reducing the number of available key packages on the guest provider, instructing the user (Bob in the diagram above) to replenish a larger number of key packages in order to reach the max total.",
          "createdAt": "2023-11-21T15:12:20Z",
          "updatedAt": "2023-11-21T15:12:20Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "While it would certainly make things simpler, I don't think we can assume that clients will never need to remove/revoke KeyPackages. For example, if a client rotates its credential for some reason, it won't want to wait until all previously published KeyPackages have expired.",
          "createdAt": "2023-11-21T15:20:08Z",
          "updatedAt": "2023-11-21T15:20:08Z"
        },
        {
          "author": "dkasak",
          "authorAssociation": "NONE",
          "body": "You're right, of course. A client could also simply lose its private key material for the published key packages due to an error or failure. This makes it obvious removal needs to be supported.\r\n\r\nHowever, I maintain that the default case should be to non-destructively replenish rather than replace, and for the fetching operation to be considered to be consuming (reducing the available total), which in practice makes this problem *much* less likely to occur.",
          "createdAt": "2023-11-21T15:32:18Z",
          "updatedAt": "2023-11-21T15:32:18Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "body": "Key packages are now delivered via the hub, so this is resolved.",
          "createdAt": "2024-12-04T17:15:10Z",
          "updatedAt": "2024-12-04T17:15:10Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Currently KPs are fetched via the Hub so that Welcomes can be delivered correctly.",
          "createdAt": "2024-12-04T17:15:16Z",
          "updatedAt": "2024-12-04T17:15:16Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "I_kwDOKZ8QO852WTd9",
      "title": "Fix `ds.send_message`",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/34",
      "state": "CLOSED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "consensus-required"
      ],
      "body": "> **TODO**: This is not a proposal and there is no way for the Hub or follower servers\r\n> to authenticate this event at the moment. We might want to a way to do that\r\n> later.\r\n\r\n(thoughts welcome)",
      "createdAt": "2023-11-09T12:51:02Z",
      "updatedAt": "2024-07-25T19:50:01Z",
      "closedAt": "2024-07-25T19:50:01Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "Some context: Application messages are signed, but the sender data is encrypted to protect the associated metadata. Only clients can decrypt the sender data and thus authenticate the message.",
          "createdAt": "2023-11-10T09:32:04Z",
          "updatedAt": "2023-11-10T09:32:04Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe the current submitMessage primitive has appropriate authorization now. Closing. ",
          "createdAt": "2024-07-25T19:50:01Z",
          "updatedAt": "2024-07-25T19:50:01Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "I_kwDOKZ8QO852WTtP",
      "title": "Do we need `m.room.info`?",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/35",
      "state": "CLOSED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "see title",
      "createdAt": "2023-11-09T12:51:37Z",
      "updatedAt": "2024-07-25T19:48:44Z",
      "closedAt": "2024-07-25T19:48:44Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "For context: If the room state is included fully (and not just as a hash) in the group state, it can be retrieved it via `ds.fetch_group_info`. `m.room.info` is thus somewhat redundant.",
          "createdAt": "2023-11-10T09:30:49Z",
          "updatedAt": "2023-11-10T09:30:49Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the original intent of this was that clients would get informed of changes to the room and room policy, which I think is covered under the current architecture. Closing. (Please reopen a more specific issue if I missed something).",
          "createdAt": "2024-07-25T19:48:44Z",
          "updatedAt": "2024-07-25T19:48:44Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "I_kwDOKZ8QO852WUF-",
      "title": "`Add` authorization",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/36",
      "state": "CLOSED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "consensus-required"
      ],
      "body": "> **TODO**: We will probably want some kind of mechanism here that allows the\r\n> adder to signal that they are authorized (by the added user) to add the added\r\n> user to the room.",
      "createdAt": "2023-11-09T12:52:31Z",
      "updatedAt": "2024-07-25T19:50:52Z",
      "closedAt": "2024-07-25T19:50:52Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we have this currently with the AppSync mechanism. Closing.",
          "createdAt": "2024-07-25T19:50:52Z",
          "updatedAt": "2024-07-25T19:50:52Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "I_kwDOKZ8QO852WUZl",
      "title": "Refactor invites?",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/37",
      "state": "CLOSED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "consensus-required"
      ],
      "body": "> **TODO**: For now, the invite flow implies that the user has to explicitly\r\n> accept by adding one or more clients via external commit as part of the \"Join\"\r\n> flow. In the future, we can either make the \"Invite\" flow more versatile and\r\n> allow for Welcome based invitations, or create an additional \"Add\" flow, that\r\n> allows participants to add other users (and their clients) directly via\r\n> Welcome.",
      "createdAt": "2023-11-09T12:53:14Z",
      "updatedAt": "2023-11-14T07:21:15Z",
      "closedAt": "2023-11-14T07:21:15Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "That TODO is a bit outdated (meaning I forgot to remove it as part of the PR that added the Add flow). We now have an \"Add\" section in the document, so I think we can close this. ",
          "createdAt": "2023-11-10T09:29:28Z",
          "updatedAt": "2023-11-10T09:29:28Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "I_kwDOKZ8QO852WU23",
      "title": "Do we need knocks?",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/38",
      "state": "OPEN",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "consensus-required",
        "WG reviewed"
      ],
      "body": "> **TODO**: Discuss if this participation state is desirable, and figure out\r\n> details for how it works. It'd likely just be an `m.room.user` state event\r\n> with no MLS interaction, like invites are.\r\n\r\n> **TODO**: If we have an Add event as discussed in a TODO in the \"Invites\"\r\n> section, an \"Add\" would probably be the response to a knock.",
      "createdAt": "2023-11-09T12:54:20Z",
      "updatedAt": "2025-03-19T03:13:35Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A response to a knock could be an Add or an Invite or a Ban IMO.",
          "createdAt": "2023-11-12T13:28:35Z",
          "updatedAt": "2023-11-12T13:28:35Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "Just so we agree on what we're talking about: The knocking functionality is meant to allow a user (or its server) to request to be added to a given room, correct? In that context, do we really need an invite as additional step? I'd say an Add would be a positive response and a kick or ban the negative ones.",
          "createdAt": "2023-11-13T12:30:42Z",
          "updatedAt": "2023-11-13T12:30:42Z"
        },
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "Knocking is intended to be a \"please add me\" stage, yes. It could be argued to be pure signaling without group operations, similar to invites. \r\n\r\nThe requirement to be invited (accepted knock) is largely an artifact from Matrix, where the concept of an \"Add\" doesn't necessarily exist in the signaling flow. For MIMI, an Add is more appropriate (and if worded slightly differently, is an invite in terms of signaling anyways). \r\n\r\nThe question here is mostly whether we need a protocol feature for \"request Add\", or if this could be considered excess bulk.",
          "createdAt": "2023-11-13T18:31:13Z",
          "updatedAt": "2023-11-13T18:31:13Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "body": "Nobody has a clear use case that motivates this feature. @rohanmahy will go to the MIMI list to ask for use cases, and we'll close this if none materialize.",
          "createdAt": "2024-12-04T17:19:40Z",
          "updatedAt": "2024-12-04T17:19:40Z"
        },
        {
          "author": "timokoesters",
          "authorAssociation": "NONE",
          "body": "I have never used knocks myself, but I think the idea is to protect against spam waves. By attaching a custom message to the knock, they can explain their motivation for joining the room.\r\n\r\nA similar problem is attaching a custom message when sending a friend request or starting a new DM with someone. I don't know how this would work in practice though, because e2ee is not initialized at that time.",
          "createdAt": "2024-12-17T15:53:50Z",
          "updatedAt": "2024-12-17T15:53:50Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "COLLABORATOR",
          "body": "If I understand this correctly, this is a feature Signal has. Users can generate an invite link to a group, but new participants still have to be allowed individually. If that's what it is, this is actually a very useful feature for communities or in business messaging.",
          "createdAt": "2024-12-18T17:49:37Z",
          "updatedAt": "2024-12-18T17:49:37Z"
        },
        {
          "author": "coopdanger",
          "authorAssociation": "NONE",
          "body": "Agree with Raphael.",
          "createdAt": "2025-03-19T03:13:35Z",
          "updatedAt": "2025-03-19T03:13:35Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "I_kwDOKZ8QO854hf7_",
      "title": "XMPP compatibility?",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/40",
      "state": "CLOSED",
      "author": "haansn08",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "WG reviewed"
      ],
      "body": "I feel like it's a missed opportunity by the MIMI WG to essentially ignore the prior art created with the XMPP standard and make no effort to be compatible with the existing XMPP internet standard.\r\n\r\nI'm not sure why an entirely new transport protocol and message format that is not compatible with XMPP is being considered, instead of a XMPP protocol extension for MLS.\r\n\r\nThe advantages of Matrix were eventual consistency and more decentralized rooms, but the protocol proposal makes no mention of those features and the scaling issues Matrix has show that they're probably a bad idea too. Is it really worth breaking compatibility with XMPP just to replace XML with JSON?",
      "createdAt": "2023-12-02T13:48:21Z",
      "updatedAt": "2025-03-05T05:49:40Z",
      "closedAt": "2024-12-04T17:24:18Z",
      "comments": [
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "*For the record: I'm directly affiliated with Matrix as a Spec Core Team member.*\r\n\r\nThe MIMI charter mentions XMPP as a prior attempt to achieve interoperability, though implies that it's insufficient in some way. MIMI is aiming to *learn from* XMPP rather than implement XMPP. I'm not sure the concerns regarding XMPP have been enumerated, though this issue may be a good place to cover some of them as they relate to the protocol document specifically. \r\n\r\nThe protocol document's purpose is to be as compatible as possible with existing messaging providers, which inherently includes compatibility with existing messaging(-ish) protocols too. The document does *not* use JSON or XML, and indeed doesn't have features that Matrix does either. This doesn't make it incompatible, however, as that would be counter to the point of MIMI. Both Matrix and XMPP can interact with MIMI through this protocol with relative ease, and should feel like that's in fact possible. \r\n\r\nFor Matrix, initial compatibility would be defining a room version which is capable of representing MIMI's policies. Openly available exploration into some of the ideas MIMI has for policy are underway as [MSC4056](https://github.com/matrix-org/matrix-spec-proposals/pull/4056), [MSC4049](https://github.com/matrix-org/matrix-spec-proposals/pull/4049), [MSC4080](https://github.com/matrix-org/matrix-spec-proposals/pull/4080), etc. More rich compatibility might be extending MIMI RFCs when they exist, or further room version alterations, or both. None of this is important for MIMI to track directly, however. \r\n\r\nXMPP, alongside other existing messaging providers, may have to undergo a similar transition in their own systems. XMPP specifically might choose to write up an extension which is MIMI-compatible, or similar. Other messaging providers might implement a dual-stack service in their infrastructure which speaks MIMI on one side and their internal systems on the other. The protocol document's lack of history retention specifically gives the fire-and-forget protocols/providers a chance at interoperating, even if the network they're talking to supports history (like Matrix). \r\n\r\nRegarding Matrix's scalability briefly, it's worth noting that many of the concerns folks have are largely with the organic implementations rather than the protocol. The protocol requires very little to be persisted, though those organic implementations definitely are persist-heavy. As the network grows, the server implementations will become more efficient as well. Regardless, the protocol document being discussed here has been specifically designed with scalability in mind, particularly for the billions of users scenario.\r\n\r\nOverall, I feel as though the level of compatibility we've reached in this document is sufficient for what MIMI hopes to achieve. Existing providers are able to use it relatively quickly, as are both Matrix and XMPP if they choose. The scalability of the protocol is unproven but feels correct, though may still need adjusting while implementations are written and evaluated. \r\n\r\nIf you have specific concerns with the compatibility or scalability, I'm happy to address them here or with [proposed] edits to the document as required.",
          "createdAt": "2023-12-05T20:51:05Z",
          "updatedAt": "2023-12-05T20:51:05Z"
        },
        {
          "author": "haansn08",
          "authorAssociation": "NONE",
          "body": "> MIMI is aiming to learn from XMPP rather than implement XMPP.\r\n\r\nI don't see how MIMI has learned from XMPP, in particular a good reason why MIMI is not implemented as an extension for XMPP in the first place.\r\n\r\nThe choice of HTTP as the transport protocol also strikes me as odd for an IM protocol, the streaming XML part of XMPP seems much more appropriate for IM providers.",
          "createdAt": "2023-12-16T03:12:50Z",
          "updatedAt": "2023-12-16T03:12:50Z"
        },
        {
          "author": "Alexis211",
          "authorAssociation": "NONE",
          "body": "> The choice of HTTP as the transport protocol also strikes me as odd for an IM protocol, the streaming XML part of XMPP seems much more appropriate for IM providers.\r\n\r\nHere are some of the advantages of using a protocol based on HTTP that I see as a developer of distributed systems (note that this is my first time posting on discussions about the IETF MIMI effort, although I've been following it from afar for quite some time) :\r\n\r\n- A streaming protocol using a single TCP connection would be subject to reliability issues such as head-of-line blocking (the situation where a dropped packet slows down the entire flow of data in a TCP connection, including unrelated traffic that could have gone through regardless), and the necessity for specific handling of restart logic when an existing connection is dropped/interrupted and a new connection has to be started. With HTTP, independent messages can be submitted through separate TCP connections, which are stateless by definition, and not subject to global head-of-line blocking.\r\n\r\n- The reliability requirements on messaging applications match very well to the transactional nature of HTTP requests: when sending a message to a remote server using a PUT (or POST) request, a response code of 200 indicates that the recipient server has successfully received and stored the message, whereas any other result (error response code, connection reset, timeout, etc.) indicates that the message could not be transmitted, and should be queued for retry. Other features of IM applications, such as retrieving channel state (history, member list) or interacting with objects in any kind of ways generally map very well to HTTP semantics as well.\r\n\r\n- By forcing the design of a protocol that uses separate, stateless HTTP requests for each message, we will naturally end up building a protocol that is idempotent, i.e. if we are not sure that a message was sent correctly, we just re-send it, and even if the first one did actually go through, the message will not be duplicated when the second requests is received as well. (This can be implemented using unique IDs on messages, and is an expected behavior of HTTP PUT requests).\r\n\r\n- HTTP library support is excellent in most mainstream programming languages, and many developers are already familiar with HTTP semantics (which is not the case with XMPP), which could help MIMI to be adopted much more easily / much faster.\r\n\r\nAll in all, I am a strong believer in building a protocol that makes use of HTTP. The only downside I can see is that, technically, this would make for a slightly more heavyweight protocol than a streaming protocol using long-running statefull TCP connections. However I believe that these potential performance issues can generally be overcome by designing a protocol that is minimalistic / not bloated, and allowing for optimizations such as connection reuse, header compression, etc, all of which are features of the now-standard HTTP3. From what I've heard from a large public XMPP server that is currently running, the bottlenecks are not CPU or networking but rather on storage (for the loading of chat room history), so I believe the costs of using an HTTP-based protocol would be totally bearable and largely outweighted by the benefits which I mentioned above.",
          "createdAt": "2023-12-27T16:19:49Z",
          "updatedAt": "2023-12-27T16:19:49Z"
        },
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "To clarify the client-server detail: it's generally understood that if MIMI were to be founded on another protocol, that protocol's client-server API would be excluded from scope. Matrix's APIs are able to be separated in this way, and I believe XMPP can as well.",
          "createdAt": "2024-01-15T18:21:23Z",
          "updatedAt": "2024-01-15T18:21:23Z"
        },
        {
          "author": "haansn08",
          "authorAssociation": "NONE",
          "body": "@Alexis211 \r\n\r\n> A streaming protocol using a single TCP connection would be subject to reliability issues such as head-of-line blocking (the situation where a dropped packet slows down the entire flow of data in a TCP connection\r\n\r\nHead-of-line blocking is not a very pressing issue for XMPP today, but even if it was there are much better options than establishing more TCP/SSL connections for every request/message like with HTTP, just to avoid head-of-line blocking. An updated XMPP spec with a message oriented transport protocol such as SCTP or QUICK would be nice and much more elegant than HTTP. Switching out the transport protocol also allows for backwards compatibility and avoids reinventing the wheel again.\r\n\r\n> The reliability requirements on messaging applications match very well to the transactional nature of HTTP requests: when sending a message to a remote server using a PUT (or POST) request, a response code of 200 indicates that the recipient server has successfully received and stored the message\r\n\r\n> By forcing the design of a protocol that uses separate, stateless HTTP requests for each message, we will naturally end up building a protocol that is idempotent, i.e. if we are not sure that a message was sent correctly, we just re-send it, and even if the first one did actually go through, the message will not be duplicated when the second requests is received as well. (This can be implemented using unique IDs on messages, and is an expected behavior of HTTP PUT requests).\r\n\r\nYou probably are looking for https://xmpp.org/extensions/xep-0198.html\r\n\r\n> HTTP library support is excellent in most mainstream programming languages, and many developers are already familiar with HTTP semantics (which is not the case with XMPP), which could help MIMI to be adopted much more easily / much faster.\r\n\r\nSince most IM users are trapped in large silos like WhatsApp today success will mostly depend on whether those large providers will adopt it or not. WhatsApp for example is already using a modified version of ejabberd internally, so XMPP federation would be the obvious choice for them. It's nice that there are masses of web developers out there that understand how HTTP works, but tbh there are very few companies that decide if MIMI will be successful. I think reinventing existing internet standards, instead of improving them is much more harmful to the goals of MIMI. XMPP is already a successful protocol - it is time tested and can scale to billions (!) of users in production like at WhatsApp - even if the original goal of universal federation has not been met. However this is due to the profit incentives of large IM providers (ofc interoperability is harder and as a \"reward\" is makes it easier for users to leave their platform). Publishing yet another IM protocol will do nothing to solve this problem and only introduce more fragmentation.",
          "createdAt": "2024-02-02T13:27:01Z",
          "updatedAt": "2024-02-02T18:19:58Z"
        },
        {
          "author": "haansn08",
          "authorAssociation": "NONE",
          "body": "More evidence that WhatsApp's DMA compliance will be based on the XMPP internet standard:\r\n \r\n> Dick Brouwer, an engineering director at WhatsApp\r\n\r\n> Brouwer says Meta would prefer if other apps use the Signal encryption protocol, which its systems are based upon. Other than its namesake app and the Meta-owned messengers, the Signal Protocol is publicly disclosed as being used in Google Messages and Skype. To send messages, third-party apps will need to encrypt content using the Signal Protocol and then **package it into message stanzas in the eXtensible Markup Language (XML)**. When receiving messages, apps will need to connect to WhatsApp\u2019s servers.\r\n\r\n> \u201cWe think that the best way to deliver this approach is through a solution that is **built on WhatsApp\u2019s existing client-server architecture**,\u201d Brouwer says, adding it has been working with other companies on the plans.\r\n\r\nhttps://www.wired.com/story/whatsapp-interoperability-messaging/",
          "createdAt": "2024-02-06T21:36:59Z",
          "updatedAt": "2024-02-06T21:36:59Z"
        },
        {
          "author": "ara4n",
          "authorAssociation": "COLLABORATOR",
          "body": "Having just implemented Matrix interop with WA\u2019s DMA APIs, I\u2019m afraid that I can say with authority that they are *very* far removed from XMPP (as you would expect, given WhatsApp forked from XMPP and ejabberd before it even launched).",
          "createdAt": "2024-02-07T00:47:23Z",
          "updatedAt": "2024-02-07T00:47:23Z"
        },
        {
          "author": "haansn08",
          "authorAssociation": "NONE",
          "body": "@ara4n Can you share more details about the API? I cannot find any details on it. The most detailed account on the internals of WhatsApp I can find is this [article](https://mycodeplex.wordpress.com/2016/03/08/inside-of-whatsapp-part-1/) from 2016, which suggests that they use a static table to map XMPP keywords to single bytes and a lot of custom extensions.",
          "createdAt": "2024-02-07T02:20:33Z",
          "updatedAt": "2024-02-07T02:20:33Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "- XMPP over HTTP is long specified via [XEP-0206](https://xmpp.org/extensions/xep-0206.html), with multiple implementations having used it in the wild (it was how XMPP clients in browsers worked before there was WebSocket)\r\n- XMPP over WebSocket is specified via [RFC7395](https://datatracker.ietf.org/doc/rfc7395/)\r\n- XMPP over QUIC was specified before the foundation of the MIMI WG via [XEP-0467](https://xmpp.org/extensions/xep-0467.html). There is a [server-side proxy software](https://github.com/moparisthebest/xmpp-proxy) that can make every existing XMPP server support XMPP over QUIC both for c2s and s2s.\r\n\r\nSo any of the mentioned reasons that speak for using HTTP would not rule out using XMPP in any way. That said, I also don't see a big issue with using something else. Even if XMPP was used as is as a transport protocol, there would be need to add support for new identifiers, discovery and so on, so it's unlikely that any existing XMPP implementation could be compatible with what is within the goals of MIMI.\r\n\r\nWhen it comes to take learnings from XMPP:\r\n- Don't use XML or JSON for transporting binary blobs (or as payload for encrypted messages). It's really just wasting resources and it's impossible to understand those for humans anyway (which was one of the reasons to use plain-text protocols back then).\r\n- Always keep in mind you might lose messages on s2s links during fanout, implying the need to discover this and be able to recover from such loss.",
          "createdAt": "2024-02-07T10:59:53Z",
          "updatedAt": "2024-02-07T10:59:53Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "@haansn08 , first of all, I apologize to taking a long time to respond to this issue. \r\n\r\nI quite like the clean semantics of XMPP. It has clean layering; the very relevant distinction between `message`, `presence`, and `iq` stanzas; and it has inter-domain interoperability baked in. Most of largest messaging servers ran on XMPP at some time in the past. Some of them also permitted open-federation. \r\n\r\nSo, why don't they use XMPP now? Open-federation became unsupportable due to spam and abuse, but that is not a reason to switch protocols (you can run an XMPP system that refuses to accept messages to or from most domains). \r\nThe large vendors have volumes in the millions of messages per minute. They were some of the largest XMPP deployments and then transitioned to something else.\r\n\r\nMy understanding is that at some point the time spent parsing each stream to find the beginning and end of a stanza became a real bottleneck in these networks and made it challenging to implement what has become a standard high availability architecture, where a small number of ingress nodes forward to a much larger set of service nodes. \r\n\r\nKeeping track of which elements you are in, not to mention comments and CDATA blobs involve pretty non-trivial string processing if all you want to find is the start and end of a stanza. Chunking fixed length binary blobs is way easier and faster for an ingress node.\r\n\r\nI wasn't familiar with XEP-0467, but it seems to focus on the client to server connection. I could imagine that a binary protocol that just delivers XMPP stanzas over mutual TLS or QUIC could already dramatically improve the ingress situation.\r\n\r\nWhat else has changed since most instant messaging services ran on XMPP? End-to-end encryption. MIMI would not exist if it was not a requirement. Without it vendors could just gateway among protocols. E2EE means that the contents encrypted for the recipients need to be usable by the recipients. That means we need a standard content format, a standard encryption protocol (in this case MLS), compatible usage of that encryption, and a way to negotiation extensions. \r\n\r\nI would be delighted to see implementations of XMPP that use MLS, and I am willing to help implementers make that happen. I would also entertain using XMPP to exchange MLS-encrypted messages *in MIMI* if it includes a credible proposal to solve the high availability problem. \r\n\r\nThat said, I think the semantics of consent, initial keying material, and the details of which MLS extensions are needed (ex: which external_senders are in a group and how they get there; how a welcomed client gets the ratchet tree) are much more pressing. Those questions need to get resolved regardless if MIMI transport happens over HTTP, XMPP, or something else.\r\n\r\nThanks,\r\n-rohan",
          "createdAt": "2024-02-22T18:39:55Z",
          "updatedAt": "2024-02-22T18:39:55Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "Hi rohan,\r\n\r\nI secured funding to specify and implement MLS in XMPP (see https://nlnet.nl/project/XMPP-MLS/). Compatibility of this specification with MIMI is important to me and the XMPP community. As of now, I assume that something along the lines of [draft-ietf-mimi-content](https://datatracker.ietf.org/doc/draft-ietf-mimi-content/) will be the MIMI payload format, which is fine for me (we can specify how it maps to XMPP and have an [XEP-0420](https://xmpp.org/extensions/xep-0420.html) envelope inside an additional part to accommodate for XMPP features not supported by MIMI itself where necessary).\r\n\r\nAs a client developer, I am personally not really involved with the selection of the transport protocol of MLS-encrypted MIMI messages - we can have server-side gateways to whatever MIMI decides to do.\r\n\r\nAs I understood, there was no interest within the MIMI WG to use a protocol based on and/or compatible with current XMPP specification, software and deployments and this is a fair decision. If there was a clear signal from MIMI WG that XMPP is desired to be used, I am certain that several community members would be willing to prioritize developments around that. But as many contributors to XMPP don't have a lot of resources they are willing to waste on this (if there is no intent from the MIMI WG to pick these things up, it would likely be wasted), you are unlikely to see large documents being prepared to promote the use of XMPP in MIMI.",
          "createdAt": "2024-02-22T19:17:53Z",
          "updatedAt": "2024-02-22T19:17:53Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "@mar-v-in \r\nI'm delighted to hear that you have funding to write a XEP for MLS. I'm happy to help, and I would love the MIMI usage of MLS and the XEP to be compatible. Please DM me (IETF Slack, @rohanmahy on Wire, rohan.ietf@gmail.com ).\r\n\r\n> If there was a clear signal from MIMI WG that XMPP is desired to be used, I am certain that several community members would be willing to prioritize developments around that. But as many contributors to XMPP don't have a lot of resources they are willing to waste on this (if there is no intent from the MIMI WG to pick these things up, it would likely be wasted), you are unlikely to see large documents being prepared to promote the use of XMPP in MIMI.\r\n\r\nI think this is a bit of a chicken and egg problem. I think having an idea of how it would work at the bar-napkin or half-page outline level would be useful for the rest of the WG to even understand how it would be possible. ",
          "createdAt": "2024-02-22T20:43:30Z",
          "updatedAt": "2024-02-22T20:44:42Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "body": "This is related to #26, in that we might want to support XMPP core as a transport for MIMI instead of/in addition to HTTPS.\r\n\r\nWe are closing this issue in that we believe nothing is missing to allow interop with XMPP, except for what is tracked in #26. There's no other action to take on this issue.",
          "createdAt": "2024-12-04T17:24:18Z",
          "updatedAt": "2024-12-04T17:24:18Z"
        },
        {
          "author": "Neustradamus",
          "authorAssociation": "NONE",
          "body": "To follow this important ticket about XMPP.",
          "createdAt": "2025-03-05T05:49:39Z",
          "updatedAt": "2025-03-05T05:49:39Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "I_kwDOKZ8QO85-dr3a",
      "title": "power levels or role-based authorization?",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/46",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "IETF-119"
      ],
      "body": "draft-ralston-mimi-protocol currently uses Matrix-style power levels.\r\ndraft-barnes-mimi-protocol currently implies role-based access control (RBAC).\r\n\r\nI think we have three reasonable choices here:\r\n- keep using power levels\r\n- use role-based access control with a fixed set of roles (for example: owner, admin, moderator, regular-user, visitor, banned, none)\r\n- user role-based access control with administrator defined role labels. Each role label has a set of permissions it can accomplish (for example, can add user, can add remove user, can change user role, can change base policy, etc.)\r\n\r\nTravis brought up that with role-based access control it is necessary to specify the behavior of combinations of roles or permissions. That is true, but I don't think it is unreasonable to enumerate those requirements. I think RBAC maps much better onto the variety of systems we would like to interop with. ",
      "createdAt": "2024-02-06T21:40:00Z",
      "updatedAt": "2024-03-03T06:48:12Z",
      "closedAt": "2024-03-03T06:48:12Z",
      "comments": [
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "draft-ralston-mimi-protocol currently does not define any permissions model, especially not power levels, and instead implies some sort of RBAC. I do think we need an RBAC system, but it needs to be user-defined because there's systems which already allow such features. \r\n\r\nUsers should also be able to be assigned multiple roles, which can then lead to conflicts in the user's permissions. To make it predictable, we can add a numeric `order` value to each role, which defines which order the role's included permissions are defined in (in ascending order). Note that I'm assuming permissions are a trinary of [grant, deny, unchanged/default].\r\n\r\nAs an example:\r\n* Role A (power 1) is explicitly allowed to send messages, no changes to being able to add users.\r\n* Role B (power 2) is explicitly allowed to add users, no changes to sending messages.\r\n* Role C (power 3) is explicitly *denied* sending messages, no changes to adding users.\r\n* User A is assigned roles A and C - they are *not* allowed to send messages, and the default value for adding users is applied. \r\n* User B is assigned roles B and C - they are *not* allowed to send messages, and *are* allowed to add other users. \r\n* User C is assigned roles A, B, and C - they have the same permissions as User B.",
          "createdAt": "2024-02-06T22:20:18Z",
          "updatedAt": "2024-02-06T22:20:18Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "DT call 2024-02-28:\r\n* Violent agreement that RBAC+labels is a sensible way to go.  Specifically:\r\n    * Underlying set of permissions \r\n    * Predefine labels for common sets of permissions\r\n    * Allow administrators to define other sets of permissions\r\n* @rohanmahy to make a PR with a minimal version of this scheme",
          "createdAt": "2024-02-28T16:23:15Z",
          "updatedAt": "2024-02-28T16:23:15Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Created PR #62 ",
          "createdAt": "2024-03-01T22:14:47Z",
          "updatedAt": "2024-03-01T22:14:47Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "Back in the LDAP days, we figured out that additive permissions (you can do the sum of all the roles that you are assigned) was possible to reason about.\r\nSubtractive ACLs (\"if you're in group FOO then you can do BAZ except when you're also in group BAR) made it almost impossible for users to figure out what policy they had specified.\r\n\r\nThat may be a warning - Keep It Simple.",
          "createdAt": "2024-03-02T19:23:28Z",
          "updatedAt": "2024-03-02T19:23:28Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Merged #62. Closing.",
          "createdAt": "2024-03-03T06:48:12Z",
          "updatedAt": "2024-03-03T06:48:12Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "I_kwDOKZ8QO85_vAFp",
      "title": "Figure out versioning",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/52",
      "state": "OPEN",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rohanmahy"
      ],
      "labels": [
        "WG reviewed",
        "ready-for-PR"
      ],
      "body": "Figure out if versioning of endpoints includes different options inside the same framing, or a whole new endpoint, discovered by the directory, or something else.",
      "createdAt": "2024-02-19T19:33:42Z",
      "updatedAt": "2025-02-27T03:44:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "body": "WG review: We don't yet really understand what the requirements are here. Do we want to allow in-band protocol version disparities?\r\n\r\nPotential requirement: do all the providers participating in a room need to support the same version?",
          "createdAt": "2024-05-08T17:53:39Z",
          "updatedAt": "2024-05-08T17:53:39Z"
        },
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "I haven't yet caught up on the discussion at the interim, so apologies if I've missed something here.\r\n\r\nThe protocol may have multiple disparate versions associated with it:\r\n\r\n* The policy profile, and any rules associated with that policy.\r\n* The synchronization approach for participation and membership, if any.\r\n* The actual transport layer/HTTP endpoints.\r\n* Encoding formats at the above levels, potentially.\r\n\r\nAt the transport level there should be some support for versioning which is not bound to the room/group itself. Servers should be able to negotiate with each other the versions of endpoints without affecting the overall room operation (in most cases). Where a room behaviour *requires* a certain operation to take place, that would obviously have impact and need to be taken into consideration. For example, a non-MLS room may require certain transport considerations to exist, though within those considerations versioning can be applied to upgrade/change body encoding and similar.\r\n\r\nPolicy and user/client synchronization may not require explicit versioning in the protocol, though a concept of \"this room is replaced by X\" may need to exist. For example, formalizing what an MLS ReInit looks like in user experience terms, and reflecting that back as protocol capability.",
          "createdAt": "2024-05-11T02:19:43Z",
          "updatedAt": "2024-05-11T02:19:43Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "body": "@rohanmahy  says he can take a stab at solving this.\r\n@raphaelrobert says his team has been looking at this too.\r\n\r\nAt a minimum, this is about explicitly indicating the protocol version in use in-band so that providers can refuse to talk to another provider.\r\n\r\nClients also need to participate here to deal with changes to content format or MLS profile.",
          "createdAt": "2024-12-04T17:27:57Z",
          "updatedAt": "2024-12-04T17:27:57Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "I_kwDOKZ8QO85_vDF3",
      "title": "Define the specific form that identifiers take in MIMI",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/53",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "IETF-119"
      ],
      "body": "",
      "createdAt": "2024-02-19T19:44:14Z",
      "updatedAt": "2024-02-29T16:30:51Z",
      "closedAt": "2024-02-29T16:30:51Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "DT call 2024-02-28:\r\n* @rohanmahy thinks URIs are the way to go.  Flexibility + compartmentalize vendor specifics\r\n* @bifurcation and @raphaelrobert are more focused on requirements for identitiers -- what does an identifier need to do?\r\n    * User/room -- connect to a provider, identify resource within a provider\r\n    * Requirement to route to the MIMI app from outside the MIMI context?\r\n* @ara4n points out that there are some cases where you want non-provider-specific identifiers\r\n    * General feeling that (a) we will need provider-scoped things, and (b) mapping/discovery can add provider-independent stuff later\r\n* @bifurcation Proposal: Make a simple URI scheme following the [Matrix URI scheme](https://github.com/matrix-org/matrix-spec-proposals/blob/main/proposals/2312-matrix-uri.md )\r\n    * `mimi://example.com/` \r\n    * `mimi://example.com/u/bifurcation`\r\n    * `mimi://example.com/d/bifurcation/uuid`\r\n    * `mimi://example.com/r/clubhouse`\r\n* @rohanmahy to make a PR\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2024-02-28T16:47:41Z",
          "updatedAt": "2024-02-28T16:47:59Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "2 notes of things that are slightly different in PR #59  from what was discussed on the design team call\r\n- the client/device identifier is shown as `mimi://example.com/d/{clientId}` but could have one or more path segments after the `/d/`.\r\n- I added an MLS group identifier in case we want it to separately have a domain identifier. It is easy to remove if we don't want it.",
          "createdAt": "2024-02-29T00:27:46Z",
          "updatedAt": "2024-02-29T00:28:40Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as PR #59 was merged.",
          "createdAt": "2024-02-29T16:30:51Z",
          "updatedAt": "2024-02-29T16:30:51Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "I_kwDOKZ8QO85_vTpN",
      "title": "Clarify handling of duplicate messages",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/54",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "IETF-119"
      ],
      "body": "",
      "createdAt": "2024-02-19T20:35:54Z",
      "updatedAt": "2024-02-29T21:25:53Z",
      "closedAt": "2024-02-29T21:25:53Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "DT call 2024-02-28:\r\n* Problem: Hub might think that a `/notify` failed and retry, recipient needs a way to dedup\r\n* Alternatives:\r\n    * Explicit transaction ID set by hub\r\n    * Hash of `/notify` request body (=> no need for an explicit identifier in protocol)\r\n* Either way, recipient needs to keep a strike list of things it has already seen\r\n* Proposal: Add text that says you can dedup by hash, add discussion of tradeoffs\r\n* @bifurcation to make a PR on this\r\n",
          "createdAt": "2024-02-28T17:04:11Z",
          "updatedAt": "2024-02-28T17:04:11Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "COLLABORATOR",
          "body": "Adding the arguments against using hashes that were discussed in the DT call 2024-02-28:\r\n - Hashes introduce the requirement that message content must be unique. This blurs the abstraction lines between the protocol levels. E.g. it might be fine to send the exact same message repeatedly at a higher level of the protocol, but those message would be be delivered because the transport layer considers them to be duplicates.\r\n - Messages that are retransmitted must now always be identical. This requirement is probably easier to meet than the first one, but it's there nonetheless.",
          "createdAt": "2024-02-28T17:12:53Z",
          "updatedAt": "2024-02-28T17:12:53Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing with PR #60 merged.",
          "createdAt": "2024-02-29T21:25:53Z",
          "updatedAt": "2024-02-29T21:25:53Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "I_kwDOKZ8QO85_vcd3",
      "title": "Make sure endpoint, and protocol are included in any MIMI signatures",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/55",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-19T21:07:46Z",
      "updatedAt": "2024-03-04T16:28:39Z",
      "closedAt": "2024-03-04T16:28:39Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok this only seems to apply to groupInfo/ requests and reponses. I made sure the Protocol is included. What threat are we solving by including the request endpoint?",
          "createdAt": "2024-03-01T23:20:36Z",
          "updatedAt": "2024-03-01T23:20:36Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "My main concern was to ensure that sender and recipient agree on what kind of request they're making. But now that I think about that's probably covered by including the payload name as label in the signature context. I think this is good to be closed as long as we keep properly labelling when signing.",
          "createdAt": "2024-03-04T16:28:39Z",
          "updatedAt": "2024-03-04T16:28:39Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "I_kwDOKZ8QO86ApTsj",
      "title": "Return timestamp to message sender",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/56",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The timestamp in fanout messages needs to be returned to the sender of the message upon accceptance by the DS. This is to make sure that the sender shares the same view of the group's message history as the rest of the group.",
      "createdAt": "2024-02-28T07:40:45Z",
      "updatedAt": "2024-02-29T06:47:28Z",
      "closedAt": "2024-02-29T06:47:28Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Address in PR #58 ",
          "createdAt": "2024-02-29T06:47:28Z",
          "updatedAt": "2024-02-29T06:47:28Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "I_kwDOKZ8QO86BLlLy",
      "title": "Make more ASCII art flow changes",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/68",
      "state": "OPEN",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WG reviewed",
        "chore"
      ],
      "body": "- [ ]  Make ASCII art fit in 72 characters (only done so far for Bob Adds Cathy flow)\r\n- [ ]  Show fanouts to multiple servers and clients closer/tighter in time? \r\n- [ ]  Show fanouts to Clients of final commits (done for Bob leaves room flow)\r\n- [ ]  Consider a consistent order of Servers and Clients\r\n- [ ]  Overall make all ascii art diagrams in the document consistent",
      "createdAt": "2024-03-04T16:50:55Z",
      "updatedAt": "2025-02-28T21:46:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "body": "WG review: this is something we'd do before last call, to sync artwork up with where the protocol ends up. Still relevant, but no immediate action needed.",
          "createdAt": "2024-05-08T17:54:54Z",
          "updatedAt": "2024-05-08T17:54:54Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDOKZ8QO86BMBBk",
      "title": "idnits: There are 2 instances of lines with non-ascii characters in the document.",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/70",
      "state": "CLOSED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "during submission of 02 document:\r\n```\r\nidnits 2.17.00 (12 Aug 2021)\r\n\r\n/a/www/www6s/staging/draft-ralston-mimi-protocol-02.txt:\r\n\r\n  Showing Errors (**), Flaws (~~), Warnings (==), and Comments (--).\r\n  Errors MUST be fixed before draft submission.  Flaws SHOULD be fixed before draft submission.\r\n\r\n  Checking boilerplate required by [RFC 5378](https://datatracker.ietf.org/doc/rfc5378/) and the IETF Trust (see\r\n  https://trustee.ietf.org/license-info):\r\n  ----------------------------------------------------------------------------\r\n\r\n     No issues found here.\r\n\r\n  Checking nits according to https://www.ietf.org/id-info/1id-guidelines.txt:\r\n  ----------------------------------------------------------------------------\r\n\r\n  == There are 2 instances of lines with non-ascii characters in the document.\r\n\r\n\r\n  Running in submission checking mode -- *not* checking nits according to\r\n  https://www.ietf.org/id-info/checklist .\r\n  ----------------------------------------------------------------------------\r\n\r\n\r\n     Summary: 0 errors (**), 0 flaws (~~), 1 warning (==), 0 comments (--).\r\n```",
      "createdAt": "2024-03-04T17:52:14Z",
      "updatedAt": "2024-03-04T18:28:10Z",
      "closedAt": "2024-03-04T18:28:10Z",
      "comments": []
    },
    {
      "number": 77,
      "id": "I_kwDOKZ8QO86FQ9fg",
      "title": "Minimize metadata leakage",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/77",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We should avoid leaking metadata in the MIMI protocol, for example:\r\n\r\n* The number of devices used by each user\r\n* Which users are participating in which groups\r\n\r\nThe demands of policy enforcement will require some level of metadata exposure.  But we should avoid exposing metadata more broadly than is required.",
      "createdAt": "2024-04-10T14:58:07Z",
      "updatedAt": "2024-05-08T17:55:54Z",
      "closedAt": "2024-05-08T17:55:53Z",
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "body": "WG review: While this might result in protocol doc changes, the discussion is tracked in https://github.com/ietf-wg-mimi/mimi-arch/issues/15, so closing this.",
          "createdAt": "2024-05-08T17:55:53Z",
          "updatedAt": "2024-05-08T17:55:53Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDOKZ8QO86S3mOm",
      "title": "Add description of flows with pseudonyms (opt-in privacy enhancement)",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/84",
      "state": "OPEN",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [
        "WG reviewed"
      ],
      "body": "Per discussion at IETF 120, the baseline privacy will be that handshake messages are sent with SemiPrivateMessage, to provide a balance of privacy and functionality (follower server don't see the roster, but the hub can still assist with policy decisions). The use of pseudonyms needs to be explained in an end-to-end flow as their use are an important opt-in privacy option for MIMI.",
      "createdAt": "2024-08-13T19:18:20Z",
      "updatedAt": "2024-12-04T17:31:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "body": "Action here is to take PRs on the protocol doc that materialize the MIMIMI pseudonym work that has been discussed at IETF 121 and previous interims. Assigning to @kkohbrok as he is drafting the PR(s).",
          "createdAt": "2024-12-04T17:30:38Z",
          "updatedAt": "2024-12-04T17:30:38Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "I_kwDOKZ8QO86dKPNY",
      "title": "Add signature of reporter and messageId to AbuseReport",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/88",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-11-05T23:29:31Z",
      "updatedAt": "2024-12-04T17:29:10Z",
      "closedAt": "2024-12-04T17:29:10Z",
      "comments": [
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "rationale? ",
          "createdAt": "2024-11-06T20:48:34Z",
          "updatedAt": "2024-11-06T20:48:34Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "In the current version, a malicious group member (Malek) could send an abuse report impersonating another member (Alice). If used repeatedly, Alice might be banned for sending frivolous abuse reports, or Malek might \"out\" the sender of a specific message, but attribute that action to Alice instead of himself.",
          "createdAt": "2024-11-07T08:18:48Z",
          "updatedAt": "2024-11-07T08:18:48Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "This has been addressed in PR #90. Closing.",
          "createdAt": "2024-12-04T17:29:10Z",
          "updatedAt": "2024-12-04T17:29:10Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "I_kwDOKZ8QO86dXqDT",
      "title": "malicious follower can \"maul\" server frank",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/89",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "A follower provider that doesn't wish messages to be reportable as abusive could maliciously modify (\"maul\") the server frank. Without a signature by the hub, this would be undetectable by the follower client.\r\n\r\nSimilarly, the follower could modify the hub accepted timestamp. The follower client would reject the message because the franking context did not match, but would be unable to tell if the context was wrong because of a malicious or buggy sender, hub, or follower.\r\n\r\nThe hub could sign the frank (server frank, franking tag, franking context hash) and timestamp instead of protecting the server frank with an HMAC (and the timestamp with nothing).",
      "createdAt": "2024-11-07T08:13:25Z",
      "updatedAt": "2024-11-26T17:29:55Z",
      "closedAt": "2024-11-26T17:29:54Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Konrad recommended using another key from associated parties to prove integrity of the server frank",
          "createdAt": "2024-11-07T23:45:59Z",
          "updatedAt": "2024-11-07T23:45:59Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Added an integrity check inspired by Konrad's suggestion in #90 ",
          "createdAt": "2024-11-11T17:40:23Z",
          "updatedAt": "2024-11-11T17:40:23Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed. Closing.",
          "createdAt": "2024-11-26T17:29:55Z",
          "updatedAt": "2024-11-26T17:29:55Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "I_kwDOKZ8QO86e6VMx",
      "title": "Move FrankingAssertion map to mimi-content",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/91",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WG reviewed",
        "has-PR"
      ],
      "body": "The FrankingAssertion map in Section 5.4.1.1 Client creation and sending should be defined in draft-ietf-mimi-content",
      "createdAt": "2024-11-17T16:30:03Z",
      "updatedAt": "2025-02-28T21:44:06Z",
      "closedAt": "2025-02-28T21:44:06Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Need comment about relationship between the two documents @rohanmahy ",
          "createdAt": "2024-12-04T17:33:35Z",
          "updatedAt": "2024-12-04T17:33:35Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "With the [proposed change](https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/36) of message ID format in MIMI content, there will be a per-message salt inside the message we can use instead of the franking_secret.\r\n\r\nThe sender_URI and room_URI can be added as extensions in mimi-protocol using the MIMI content extensions registry defined in [mimi-content PR#35](https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/35).",
          "createdAt": "2024-12-16T20:06:54Z",
          "updatedAt": "2024-12-16T20:06:54Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "This is now in mimi-content PR46.",
          "createdAt": "2025-02-25T00:46:06Z",
          "updatedAt": "2025-02-25T00:46:06Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "I_kwDOKZ8QO86iBob5",
      "title": "Need MIMI Threat model",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/93",
      "state": "OPEN",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WG reviewed",
        "ready-for-PR"
      ],
      "body": "We need to have a consistent MIMI Threat Model.",
      "createdAt": "2024-12-04T17:06:02Z",
      "updatedAt": "2025-02-27T03:44:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "body": "Portions of this could end up spread across the arch and protocol documents (in the latter's security considerations).",
          "createdAt": "2024-12-04T17:07:55Z",
          "updatedAt": "2024-12-04T17:07:55Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "I_kwDOKZ8QO86jg4It",
      "title": "Try to simplify franking context and integrity",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/95",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Figure out if the context and the integrity verification can be combined, making the franking algorithm simpler.\r\n\r\nRemove the franking_context_hash and franking_context_secret\r\n\r\n```\r\ncontext = senderURI || roomURI || acceptedTimestamp\r\nserverFrank = HMAC_SHA256(HUBkey, franking_tag || context )\r\nfrank_integrity_check = HMAC_SHA256(franking_integrity_secret,\r\n  serverFrank || context)\r\n```\r\n\r\n",
      "createdAt": "2024-12-16T20:11:09Z",
      "updatedAt": "2025-02-25T00:48:20Z",
      "closedAt": "2025-02-25T00:48:19Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to close this, as the #96 is merged.",
          "createdAt": "2025-02-25T00:48:19Z",
          "updatedAt": "2025-02-25T00:48:19Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "I_kwDOKZ8QO86pzR17",
      "title": "Fanout should be able to send a batch of related handshake messages",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/103",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "has-PR"
      ],
      "body": "An update can contain multiple proposals, with or without a commit. This is effectively a transaction, since the hub either accepts or rejects them together.\n\nHowever during fanout, individual proposals could arrive substantially delayed. A client who wants to send an application message has to commit pending proposals, but does not know if/when a fanned out handshake is the last accepted pending proposal, or to expect an accepted commit. We should allow fanout to include a batch of related handshake messages.",
      "createdAt": "2025-02-12T16:35:21Z",
      "updatedAt": "2025-02-27T01:35:13Z",
      "closedAt": "2025-02-27T01:35:12Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in #106 ",
          "createdAt": "2025-02-27T01:35:12Z",
          "updatedAt": "2025-02-27T01:35:12Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "I_kwDOKZ8QO86sojo1",
      "title": "Not up-to-date releases",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/109",
      "state": "CLOSED",
      "author": "Neustradamus",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Dear @ietf-wg-mimi team,\n\nThanks for your work!\n\nI have discovered that it is old here:\n- https://github.com/ietf-wg-mimi/mimi-protocol\n- https://github.com/ietf-wg-mimi/mimi-protocol/releases\n\nLatest release is old: draft-ralston-mimi-protocol-02 (2024-03-04).\n\nCan you add all versions?\n\nHere, the ietf.org mimi group documents:\n- https://datatracker.ietf.org/group/mimi/documents/\n\nThe current is from 2025-03-03:\n- https://datatracker.ietf.org/doc/draft-ietf-mimi-protocol/\n\nThanks in advance.",
      "createdAt": "2025-03-05T06:03:00Z",
      "updatedAt": "2025-03-06T12:03:51Z",
      "closedAt": "2025-03-06T12:00:42Z",
      "comments": [
        {
          "author": "Neustradamus",
          "authorAssociation": "NONE",
          "body": "@rohanmahy: Since latest draft-ralston-mimi-protocol-02:\n- https://datatracker.ietf.org/doc/draft-ralston-mimi-protocol/\n- https://datatracker.ietf.org/doc/draft-ralston-mimi-protocol/02/\n\nThere are:\n- https://datatracker.ietf.org/doc/draft-ietf-mimi-protocol/\n- https://datatracker.ietf.org/doc/draft-ietf-mimi-protocol/00/\n- https://datatracker.ietf.org/doc/draft-ietf-mimi-protocol/01/\n- https://datatracker.ietf.org/doc/draft-ietf-mimi-protocol/02/\n- https://datatracker.ietf.org/doc/draft-ietf-mimi-protocol/03/\n\nCan you revert your latest PR and publish one by one to have the full history?\n\nThanks in advance.",
          "createdAt": "2025-03-06T11:09:26Z",
          "updatedAt": "2025-03-06T11:09:26Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "I deleted all the releases from the old repo. All WG releases are tagged.",
          "createdAt": "2025-03-06T12:00:42Z",
          "updatedAt": "2025-03-06T12:00:42Z"
        },
        {
          "author": "Neustradamus",
          "authorAssociation": "NONE",
          "body": "@rohanmahy: Thanks!",
          "createdAt": "2025-03-06T12:03:50Z",
          "updatedAt": "2025-03-06T12:03:50Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "I_kwDOKZ8QO86uJUlk",
      "title": "Add requester Credential and signature to KeyMaterial endpoint",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/110",
      "state": "OPEN",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "has-PR"
      ],
      "body": "signature of the request should also cover the room ID",
      "createdAt": "2025-03-15T03:34:33Z",
      "updatedAt": "2025-03-18T14:40:40Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 114,
      "id": "I_kwDOKZ8QO86upwn1",
      "title": "Timestamp integrity for history",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/114",
      "state": "OPEN",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently the integrity of the timestamp is available when franking, but only for active participants/member clients. It would be nice if I replace my phone, restoring my history, I can still verify the integrity of the original timestamp (and Frank). ",
      "createdAt": "2025-03-19T01:26:20Z",
      "updatedAt": "2025-03-19T01:26:20Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 115,
      "id": "I_kwDOKZ8QO86u46za",
      "title": "Implicit specification that franking-sender must include salt",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/115",
      "state": "OPEN",
      "author": "felixlinker",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Section \"Receiver verification of frank\" specifies that the receiver of a franked message must verify its tag using the embedded salt:\n\nhttps://github.com/ietf-wg-mimi/mimi-protocol/blob/5080565278e0949af3425efd8d7381312c9cc1a1/draft-ietf-mimi-protocol.md?plain=1#L1254\n\nThe specification of the sender, however, does not mention that the sender should include the salt. Just a nit and probably an oversight, but better to be fixed! :)",
      "createdAt": "2025-03-20T05:48:28Z",
      "updatedAt": "2025-04-24T19:42:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "The salt is required in every MIMI message. It is a fixed-length, fixed-type item, and is the first item in the fixed-length array that is the top level of any MIMI message.\n\nI'll see what I can write to clarify that in mimi-protocol.",
          "createdAt": "2025-04-24T19:42:21Z",
          "updatedAt": "2025-04-24T19:42:21Z"
        }
      ]
    },
    {
      "number": 116,
      "id": "I_kwDOKZ8QO86u5gOq",
      "title": "Inconsistency between sections 5.4.1.3 and 5.9",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/116",
      "state": "OPEN",
      "author": "felixlinker",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "5.4.1.3 says \u201ethe receiver needs to store the frank,\u201c (unclear which one, but I presume the server frank), 5.9 says the report must include \u201e[a messages] franks\u201c (plural!). This shouldn't change much from the perspective of security, but could lead to interoperability issues.",
      "createdAt": "2025-03-20T06:57:33Z",
      "updatedAt": "2025-03-20T07:16:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "felixlinker",
          "authorAssociation": "NONE",
          "body": "Also, the type and name of field `Frank frank;` in `AbusiveMessage` suggests it contains only a single frank.",
          "createdAt": "2025-03-20T07:08:04Z",
          "updatedAt": "2025-03-20T07:08:17Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "NONE",
          "body": "Aha, found the type definition of `Frank` in Sec 5.5., which clears up things. Nevertheless, I think 5.4.1.3 should be more explicit about what needs to be stored :)",
          "createdAt": "2025-03-20T07:16:36Z",
          "updatedAt": "2025-03-20T07:16:36Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "I_kwDOKZ8QO86u6cnl",
      "title": "AbusiveMessage does not include salt",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/117",
      "state": "OPEN",
      "author": "felixlinker",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "@rohanmahy Let me know that the the sender's salt it used to generate the initial franking tag should be included in the MIMI content of the `AbusiveMessage`. That field's type, however, is `opaque` suggesting its values shouldn't matter to implementations.",
      "createdAt": "2025-03-20T08:45:49Z",
      "updatedAt": "2025-03-20T08:45:49Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 119,
      "id": "I_kwDOKZ8QO862KiMq",
      "title": "Prevent colluding participants from overloading abuse reporting system",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/issues/119",
      "state": "OPEN",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Because the franking_integrity_hash uses a shared secret, malicious members can report non-existent messages that appear to have an acceptable franking_integrity_hash.\n\nSwitch to using a signature to validate the the integrity of the frank and context (timestamp) added by the hub.\n",
      "createdAt": "2025-05-12T09:01:23Z",
      "updatedAt": "2025-05-12T09:01:23Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOKZ8QO85d62SL",
      "title": "[WIP] Cut out excess signaling components",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/1",
      "state": "MERGED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[Rendered](https://turt2live.github.io/ietf-mimi-protocol/travis/refactor-1/draft-ralston-mimi-protocol.html)",
      "createdAt": "2023-10-26T23:19:14Z",
      "updatedAt": "2023-10-27T14:06:02Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "688fdcfeee972630881d4535b305fb80def1c658",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "travis/refactor-1",
      "headRefOid": "1e7fb575a9f5bce35e0edfc13cc897873734a878",
      "closedAt": "2023-10-27T14:05:58Z",
      "mergedAt": "2023-10-27T14:05:58Z",
      "mergedBy": "turt2live",
      "mergeCommit": {
        "oid": "f0422982ac7e16a31ff320843b6af8f082278e46"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85lZFrL",
          "commit": {
            "abbreviatedOid": "1e7fb57"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-27T06:28:54Z",
          "updatedAt": "2023-10-27T06:49:18Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "What kind of guarantee are we aiming for here?",
              "createdAt": "2023-10-27T06:28:54Z",
              "updatedAt": "2023-10-27T06:49:18Z"
            },
            {
              "originalPosition": 309,
              "body": "I think those fields are gone now.",
              "createdAt": "2023-10-27T06:29:35Z",
              "updatedAt": "2023-10-27T06:49:18Z"
            },
            {
              "originalPosition": 314,
              "body": "We might want to define the set of relevant servers a little more clearly. I think somewhere else in the doc, you define them as the servers who have users in the `join` state. Maybe we should have some terminology for the servers involved in the room. Guest/follower servers?",
              "createdAt": "2023-10-27T06:31:22Z",
              "updatedAt": "2023-10-27T06:49:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 2,
      "id": "PR_kwDOKZ8QO85eA0jT",
      "title": "Remove major MLS/DS components; Update event approach",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/2",
      "state": "MERGED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-27T22:37:55Z",
      "updatedAt": "2024-10-21T02:37:10Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "f0422982ac7e16a31ff320843b6af8f082278e46",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "travis/events-pt2",
      "headRefOid": "0b4a3ed65f9692cffe80b42466e3f0a868364450",
      "closedAt": "2023-10-30T18:20:56Z",
      "mergedAt": "2023-10-30T18:20:56Z",
      "mergedBy": "turt2live",
      "mergeCommit": {
        "oid": "48c2527f52abbd1d65cd9a6ba7da4679197a7864"
      },
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Travis,\r\n\r\nI don't think this particular list of events is helping us move forward. \r\n\r\nThe m.room.create event is out of scope of MIMI.\r\n\r\nIn the MLS case, I think we had strong consensus to use an MLS Proposal to update the participant list. So, we don't need the m.room.user event.  \r\n\r\nSending an application message does not require a signature, and sending an MLS handshake (and therefore participant list modification) in MLS does not require a signature. Therefore, we should remove them from every event. We can add a signature to the specific events that need them (ex: consent).",
          "createdAt": "2023-10-29T16:43:21Z",
          "updatedAt": "2023-10-30T00:15:28Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why do other mimi providers need to be notified about a created? It doesn't\r\nseem actionable by a remote provider. Can't they just become aware of a\r\nroom the first time one of their users is added to it?\r\n\r\nOn Sun, Oct 29, 2023, 10:06 Travis Ralston ***@***.***> wrote:\r\n\r\n> ***@***.**** commented on this pull request.\r\n> ------------------------------\r\n>\r\n> In draft-ralston-mimi-protocol.md\r\n> <https://github.com/bifurcation/ietf-mimi-protocol/pull/2#discussion_r1375474716>\r\n> :\r\n>\r\n> > @@ -200,12 +217,18 @@ struct {\r\n>  > **TODO**: Include fields for encryption information. Possibly ciphersuite and\r\n>  > similar so a server can check to ensure it supports the MLS dialect?\r\n>\r\n> +**Fanout considerations**:\r\n> +\r\n> +`CreateEvent` is *unsigned* in all cases it is used. The create event is used\r\n>\r\n> This is not being used as an advertisement to other providers. It's used\r\n> to carry information over the API because the framing is an Event. See\r\n> \"check invite\" API.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/bifurcation/ietf-mimi-protocol/pull/2#discussion_r1375474716>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AVXAIJZS7XRGONEZ7QRD62DYB2EHVAVCNFSM6AAAAAA6TONZUOVHI2DSMVQWIX3LMV43YUDVNRWFEZLROVSXG5CSMV3GSZLXHMYTOMBSHE4TMNJXGA>\r\n> .\r\n> You are receiving this because you were mentioned.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2023-10-29T20:41:38Z",
          "updatedAt": "2023-10-30T00:15:18Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Your statement is about *users*. Users of a MIMI-capable provider can\r\ncertainly create rooms and MLS groups as they like. Why is this\r\ncontroversial? By the time users on foreign providers start to get involved\r\nthere will be a room and a group, but we need to ne clear about how users\r\nend up in groups because the other users need to authorize them.\r\n-r\r\n\r\n\r\nOn Sun, Oct 29, 2023, 10:06 Travis Ralston ***@***.***> wrote:\r\n\r\n> ***@***.**** commented on this pull request.\r\n> ------------------------------\r\n>\r\n> In draft-ralston-mimi-protocol.md\r\n> <https://github.com/bifurcation/ietf-mimi-protocol/pull/2#discussion_r1375474774>\r\n> :\r\n>\r\n> > @@ -304,84 +331,47 @@ described by {{leaves}}. Accepting is done by joining ({{joins}}) the room.\r\n>  ~~~\r\n>  {: #fig-invites title=\"Invite happy path\" }\r\n>\r\n> -## Joins {#joins}\r\n> -\r\n> -A user can join a room in two ways:\r\n> -\r\n> -1. Using an external commit to Add themselves to the MLS group.\r\n> -2. Receiving a Welcome message from a joined member of the MLS group.\r\n> -\r\n>\r\n> MIMI requires signaling, which does not permit the creation of an MLS\r\n> group outside of a room.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/bifurcation/ietf-mimi-protocol/pull/2#discussion_r1375474774>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AVXAIJY23BCAC4HNHCCVB6DYB2EJRAVCNFSM6AAAAAA6TONZUOVHI2DSMVQWIX3LMV43YUDVNRWFEZLROVSXG5CSMV3GSZLXHMYTOMBSHE4TMNRSG4>\r\n> .\r\n> You are receiving this because you were mentioned.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2023-10-29T23:45:11Z",
          "updatedAt": "2023-10-30T00:18:51Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regardless what protocol you use, you will need some binding between\r\nparticipant list changes and the e2e encryption protocol. For MLS, Konrad\r\nand Raphael suggested a proposal, Tom chimed in that they do that too, and\r\nRichard and I both responded favorably. Nobody raised any objection or gave\r\na reason why we would should not.\r\nThanks,\r\n-rohan\r\n\r\nOn Sun, Oct 29, 2023, 10:10 Travis Ralston ***@***.***> wrote:\r\n\r\n> ***@***.**** commented on this pull request.\r\n> ------------------------------\r\n>\r\n> On draft-ralston-mimi-protocol.md\r\n> <https://github.com/bifurcation/ietf-mimi-protocol/pull/2#discussion_r1375475447>\r\n> :\r\n>\r\n> The m.room.create event is out of scope of MIMI.\r\n>\r\n> See\r\n> https://github.com/bifurcation/ietf-mimi-protocol/pull/2/files#r1375474716\r\n>\r\n> In the MLS case, I think we had strong consensus to use an MLS Proposal to\r\n> update the participant list. So, we don't need the m.room.user event.\r\n>\r\n> I don't agree that we had consensus on using MLS Proposals for participant\r\n> list changes. This document is shaped independently of MLS though, so\r\n> events *could* run over MLS Proposals in a different document if desired.\r\n> We should discuss this as a Design Team.\r\n>\r\n> Sending an application message does not require a signature, and sending\r\n> an MLS handshake (and therefore participant list modification) in MLS does\r\n> not require a signature. Therefore, we should remove them from every event.\r\n> We can add a signature to the specific events that need them (ex: consent).\r\n>\r\n> The application message is not signed by the protocol document (in fact,\r\n> it's been removed in this PR). Participant list events are required to be\r\n> signed because they transit multiple hops, however redactions and hash\r\n> chaining were removed in an earlier PR already.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/bifurcation/ietf-mimi-protocol/pull/2#discussion_r1375475447>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AVXAIJ3JRMCI42ZDL5EXLC3YB2EYVAVCNFSM6AAAAAA6TONZUOVHI2DSMVQWIX3LMV43YUDVNRWFEZLROVSXG5CSMV3GSZLXHMYTOMBSHE4TONBXG4>\r\n> .\r\n> You are receiving this because you were mentioned.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2023-10-29T23:56:02Z",
          "updatedAt": "2023-10-30T00:25:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85lgZ3u",
          "commit": {
            "abbreviatedOid": "0b4a3ed"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-29T16:46:09Z",
          "updatedAt": "2023-10-29T16:46:09Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "We don't require other providers to be notified when a new room is created. I don't see why we have a create event.",
              "createdAt": "2023-10-29T16:46:09Z",
              "updatedAt": "2023-10-29T16:46:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85lgZ5K",
          "commit": {
            "abbreviatedOid": "0b4a3ed"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-29T16:46:46Z",
          "updatedAt": "2023-10-29T16:46:47Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "3. Create a group and add others to it.",
              "createdAt": "2023-10-29T16:46:47Z",
              "updatedAt": "2023-10-29T16:46:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85lgafM",
          "commit": {
            "abbreviatedOid": "0b4a3ed"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-29T17:04:29Z",
          "updatedAt": "2023-10-29T17:04:30Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "(moving to a thread for replies)\r\n\r\n@rohan-wire says:\r\n\r\n> Hi Travis,\r\n> \r\n> I don't think this particular list of events is helping us move forward.\r\n> \r\n> The m.room.create event is out of scope of MIMI.\r\n> \r\n> In the MLS case, I think we had strong consensus to use an MLS Proposal to update the participant list. So, we don't need the m.room.user event.\r\n> \r\n> Sending an application message does not require a signature, and sending an MLS handshake (and therefore participant list modification) in MLS does not require a signature. Therefore, we should remove them from every event. We can add a signature to the specific events that need them (ex: consent).\r\n\r\n",
              "createdAt": "2023-10-29T17:04:30Z",
              "updatedAt": "2023-10-29T17:04:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85lgapa",
          "commit": {
            "abbreviatedOid": "0b4a3ed"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-29T17:05:51Z",
          "updatedAt": "2023-10-29T17:05:51Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "This is not being used as an advertisement to other providers. It's used to carry information over the API because the framing is an Event. See \"check invite\" API.",
              "createdAt": "2023-10-29T17:05:51Z",
              "updatedAt": "2023-10-29T17:05:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85lgaqT",
          "commit": {
            "abbreviatedOid": "0b4a3ed"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-29T17:06:21Z",
          "updatedAt": "2023-10-29T17:06:22Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "MIMI requires signaling, which does not permit the creation of an MLS group outside of a room.",
              "createdAt": "2023-10-29T17:06:21Z",
              "updatedAt": "2023-10-29T17:06:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85lga3l",
          "commit": {
            "abbreviatedOid": "0b4a3ed"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-29T17:10:23Z",
          "updatedAt": "2023-10-29T17:10:23Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "> The m.room.create event is out of scope of MIMI.\r\n\r\nSee https://github.com/bifurcation/ietf-mimi-protocol/pull/2/files#r1375474716\r\n\r\n> In the MLS case, I think we had strong consensus to use an MLS Proposal to update the participant list. So, we don't need the m.room.user event.\r\n\r\nI don't agree that we had consensus on using MLS Proposals for participant list changes. This document is shaped independently of MLS though, so events *could* run over MLS Proposals in a different document if desired. We should discuss this as a Design Team.\r\n\r\n> Sending an application message does not require a signature, and sending an MLS handshake (and therefore participant list modification) in MLS does not require a signature. Therefore, we should remove them from every event. We can add a signature to the specific events that need them (ex: consent).\r\n\r\nThe application message is not signed by the protocol document (in fact, it's been removed in this PR). Participant list events are required to be signed because they transit multiple hops, however redactions and hash chaining were removed in an earlier PR already.",
              "createdAt": "2023-10-29T17:10:23Z",
              "updatedAt": "2023-10-29T17:10:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85lgxif",
          "commit": {
            "abbreviatedOid": "0b4a3ed"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-30T00:14:24Z",
          "updatedAt": "2023-10-30T00:14:24Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "(looks like replying via email doesn't work with threads)\r\n\r\n@rohan-wire says:\r\n> Why do other mimi providers need to be notified about a created room? It doesn't seem actionable by a remote provider. Can't they just become aware of a room the first time one of their users is added to it?\r\n\r\n",
              "createdAt": "2023-10-30T00:14:24Z",
              "updatedAt": "2023-10-30T18:12:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85lgxl8",
          "commit": {
            "abbreviatedOid": "0b4a3ed"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-30T00:15:07Z",
          "updatedAt": "2023-10-30T00:15:07Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "Other providers are *not* notified. This is how they become aware of the room - there's still more work to be done on the create event contents before this is ready for review.",
              "createdAt": "2023-10-30T00:15:07Z",
              "updatedAt": "2023-10-30T00:15:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85lgxrQ",
          "commit": {
            "abbreviatedOid": "0b4a3ed"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-30T00:16:12Z",
          "updatedAt": "2023-10-30T00:16:12Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "@rohan-wire says:\r\n\r\n> Your statement is about *users*. Users of a MIMI-capable provider can certainly create rooms and MLS groups as they like. Why is this controversial? By the time users on foreign providers start to get involved there will be a room and a group, but we need to ne clear about how users end up in groups because the other users need to authorize them. -r\r\n\r\n",
              "createdAt": "2023-10-30T00:16:12Z",
              "updatedAt": "2023-10-30T00:16:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85lgx3N",
          "commit": {
            "abbreviatedOid": "0b4a3ed"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-30T00:18:37Z",
          "updatedAt": "2023-10-30T00:18:37Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "I wouldn't say it's controversial yet, but I'm having trouble understanding the motivation for the initial comment. It's on a deleted line, and doesn't include much detail. \r\n\r\nMLS groups can of course be created, but joins (where this comment is placed) happen within signaling. There's already text to permit/allow the addition of clients without user signaling messages.",
              "createdAt": "2023-10-30T00:18:37Z",
              "updatedAt": "2023-10-30T00:18:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85lgx7o",
          "commit": {
            "abbreviatedOid": "0b4a3ed"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-30T00:19:31Z",
          "updatedAt": "2023-10-30T00:19:32Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "@rohan-wire says:\r\n\r\n> Regardless what protocol you use, you will need some binding between participant list changes and the e2e encryption protocol. For MLS, Konrad and Raphael suggested [using an MLS `Proposal`], Tom chimed in that they do that too, and Richard and I both responded favorably. Nobody raised any objection or gave a reason why we would should not. Thanks, -rohan\r\n\r\n",
              "createdAt": "2023-10-30T00:19:31Z",
              "updatedAt": "2023-10-30T18:13:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85lgyVI",
          "commit": {
            "abbreviatedOid": "0b4a3ed"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-30T00:25:10Z",
          "updatedAt": "2023-10-30T00:25:10Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "There is still a binding between participant list and MLS group, though not in this document specifically. We've talked several times as a design team about how this could be done, and Konrad and I are working on formalizing that in the DS and protocol documents. We should have something up for review on Tuesday by the design team.\r\n\r\nWhat specific proposal are you speaking to? Thursday's design meeting is the state of decisions this PR is based upon (pending a re-review on Tuesday with the whole design team).",
              "createdAt": "2023-10-30T00:25:10Z",
              "updatedAt": "2023-10-30T00:25:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85lh49T",
          "commit": {
            "abbreviatedOid": "0b4a3ed"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for the PR! I think this is fine to merge for now. I'll put any changes I'd propose into a follow up PR.",
          "createdAt": "2023-10-30T07:05:28Z",
          "updatedAt": "2023-10-30T07:46:44Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "I think the name is a bit misleading at this point, as it's a bit of a vestige from when room state was event based. Now, the \"CreateEvent\" contains the static information of the room required for a new provider/user to join the room. Since the provider also needs the GroupInfo and the participant list, I think we'll condense this down to one or maybe two events.",
              "createdAt": "2023-10-30T07:05:28Z",
              "updatedAt": "2023-10-30T07:46:44Z"
            },
            {
              "originalPosition": 276,
              "body": "While it's fine to link limitations to MLS, we should probably not allude to non-MLS versions in this doc. ",
              "createdAt": "2023-10-30T07:09:03Z",
              "updatedAt": "2023-10-30T07:46:44Z"
            },
            {
              "originalPosition": 1,
              "body": "I'm working on the next set of changes that will ensure the participant list is anchored in the room's underlying MLS group state.",
              "createdAt": "2023-10-30T07:45:44Z",
              "updatedAt": "2023-10-30T07:46:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOKZ8QO85eDRbJ",
      "title": "Add Basic Operations section with Alice and Bob flow.",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/3",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-29T16:25:57Z",
      "updatedAt": "2024-10-21T02:37:20Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "d7858010d4cda7f568abbae3fc59e53cc4db6f1f",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/basic-operations",
      "headRefOid": "b07d56bb904b3c5efda5de4aa633f087c31cdf65",
      "closedAt": "2023-11-06T11:31:45Z",
      "mergedAt": "2023-11-06T11:31:45Z",
      "mergedBy": "kkohbrok",
      "mergeCommit": {
        "oid": "8ab7addb6d4b6ed4b67737225e1418200a195203"
      },
      "comments": [
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "For the record: a lot of this PR's content may be different or superceded by what Konrad and I are working on in preparation for the Design Team meeting in a couple of days.",
          "createdAt": "2023-10-29T16:31:48Z",
          "updatedAt": "2023-10-29T16:31:48Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For the record: a lot of this PR's content may be different or superceded by what Konrad and I are working on in preparation for the Design Team meeting in a couple of days.\r\n\r\nFair enough. I just wanted to have two things from this PR:\r\n\r\n- a narrative/example walkthrough of the Alice and Bob case (which can point to things defined elsewhere)\r\n- an existence proof that we can make this work for the MLS case, and that the boundary between MLS and everything is a relatively clean boundary.\r\n\r\n",
          "createdAt": "2023-10-30T18:10:30Z",
          "updatedAt": "2023-10-30T18:11:06Z"
        },
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "for the public record: Konrad is working on a PR which proposes an Alice adds Bob flow using the newly-decided MLS Proposal-framed signaling approach. It may be different from this PR, but should also be relatively similar.",
          "createdAt": "2023-10-31T19:30:54Z",
          "updatedAt": "2023-10-31T19:30:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85loF2h",
          "commit": {
            "abbreviatedOid": "1036847"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for putting this together. I do think there's value in an \"Alice adds Bob then Cathy\" flow, though I'm concerned that this PR goes into details not appropriate for this document (or already handled by other PRs/plans).\r\n\r\nIn the meantime, I've put some suggestions down to match editorial style more than anything. Very happy to discuss what's in and out of scope for the document at the design team meeting tomorrow.",
          "createdAt": "2023-10-30T20:28:18Z",
          "updatedAt": "2023-10-30T20:45:45Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nThroughout this document, the examples use the TLS Presentation Language\r\n{{!RFC8446}} and the semantics of HTTP {{!RFC7231}}. \r\n\r\n> **TODO**: Decide on binary encoding and set of transport semantics.\r\n```",
              "createdAt": "2023-10-30T20:28:18Z",
              "updatedAt": "2023-10-30T20:45:45Z"
            },
            {
              "originalPosition": 25,
              "body": "This is out of scope for the design team's considerations, for now. We assume going into this document that an internal identifier has already been discovered through some means.\r\n\r\nLater we may incorporate discovery, after the working group adopts a suitable document (or set of documents).",
              "createdAt": "2023-10-30T20:29:18Z",
              "updatedAt": "2023-10-30T20:45:45Z"
            },
            {
              "originalPosition": 41,
              "body": "I don't think we need to highlight the design team's decisions like this in the doc. For consistency, let's use the `> **TODO**: Words` syntax.",
              "createdAt": "2023-10-30T20:30:35Z",
              "updatedAt": "2023-10-30T20:45:45Z"
            },
            {
              "originalPosition": 27,
              "body": "This is just one possible flow: Alice can also create the room and *invite* Bob to it without ever requesting key material.",
              "createdAt": "2023-10-30T20:31:23Z",
              "updatedAt": "2023-10-30T20:45:45Z"
            },
            {
              "originalPosition": 32,
              "body": "The participation changes are additionally fanned out, as is Alice's message. Which message is \"the\" message here?",
              "createdAt": "2023-10-30T20:32:17Z",
              "updatedAt": "2023-10-30T20:45:45Z"
            },
            {
              "originalPosition": 46,
              "body": "As discussed, this is out of scope for now. Let's remove it until we have an agreed working group item to work from.",
              "createdAt": "2023-10-30T20:32:49Z",
              "updatedAt": "2023-10-30T20:45:45Z"
            },
            {
              "originalPosition": 116,
              "body": "```suggestion\r\n> **TODO**: Add mechanism to achieve this. See Section 6.1 \r\nof {{?I-D.mahy-mimi-transport-design-reqs}} for thoughts.\r\n```",
              "createdAt": "2023-10-30T20:34:35Z",
              "updatedAt": "2023-10-30T20:45:45Z"
            },
            {
              "originalPosition": 118,
              "body": "This feels overly specific for this document. It's covered by MIMI-DS, and referenced by https://github.com/bifurcation/ietf-mimi-protocol/pull/4 per the agreed document layout.\r\n\r\nThis section should be removed.",
              "createdAt": "2023-10-30T20:35:32Z",
              "updatedAt": "2023-10-30T20:45:45Z"
            },
            {
              "originalPosition": 209,
              "body": "Room creation is covered elsewhere in the document. Can we add relevant detail to that instead, please?",
              "createdAt": "2023-10-30T20:36:12Z",
              "updatedAt": "2023-10-30T20:45:45Z"
            },
            {
              "originalPosition": 234,
              "body": "I'm not sure this needs to be a dedicated section, but much/all of the text contained within feels overly specified compared to the rest of the document. Can we merge relevant details into the other sections, please?\r\n\r\nThis comment applies to the section headers below as well.",
              "createdAt": "2023-10-30T20:37:04Z",
              "updatedAt": "2023-10-30T20:45:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85luo0g",
          "commit": {
            "abbreviatedOid": "1036847"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-31T16:12:11Z",
          "updatedAt": "2023-10-31T16:12:12Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Just documenting one flow seems fine for this document, for now.",
              "createdAt": "2023-10-31T16:12:11Z",
              "updatedAt": "2023-10-31T16:12:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85lwEix",
          "commit": {
            "abbreviatedOid": "1036847"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-31T19:29:41Z",
          "updatedAt": "2023-10-31T19:29:41Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "(we should at least mention that there's other possible flows though, if we still have them after our latest Alice and Bob discussions)",
              "createdAt": "2023-10-31T19:29:41Z",
              "updatedAt": "2023-10-31T19:29:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mIpGE",
          "commit": {
            "abbreviatedOid": "1036847"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-03T21:15:48Z",
          "updatedAt": "2023-11-03T21:15:49Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Whether we address it or not, that step needs to happen, and an example flow needs to acknowledge that.",
              "createdAt": "2023-11-03T21:15:48Z",
              "updatedAt": "2023-11-03T21:15:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mIpeM",
          "commit": {
            "abbreviatedOid": "1036847"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-03T21:17:36Z",
          "updatedAt": "2023-11-03T21:17:36Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "We should document the most common flow *first* (Alice adds Bob), because with most messengers, if Alice \"adds\" Bob, she can send a message immediately which Bob can read after coming online (without any history passing mechanism).",
              "createdAt": "2023-11-03T21:17:36Z",
              "updatedAt": "2023-11-03T21:17:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mIpjO",
          "commit": {
            "abbreviatedOid": "1036847"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-03T21:17:57Z",
          "updatedAt": "2023-11-03T21:17:58Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "good point. it could be either.",
              "createdAt": "2023-11-03T21:17:57Z",
              "updatedAt": "2023-11-03T21:17:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mN3Cz",
          "commit": {
            "abbreviatedOid": "b07d56b"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "We will merge this PR as is and any changes will follow as part of #14.",
          "createdAt": "2023-11-06T11:31:34Z",
          "updatedAt": "2023-11-06T11:31:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 4,
      "id": "PR_kwDOKZ8QO85eJMJY",
      "title": "Describe how MIMI protocol interacts with MIMI DS",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/4",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-30T16:40:36Z",
      "updatedAt": "2024-10-21T02:37:11Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "f0422982ac7e16a31ff320843b6af8f082278e46",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "konrad/mls_integration",
      "headRefOid": "edf04deb328b29cdf555331865bc51a871ae9fa6",
      "closedAt": "2023-10-30T18:59:58Z",
      "mergedAt": "2023-10-30T18:59:58Z",
      "mergedBy": "rohan-wire",
      "mergeCommit": {
        "oid": "1036c881ded6fcf48fa724e1f83516e925818b13"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85lnl5l",
          "commit": {
            "abbreviatedOid": "edf04de"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I still have issues with the text, but it is substantially better.\r\n\r\nOne suggestion, is we rename the \"user\" in `m.room.user` to \"invite\"",
          "createdAt": "2023-10-30T18:59:45Z",
          "updatedAt": "2023-10-30T18:59:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO85ln9s5",
          "commit": {
            "abbreviatedOid": "edf04de"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "from a first pass of review",
          "createdAt": "2023-10-30T20:03:57Z",
          "updatedAt": "2023-10-30T20:27:01Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "From an API design perspective, ideally we split `DSRequest` out to individual events.",
              "createdAt": "2023-10-30T20:03:57Z",
              "updatedAt": "2023-10-30T20:27:01Z"
            },
            {
              "originalPosition": 94,
              "body": "All events sounds like a lot. Do we just need specific event types here? `m.room.user` primarily. ",
              "createdAt": "2023-10-30T20:06:16Z",
              "updatedAt": "2023-10-30T20:27:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85lqAPo",
          "commit": {
            "abbreviatedOid": "846143a"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-31T06:09:41Z",
          "updatedAt": "2023-10-31T06:09:41Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "Not a strong opinion, but I thought this was a good way of maintaining the abstraction of a cryptographic building block.",
              "createdAt": "2023-10-31T06:09:41Z",
              "updatedAt": "2023-10-31T06:09:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85lqAXL",
          "commit": {
            "abbreviatedOid": "846143a"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-31T06:10:10Z",
          "updatedAt": "2023-10-31T06:10:11Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "It should probably be \"all events that change the room state\", which currently is only m.room.user.",
              "createdAt": "2023-10-31T06:10:10Z",
              "updatedAt": "2023-10-31T06:10:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOKZ8QO85eVXVp",
      "title": "events via MLS proposals",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/5",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-01T13:19:55Z",
      "updatedAt": "2023-11-02T15:28:56Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "1036c881ded6fcf48fa724e1f83516e925818b13",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "konrad/mls_proposals",
      "headRefOid": "eaccd9007a1fc919618652c189d4aa1f55c44789",
      "closedAt": "2023-11-02T14:48:16Z",
      "mergedAt": "2023-11-02T14:48:16Z",
      "mergedBy": "rohan-wire",
      "mergeCommit": {
        "oid": "966cd0bd15b7a128de24efb8e0a9383123e39f7a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85l2M0X",
          "commit": {
            "abbreviatedOid": "ddfa781"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Overall this is looking good. We should probably spin up a plausible DoubleRatchet implementation of this document to ensure compatibility, but that doesn't need to happen for working group purposes. ",
          "createdAt": "2023-11-01T17:32:53Z",
          "updatedAt": "2023-11-01T17:45:19Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "```suggestion\r\nchange during an epoch based on room-state changing events. The changes of these\r\n```",
              "createdAt": "2023-11-01T17:32:54Z",
              "updatedAt": "2023-11-01T17:45:19Z"
            },
            {
              "originalPosition": 182,
              "body": "Is this to provide the follower an ability to propose removal of their own users' clients? It feels like a path towards hub portability, which I'm very happy to include, though not sure if we want to open that can of worms yet.",
              "createdAt": "2023-11-01T17:39:59Z",
              "updatedAt": "2023-11-01T17:45:19Z"
            },
            {
              "originalPosition": 211,
              "body": "Role and participation are very different concepts imo. They could be part of the atomic operations though, where we add a user, their clients, and promote them to admin in a single transaction/frame. \r\n\r\nDefinitely worth leaving as a TODO for now \ud83d\ude07 ",
              "createdAt": "2023-11-01T17:41:46Z",
              "updatedAt": "2023-11-01T17:45:19Z"
            },
            {
              "originalPosition": 209,
              "body": "```suggestion\r\nAn `m.room.user` event can be used to change the participation state of a user.\r\n```\r\n\r\nto avoid \"participation\" appearing twice.",
              "createdAt": "2023-11-01T17:42:23Z",
              "updatedAt": "2023-11-01T17:45:19Z"
            },
            {
              "originalPosition": 236,
              "body": "accidental edit?\r\n```suggestion\r\n   ParticipationState state;\r\n```",
              "createdAt": "2023-11-01T17:43:08Z",
              "updatedAt": "2023-11-01T17:45:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85l5jQz",
          "commit": {
            "abbreviatedOid": "eaccd90"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the review and the suggestions! I'll leave this open for a bit longer before merging, but I think it's decent enough to start building the next PR on top of it.",
          "createdAt": "2023-11-02T07:16:47Z",
          "updatedAt": "2023-11-02T07:18:05Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "Kind of. It's for the follower server to be able to send signaling messages at all (or rather for everyone else to be able to authenticate them). This is a limitation stemming from the way that proposals from external senders (i.e. senders who are not group members) are authenticated. My thinking was that if a user is part of a room, its server might want to be able to send signaling messages independent of the user's clients. If it wants to do that, it needs to be added to the list. This has to happen before the server can send any signaling messages (or at least those implemented by MLS proposals) and it can only happen via commit by a client.",
              "createdAt": "2023-11-02T07:16:47Z",
              "updatedAt": "2023-11-02T07:18:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85l801g",
          "commit": {
            "abbreviatedOid": "eaccd90"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-02T14:27:20Z",
          "updatedAt": "2023-11-02T14:47:09Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nmessages, for example, to\r\n```",
              "createdAt": "2023-11-02T14:27:20Z",
              "updatedAt": "2023-11-02T14:47:09Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\n         Proposal user_event_proposal; // see later in doc\r\n```",
              "createdAt": "2023-11-02T14:27:58Z",
              "updatedAt": "2023-11-02T14:47:09Z"
            },
            {
              "originalPosition": 79,
              "body": "This is still very awkward. I'd just add a TODO to reword it and I can work on some proposed text later.",
              "createdAt": "2023-11-02T14:30:22Z",
              "updatedAt": "2023-11-02T14:47:09Z"
            },
            {
              "originalPosition": 87,
              "body": "Isn't the DS supposed to be spread across all the clients and all the providers?  Maybe something like the \"the arbiter of the delivery service (DS)\"?\r\n\r\nFeel free to ignore this comment until later.",
              "createdAt": "2023-11-02T14:43:18Z",
              "updatedAt": "2023-11-02T14:47:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85l9beo",
          "commit": {
            "abbreviatedOid": "eaccd90"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-02T15:28:56Z",
          "updatedAt": "2023-11-02T15:28:56Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Fair point. I'll clarify that in the next PR.",
              "createdAt": "2023-11-02T15:28:56Z",
              "updatedAt": "2023-11-02T15:28:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 8,
      "id": "PR_kwDOKZ8QO85eaNNw",
      "title": "Split DS event into multiple events",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/8",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [],
      "body": "This PR restructures the MIMI DS section and splits the DSEvent struct into multiple events. ",
      "createdAt": "2023-11-02T09:07:24Z",
      "updatedAt": "2023-11-02T15:01:09Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "konrad/mls_proposals",
      "baseRefOid": "eaccd9007a1fc919618652c189d4aa1f55c44789",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "konrad/multiple_ds_events",
      "headRefOid": "8c9d38de6e9bf08e7c433920a450bbd2e6e7f324",
      "closedAt": "2023-11-02T15:01:08Z",
      "mergedAt": "2023-11-02T15:01:08Z",
      "mergedBy": "rohan-wire",
      "mergeCommit": {
        "oid": "c21cb9292e6edb0ef3753b00917e98654b13b09e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85l9FPf",
          "commit": {
            "abbreviatedOid": "78aea2a"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-02T14:55:30Z",
          "updatedAt": "2023-11-02T15:00:07Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "```suggestion\r\n  DSRequest commitBundle;\r\n```",
              "createdAt": "2023-11-02T14:55:30Z",
              "updatedAt": "2023-11-02T15:00:07Z"
            },
            {
              "originalPosition": 146,
              "body": "providers can`t use KeyPackages\r\n\r\n```suggestion\r\nGroup members can use this event to request a\r\nKeyPackage from the Hub or another follower server.\r\n```",
              "createdAt": "2023-11-02T14:59:24Z",
              "updatedAt": "2023-11-02T15:00:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOKZ8QO85ea59c",
      "title": "Adapt flows to previous changes",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/10",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-02T11:07:23Z",
      "updatedAt": "2023-11-03T21:03:02Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "konrad/multiple_ds_events",
      "baseRefOid": "78aea2a254313dc70104ceb4341ec01ccf21cf2c",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "konrad/invite_flow",
      "headRefOid": "cde6ff2dd079f55356604dc6080d0e78bc8f0d14",
      "closedAt": "2023-11-03T21:03:02Z",
      "mergedAt": "2023-11-03T21:03:02Z",
      "mergedBy": "rohan-wire",
      "mergeCommit": {
        "oid": "721df0de2d710830d652d5ae61014859bbe08e54"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85l9guD",
          "commit": {
            "abbreviatedOid": "06c2fd5"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-11-02T15:37:58Z",
          "updatedAt": "2023-11-02T15:41:36Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This is the opposite of the normal flow in most messengers. We need an Add flow and it should be first.",
              "createdAt": "2023-11-02T15:37:59Z",
              "updatedAt": "2023-11-02T15:41:36Z"
            },
            {
              "originalPosition": 185,
              "body": "Just delete the section please",
              "createdAt": "2023-11-02T15:41:27Z",
              "updatedAt": "2023-11-02T15:41:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mAlWe",
          "commit": {
            "abbreviatedOid": "06c2fd5"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-02T23:51:19Z",
          "updatedAt": "2023-11-02T23:51:20Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "The user visible behavior is that Alice adds Bob and immediately sends a message. The expectation in most messengers is that Bob's clients can view the message that Alice just sent.",
              "createdAt": "2023-11-02T23:51:19Z",
              "updatedAt": "2023-11-02T23:51:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mDvHA",
          "commit": {
            "abbreviatedOid": "06c2fd5"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-03T10:07:11Z",
          "updatedAt": "2023-11-03T10:07:11Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "There are two distinct flows here that I think we should cover.\r\n\r\n1. The \"invite\" flow, where Alice invites Bob and Bob only becomes part of the room once he has accepted the invitation, and\r\n2. the \"add\" flow, where Alice adds Bob and Bob immediately becomes a part of the room without any additional involvement by Bob.\r\n\r\nFlow 1 would be based on external commit and corresponds, for example, to Signal's flow with invite links. Flow 2 is the flow you allude to, based on Welcome, and is based on Signal's flow, where once Alice has a connection with Bob, she can add him to other groups without Bob's involvement.",
              "createdAt": "2023-11-03T10:07:11Z",
              "updatedAt": "2023-11-03T10:07:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mDxHb",
          "commit": {
            "abbreviatedOid": "06c2fd5"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-03T10:12:17Z",
          "updatedAt": "2023-11-03T10:12:17Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "The issue I see with the \"Add\" flow is that we probably want to add some degree of consent signaling, s.t. the Hub and other participants can verify that Alice has Bob's permission to Add Bob to the room. ",
              "createdAt": "2023-11-03T10:12:17Z",
              "updatedAt": "2023-11-03T10:12:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mD2xE",
          "commit": {
            "abbreviatedOid": "06c2fd5"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-03T10:25:05Z",
          "updatedAt": "2023-11-03T10:25:06Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I've added an \"Add\" flow. Let me know what you think.",
              "createdAt": "2023-11-03T10:25:05Z",
              "updatedAt": "2023-11-03T10:25:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mIM1S",
          "commit": {
            "abbreviatedOid": "cde6ff2"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-03T19:43:35Z",
          "updatedAt": "2023-11-03T19:43:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO85mINGA",
          "commit": {
            "abbreviatedOid": "06c2fd5"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-03T19:44:28Z",
          "updatedAt": "2023-11-03T19:44:28Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "looks good",
              "createdAt": "2023-11-03T19:44:28Z",
              "updatedAt": "2023-11-03T19:44:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mIl49",
          "commit": {
            "abbreviatedOid": "cde6ff2"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-03T21:02:50Z",
          "updatedAt": "2023-11-03T21:02:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDOKZ8QO85eii29",
      "title": "Generalize framing and add Response struct",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/12",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-03T13:46:29Z",
      "updatedAt": "2023-11-03T21:07:01Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "konrad/invite_flow",
      "baseRefOid": "cde6ff2dd079f55356604dc6080d0e78bc8f0d14",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "konrad/fan_out_framing",
      "headRefOid": "00e90a1bb8df6d8817771b32438236844286eb94",
      "closedAt": "2023-11-03T21:07:01Z",
      "mergedAt": "2023-11-03T21:07:01Z",
      "mergedBy": "rohan-wire",
      "mergeCommit": {
        "oid": "5d7c78c1d7b7e62769acf4d1226455e2f8322563"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85mIm7a",
          "commit": {
            "abbreviatedOid": "00e90a1"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-03T21:06:33Z",
          "updatedAt": "2023-11-03T21:06:33Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "In general, I think we need to handle \"provisional\" messages that are sent to the hub, and fanned out messages differently. The meaning of an error response to a fanout message means \"something happened and I can't deal with this fanout message now\" but the hub is at that point fully \"committed\" and could reach other clients. Whereas a message en route to the hub could be rejected and won't make it to any clients.",
              "createdAt": "2023-11-03T21:06:33Z",
              "updatedAt": "2023-11-03T21:06:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mIm-W",
          "commit": {
            "abbreviatedOid": "00e90a1"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-03T21:06:39Z",
          "updatedAt": "2023-11-03T21:06:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDOKZ8QO85eio-K",
      "title": "Split MIMI DS event",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/13",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [],
      "body": "Re-creating this PR, because it got lost due to weird merge ordering.",
      "createdAt": "2023-11-03T14:00:56Z",
      "updatedAt": "2024-10-21T02:37:13Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "966cd0bd15b7a128de24efb8e0a9383123e39f7a",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "konrad/mls_proposals",
      "headRefOid": "c21cb9292e6edb0ef3753b00917e98654b13b09e",
      "closedAt": "2023-11-03T14:01:03Z",
      "mergedAt": "2023-11-03T14:01:03Z",
      "mergedBy": "kkohbrok",
      "mergeCommit": {
        "oid": "c20afb858a2e72342e12facb3322bff732f8d2d2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 14,
      "id": "PR_kwDOKZ8QO85ejHdz",
      "title": "Adapt Alice - Bob flow",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/14",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR changes the Alice Bob flow in #3 to the current state of the document.\r\n\r\nIt changes from an Add based flow to the invite-based flow we discussed in the last interim. This is just to simplify things for the IETF 118 meeting.",
      "createdAt": "2023-11-03T15:13:18Z",
      "updatedAt": "2024-10-21T02:37:27Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "d7858010d4cda7f568abbae3fc59e53cc4db6f1f",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "konrad/patch_basic_operations",
      "headRefOid": "b7d9f2038e0188cb2ef603cf8e73471d3913f70c",
      "closedAt": "2023-11-06T15:02:49Z",
      "mergedAt": "2023-11-06T15:02:49Z",
      "mergedBy": "kkohbrok",
      "mergeCommit": {
        "oid": "7df540142940a03925fc66b7727c31301e6b7747"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85mInk0",
          "commit": {
            "abbreviatedOid": "0fca48f"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I suggest we commit PR #3 and modify it to use the correct structs and have the same issues and TODOs. I am willing to do the work to make that happen on the flight to Prague tomorrow",
          "createdAt": "2023-11-03T21:09:12Z",
          "updatedAt": "2023-11-03T21:14:37Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "```suggestion\r\nAlice obtains Bob's internal identifier. \r\n\r\n**ISSUE** In the course of discovering Bob, Alice might or might not\r\nobtain a list of Bob's clients.\r\n```",
              "createdAt": "2023-11-03T21:09:12Z",
              "updatedAt": "2023-11-03T21:14:37Z"
            },
            {
              "originalPosition": 135,
              "body": "The add case is *much* more common than the invite case. We need to support both, but the example should start with the add case, and can optionally include the invite case (for example, to invite Cathy).",
              "createdAt": "2023-11-03T21:12:44Z",
              "updatedAt": "2023-11-03T21:14:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mPs3V",
          "commit": {
            "abbreviatedOid": "2273474"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-06T14:49:12Z",
          "updatedAt": "2023-11-06T14:49:13Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\n\r\nAlice fetches the internal identifier for some field of Bob's, in\r\nthis example his handle.\r\n\r\n~~~\r\nGET /identifierDiscovery/{domain}\r\n~~~\r\n\r\nThe request body is described as:\r\n\r\n~~~ tls\r\nenum {\r\n  reserved(0),\r\n  handle(1),\r\n  nick(2),\r\n  email(3),\r\n  phone(4),\r\n  partialName(5),\r\n  wholeProfile(6),\r\n  oidcStdClaim(7),\r\n  vcardField(8),\r\n  (255)\r\n} IdentifierType;\r\n\r\nstruct {\r\n  IdentifierType type;\r\n  string searchValue;\r\n  select(type) {\r\n     case oidcStdClaim:\r\n       string claimName;\r\n    case vcardField:\r\n       string fieldName;\r\n  };\r\n} IdentifierRequest;\r\n\r\n~~~\r\n\r\nThe response body is described as:\r\n\r\n~~~ tls\r\nenum {\r\n  success(0),\r\n  notFound(1),\r\n  ambiguous(2),\r\n  forbidden(3),\r\n  unsupportedField(4),\r\n  (255)\r\n} IdentifierDiscoveryCode;\r\n\r\nstruct {\r\n  IdentifierDiscoverCode responseCode;\r\n  IdentifierUri uri;\r\n} IdentifierResponse;\r\n~~~\r\n\r\n```",
              "createdAt": "2023-11-06T14:49:13Z",
              "updatedAt": "2023-11-06T14:49:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mPuFm",
          "commit": {
            "abbreviatedOid": "2273474"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-06T14:51:13Z",
          "updatedAt": "2023-11-06T14:51:14Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "```suggestion\r\n\r\nThis is an example/placeholder for a possibly more sophisticated discovery\r\nmechanism. It is not intended to be directly implemented.\r\n\r\n> **TODO**: Replace with or reference a discovery mechanism with WG consensus\r\n\r\n```",
              "createdAt": "2023-11-06T14:51:14Z",
              "updatedAt": "2023-11-06T14:51:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mPv6_",
          "commit": {
            "abbreviatedOid": "2273474"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-06T14:53:51Z",
          "updatedAt": "2023-11-06T14:53:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO85mPxkt",
          "commit": {
            "abbreviatedOid": "2273474"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-06T14:56:37Z",
          "updatedAt": "2023-11-06T14:57:16Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "```suggestion\r\n\u2020 as mentioned in the text, creating a room is a local provider\r\n```",
              "createdAt": "2023-11-06T14:56:38Z",
              "updatedAt": "2023-11-06T14:57:16Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\n- Alice get the internal identifier for Bob\r\n- Alice gains consent to talk to Bob\r\n- Alice fetches initial keying material for Bob's clients\r\n- (Alice create a room) \u2020\r\n```",
              "createdAt": "2023-11-06T14:56:55Z",
              "updatedAt": "2023-11-06T14:57:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mPy2y",
          "commit": {
            "abbreviatedOid": "5db00f0"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-06T14:58:42Z",
          "updatedAt": "2023-11-06T14:58:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOKZ8QO85epewm",
      "title": "Re-merge PR due to wrong merge order ",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/15",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-06T06:31:34Z",
      "updatedAt": "2024-10-21T02:37:19Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "c20afb858a2e72342e12facb3322bff732f8d2d2",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "konrad/fan_out_framing",
      "headRefOid": "3f338070cfd33cbd8cf2de26c1f69901a7bd7835",
      "closedAt": "2023-11-06T06:32:15Z",
      "mergedAt": "2023-11-06T06:32:15Z",
      "mergedBy": "kkohbrok",
      "mergeCommit": {
        "oid": "d7858010d4cda7f568abbae3fc59e53cc4db6f1f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "PR_kwDOKZ8QO85eqDsi",
      "title": "Update links and metadata for new repo location",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/16",
      "state": "MERGED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-06T08:22:28Z",
      "updatedAt": "2023-11-06T19:46:37Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "d7858010d4cda7f568abbae3fc59e53cc4db6f1f",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "travis/metadata",
      "headRefOid": "e93168538d8f509f7b8875d2146a176fe51d2481",
      "closedAt": "2023-11-06T10:57:32Z",
      "mergedAt": "2023-11-06T10:57:32Z",
      "mergedBy": "kkohbrok",
      "mergeCommit": {
        "oid": "56ed1ca1a0b5f1cca20a1155ea66f5333fafe63d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85mNNOH",
          "commit": {
            "abbreviatedOid": "e931685"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-06T10:20:40Z",
          "updatedAt": "2023-11-06T10:20:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOKZ8QO85erDAl",
      "title": "Rename create event and add more information",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/17",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-06T10:56:41Z",
      "updatedAt": "2024-10-21T02:37:22Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "d7858010d4cda7f568abbae3fc59e53cc4db6f1f",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "konrad/create_rename",
      "headRefOid": "35a5fba63511c7cff68d4ecebdcd1b90c110dc48",
      "closedAt": "2023-11-06T15:10:38Z",
      "mergedAt": "2023-11-06T15:10:38Z",
      "mergedBy": "rohan-wire",
      "mergeCommit": {
        "oid": "26a85ec49f9f387b7667660725620cff666c0659"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85mP20q",
          "commit": {
            "abbreviatedOid": "35a5fba"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I'm still not convinced we need this event, but info is a better name.",
          "createdAt": "2023-11-06T15:05:26Z",
          "updatedAt": "2023-11-06T15:05:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOKZ8QO85eswpF",
      "title": "Rewrite abstract and intro",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/18",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-06T14:49:00Z",
      "updatedAt": "2024-10-21T02:37:23Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "8ab7addb6d4b6ed4b67737225e1418200a195203",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "konrad/intro_abstract",
      "headRefOid": "a5b994ac8fae41dfbf14ab623285086426a7e291",
      "closedAt": "2023-11-06T15:03:07Z",
      "mergedAt": "2023-11-06T15:03:06Z",
      "mergedBy": "rohan-wire",
      "mergeCommit": {
        "oid": "46f4a959473dc32dba7a90dca218f914c67b3422"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85mP0f7",
          "commit": {
            "abbreviatedOid": "a5b994a"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-06T15:01:35Z",
          "updatedAt": "2023-11-06T15:01:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 19,
      "id": "PR_kwDOKZ8QO85es3c2",
      "title": "Authors and contributors",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/19",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-06T15:03:55Z",
      "updatedAt": "2024-10-21T02:37:26Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "46f4a959473dc32dba7a90dca218f914c67b3422",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "konrad/authors_and_contributors",
      "headRefOid": "2b9271acbd4dc829963cab0d57693dbc8dc139bf",
      "closedAt": "2023-11-06T15:11:29Z",
      "mergedAt": "2023-11-06T15:11:29Z",
      "mergedBy": "rohan-wire",
      "mergeCommit": {
        "oid": "60b7abc90a11256e3ba71ba39c562ebc29f6595d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85mP6a-",
          "commit": {
            "abbreviatedOid": "2b9271a"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-06T15:11:21Z",
          "updatedAt": "2023-11-06T15:11:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 20,
      "id": "PR_kwDOKZ8QO85es6P4",
      "title": "Remove extraneous m. in front of room events",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/20",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "consensus-required"
      ],
      "body": "globally replace `m.room.` with `room.` in event names.",
      "createdAt": "2023-11-06T15:09:57Z",
      "updatedAt": "2024-10-21T02:37:28Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "cf29470de209e35fbdb7db010a572fe59adaec54",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/event-namespace",
      "headRefOid": "b2d8061fba74b709538b2d0ebd8e36a7d41fb1c5",
      "closedAt": "2024-02-09T22:08:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I'm inclined to leave this for the WG to comment on.  The traditional IETF approach to something like this would be to have an IANA registry where certain values are registered (those that would be `m.` here) and certain values would be vendor space (I believe the Matrix pattern for these is `com.example.foo`).  If we were talking about numerical code points, the analogy would be exact, since if you know the range of numbers reserved for vendor usage (\u2248 non-`m.` here), you can look at a value and tell if it's registered or vendor.\r\n\r\nFor text-like registries, things are a little less clear.  Traditionally, these registries don't have an explicit vendor reservation, since space is not constrained.  (See, e.g., the [ACME directory metadata fields registry](https://www.iana.org/assignments/acme/acme.xhtml#acme-directory-metadata-fields).)  If you want a value for some proprietary thing, you just choose one and use it, and if some official thing later collides with it, oh well.  And in cases where there were explicit affordances for experimental (e.g., `X-` and `P-` in HTTP/SIP headers), those affordances [are now deprecated](https://datatracker.ietf.org/doc/html/rfc6648).\r\n\r\nSo it's not immediately clear to me what the right answer is here, and how to do extensibility seems like a good question for the WG to weigh in on.",
          "createdAt": "2023-11-06T20:12:25Z",
          "updatedAt": "2023-11-06T20:12:25Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "As an outside viewer, I assumed those names to be placeholders (obviously based on Matrix `m.` prefix). You don't want to send those names around in the binary protocol on the wire in the end and should use an enum instead, along the lines of\r\n\r\n```\r\nenum EventType {\r\n  RoomInfo = 1;\r\n  RoomUser = 2;\r\n  ...\r\n  Vendor(string) = 255;\r\n}\r\n```",
          "createdAt": "2024-02-07T12:12:12Z",
          "updatedAt": "2024-02-07T12:12:12Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing as this is superfluous in PR #50 ",
          "createdAt": "2024-02-09T22:08:21Z",
          "updatedAt": "2024-02-09T22:08:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85mShQi",
          "commit": {
            "abbreviatedOid": "b2d8061"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "see threaded comment",
          "createdAt": "2023-11-06T19:54:09Z",
          "updatedAt": "2023-11-06T19:54:27Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "The prefix exists to ensure namespacing is possible, as folks may want to add their own event types to the protocol. For example, to accomplish DoubleRatchet use cases. \r\n\r\nIt was my intention to also prefix the DS events with `m.` for consistency and building the official namespace. The namespace needs to be codified in the IANA registry still, but that was largely assumed to be a later problem.\r\n\r\n`m.` is shorthand for `mimi.`, which we can expand if needed.",
              "createdAt": "2023-11-06T19:54:09Z",
              "updatedAt": "2023-11-06T19:54:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mTHFe",
          "commit": {
            "abbreviatedOid": "b2d8061"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-06T21:37:40Z",
          "updatedAt": "2023-11-06T21:37:40Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "I propose we use `private.` and a reverse domain name label for namespacing of private events. \r\nMIMI  events then can use room for room events, ds for ds events, etc. ",
              "createdAt": "2023-11-06T21:37:40Z",
              "updatedAt": "2023-11-06T21:37:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mTKyd",
          "commit": {
            "abbreviatedOid": "b2d8061"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-06T21:40:08Z",
          "updatedAt": "2023-11-06T21:40:08Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "To clarify, you're suggesting the protocol document use `room.user`, and others use `private.org.example.dr.whatever`?",
              "createdAt": "2023-11-06T21:40:08Z",
              "updatedAt": "2023-11-06T21:40:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mV1sE",
          "commit": {
            "abbreviatedOid": "b2d8061"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-07T07:36:21Z",
          "updatedAt": "2023-11-07T07:36:21Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "yes",
              "createdAt": "2023-11-07T07:36:21Z",
              "updatedAt": "2023-11-07T07:36:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mV3J6",
          "commit": {
            "abbreviatedOid": "b2d8061"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-07T07:38:25Z",
          "updatedAt": "2023-11-07T07:38:26Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "and if we use an enum managed by IANA then we can use `room` and `dr` but the `dr` constant might be initially in the private range.",
              "createdAt": "2023-11-07T07:38:25Z",
              "updatedAt": "2023-11-07T07:38:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mYNR5",
          "commit": {
            "abbreviatedOid": "b2d8061"
          },
          "author": "ara4n",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-07T13:00:17Z",
          "updatedAt": "2023-11-07T13:00:17Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "> you're suggesting the protocol document use `room.user`, and others use `private.org.example.dr.whatever`?\r\n\r\nthis feels clunky in the extreme, imo. the privileged reversed-DNS namespace for 'official' specced types is a well understood pattern which works well for Java (`java.*`) and friends - while giving a warm branding fuzzy to everyone else who then goes off-spec on their own domain (`com.acme.*`) without having to beat them over the head with `private.` every time they send a message.  I'd just call it `m.room.foo` (which has the advantage that `m` can never become a gTLD,  unlike `mimi` or similar).\r\n\r\nI assume the rationale here (which seems to be missing on the PR?) is to save 2 bytes for all the `m.` prefixes flying around, frankly removing the namespace entirely for specced identifiers feels like a recipe for folks to fail to realise that a privileged space exists at all `m.`, and that they should go play in their own reverse-dns space.  Or to not realise that `private.com.foo` is a reverse-dns namespace in the first place like Java.",
              "createdAt": "2023-11-07T13:00:17Z",
              "updatedAt": "2023-11-07T13:00:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85mY839",
          "commit": {
            "abbreviatedOid": "b2d8061"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-07T14:21:16Z",
          "updatedAt": "2023-11-07T14:21:16Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "If we use an enum instead for the IANA registry then we get the best of both worlds",
              "createdAt": "2023-11-07T14:21:16Z",
              "updatedAt": "2023-11-07T14:21:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOKZ8QO85euxri",
      "title": "Consistently identify authors",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/21",
      "state": "MERGED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Per https://github.com/bifurcation/ietf-mimi-protocol/pull/19",
      "createdAt": "2023-11-06T19:40:55Z",
      "updatedAt": "2023-11-06T20:08:48Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "790b99e249d98851ca8b478db9cafbcc15f123b0",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "travis/authors",
      "headRefOid": "735045dac03d86291c0848c1385d010533444aa4",
      "closedAt": "2023-11-06T20:08:44Z",
      "mergedAt": "2023-11-06T20:08:44Z",
      "mergedBy": "turt2live",
      "mergeCommit": {
        "oid": "a4ea56cb0a9ddc5aab3050f9cdec61505ae58876"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85mSmIv",
          "commit": {
            "abbreviatedOid": "735045d"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-06T20:07:21Z",
          "updatedAt": "2023-11-06T20:07:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOKZ8QO85evDJc",
      "title": "Formatting consistency and typo fixes",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/22",
      "state": "MERGED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-06T20:33:27Z",
      "updatedAt": "2023-11-06T20:34:44Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "a4ea56cb0a9ddc5aab3050f9cdec61505ae58876",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "travis/editorial",
      "headRefOid": "6d8e23d3629f14244501966b4ae581e1ce6ce96b",
      "closedAt": "2023-11-06T20:34:13Z",
      "mergedAt": "2023-11-06T20:34:13Z",
      "mergedBy": "turt2live",
      "mergeCommit": {
        "oid": "4142c96d80511a35880c2c536031928072dbc20d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85mSwyP",
          "commit": {
            "abbreviatedOid": "6d8e23d"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-06T20:34:02Z",
          "updatedAt": "2023-11-06T20:34:02Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "calling this out specifically as something we discussed in the design team and was relatively easy to add here. Wording may need further adjustment.",
              "createdAt": "2023-11-06T20:34:02Z",
              "updatedAt": "2023-11-06T20:34:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 39,
      "id": "PR_kwDOKZ8QO85fTFO3",
      "title": "Remove outdated TODO",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/39",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [],
      "body": "Closes #37.\r\n\r\nWe already have an Add and an Invite flow, which I think solves this TODO.",
      "createdAt": "2023-11-13T13:04:41Z",
      "updatedAt": "2024-10-21T02:37:29Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "4142c96d80511a35880c2c536031928072dbc20d",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "konrad/remove_todo",
      "headRefOid": "3c5a1f54ef5fa04ec152444fd2ea9041ea785dd5",
      "closedAt": "2023-11-14T07:21:14Z",
      "mergedAt": "2023-11-14T07:21:14Z",
      "mergedBy": "kkohbrok",
      "mergeCommit": {
        "oid": "af62be86e01834c228d8bfc068fb383c0cdd20b2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85m_nOX",
          "commit": {
            "abbreviatedOid": "3c5a1f5"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "thanks!",
          "createdAt": "2023-11-13T18:24:56Z",
          "updatedAt": "2023-11-13T18:24:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "PR_kwDOKZ8QO85lYBxX",
      "title": "Update abstract",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/41",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Consolidates paragraphs.  Expands on functionality.  Rephrases the E2E security section to list assurances and remove citations.",
      "createdAt": "2024-01-29T20:59:26Z",
      "updatedAt": "2024-10-21T02:37:34Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "af62be86e01834c228d8bfc068fb383c0cdd20b2",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "abstract",
      "headRefOid": "0e6876a0d0ea413d97dccff03e86bd9482fef159",
      "closedAt": "2024-01-31T00:51:39Z",
      "mergedAt": "2024-01-31T00:51:39Z",
      "mergedBy": "rohan-wire",
      "mergeCommit": {
        "oid": "b775606f779086dfb27b93a7bc1dad600ce4a8c1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85uRfKY",
          "commit": {
            "abbreviatedOid": "7a462a6"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-30T01:36:11Z",
          "updatedAt": "2024-01-30T01:36:11Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO85uamG_",
          "commit": {
            "abbreviatedOid": "7a462a6"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "extremely minor editorial comment, but lgtm",
          "createdAt": "2024-01-30T22:08:22Z",
          "updatedAt": "2024-01-30T22:09:01Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nintegrates the Messaging Layer Security (MLS) protocol to provide end-to-end security\r\n```",
              "createdAt": "2024-01-30T22:08:22Z",
              "updatedAt": "2024-01-30T22:09:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 42,
      "id": "PR_kwDOKZ8QO85lYGQ7",
      "title": "Update Introduction and add Known Gaps",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/42",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The Known Gaps section might need some updating depending on what we do with the rest of the document.",
      "createdAt": "2024-01-29T21:10:19Z",
      "updatedAt": "2024-10-21T02:37:39Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "af62be86e01834c228d8bfc068fb383c0cdd20b2",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "intro",
      "headRefOid": "65edb486fd03cdcef8a372f881b2a8936458604b",
      "closedAt": "2024-02-02T21:10:15Z",
      "mergedAt": "2024-02-02T21:10:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1301edecda602fad2511c158950b0660fa657722"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85uRgJ1",
          "commit": {
            "abbreviatedOid": "34a2255"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-30T01:38:59Z",
          "updatedAt": "2024-01-30T01:40:06Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nof a protocol framework to indicate how to add other necessary functionality.  The\r\n```",
              "createdAt": "2024-01-30T01:38:59Z",
              "updatedAt": "2024-01-30T01:40:06Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nstores initial keying material and consent for its own users (who may be offline).\r\n```",
              "createdAt": "2024-01-30T01:39:14Z",
              "updatedAt": "2024-01-30T01:40:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85uXk2u",
          "commit": {
            "abbreviatedOid": "34a2255"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the PR. Made an initial pass with a few questions and remarks.",
          "createdAt": "2024-01-30T15:48:52Z",
          "updatedAt": "2024-01-30T15:57:32Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Is there a reason we're distinguishing between \"maintains the policy and participation for the room\" and then later in the sentence \"and is responsible for (...) the participation list, and policy of its rooms\"?",
              "createdAt": "2024-01-30T15:48:52Z",
              "updatedAt": "2024-01-30T15:57:32Z"
            },
            {
              "originalPosition": 33,
              "body": "We should be more clear here what it means to \"store consent\". At least it's not clear to me.",
              "createdAt": "2024-01-30T15:49:20Z",
              "updatedAt": "2024-01-30T15:57:32Z"
            },
            {
              "originalPosition": 38,
              "body": "What does it mean to \"share room policy\"? Agreement between providers? Or participants?\r\n\r\nIn any case, the other two examples seem more natural in the context of \"messaging application functionality\", so I'd put them first.",
              "createdAt": "2024-01-30T15:50:26Z",
              "updatedAt": "2024-01-30T15:57:32Z"
            },
            {
              "originalPosition": 92,
              "body": "If we do want to keep a list (I think another PR removes existing remarks about missing things), we should add authentication here. We do have basic MLS authentication, but we should also be able to verify cryptographically, that a given user belongs to a given provider.",
              "createdAt": "2024-01-30T15:57:05Z",
              "updatedAt": "2024-01-30T15:57:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85uYxPC",
          "commit": {
            "abbreviatedOid": "34a2255"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-30T17:53:00Z",
          "updatedAt": "2024-01-30T17:53:01Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I meant maintains the policy and participation as *enforcing* the policy and participation. It's also the source of truth (\"responsible\") for the \"message ordering, the participation list, and policy of its rooms\".\r\n\r\nFeel free free to propose some alternate wording.",
              "createdAt": "2024-01-30T17:53:00Z",
              "updatedAt": "2024-01-30T17:53:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85uYyBF",
          "commit": {
            "abbreviatedOid": "34a2255"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-30T17:54:42Z",
          "updatedAt": "2024-01-30T17:54:43Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "if a user has granted, revoked, or rejected consent, that needs to get stored at their provider so the provider can act on behalf of the user if his or clients are offline.",
              "createdAt": "2024-01-30T17:54:43Z",
              "updatedAt": "2024-01-30T17:54:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85uYyXP",
          "commit": {
            "abbreviatedOid": "34a2255"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-30T17:55:32Z",
          "updatedAt": "2024-01-30T17:55:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I'd say \"share room policy\" is between participants and the hub.",
              "createdAt": "2024-01-30T17:55:32Z",
              "updatedAt": "2024-01-30T17:55:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85uamc9",
          "commit": {
            "abbreviatedOid": "34a2255"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Mentions of consent outside the known gaps section should be elided for now.",
          "createdAt": "2024-01-30T22:09:25Z",
          "updatedAt": "2024-01-30T22:18:28Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nThe More Instant Messaging Interoperability (MIMI) transport protocol enables providers of\r\n```",
              "createdAt": "2024-01-30T22:09:25Z",
              "updatedAt": "2024-01-30T22:18:28Z"
            },
            {
              "originalPosition": 33,
              "body": "in my opinion, we should descope consent for now. It needs a lot more thought as to how it works.\r\n\r\n```suggestion\r\nstores initial keying material for its own users (who may be offline).\r\n```",
              "createdAt": "2024-01-30T22:11:46Z",
              "updatedAt": "2024-01-30T22:18:28Z"
            },
            {
              "originalPosition": 45,
              "body": "descoping consent: \r\n```suggestion\r\nIn support of these functions, the protocol also has primitives to fetch initial\r\nkeying material and fetch the current state of the underlying end-to-end encryption\r\nprotocol for the room.\r\n```",
              "createdAt": "2024-01-30T22:14:13Z",
              "updatedAt": "2024-01-30T22:18:28Z"
            },
            {
              "originalPosition": 52,
              "body": "```suggestion\r\nparticipant in the room, and that all clients in the group agree on the state\r\n```",
              "createdAt": "2024-01-30T22:15:07Z",
              "updatedAt": "2024-01-30T22:18:28Z"
            },
            {
              "originalPosition": 72,
              "body": "This is a bit too vague: what flows specifically are we descoping from this version?",
              "createdAt": "2024-01-30T22:16:34Z",
              "updatedAt": "2024-01-30T22:18:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85ubhMQ",
          "commit": {
            "abbreviatedOid": "34a2255"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T00:55:11Z",
          "updatedAt": "2024-01-31T00:55:11Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "This statement merely says that the providers are responsible for keeping track of the consent of their users, which should be non-controversial. This section / PR doesn't impose any specific mechanism for doing so.",
              "createdAt": "2024-01-31T00:55:11Z",
              "updatedAt": "2024-01-31T00:55:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85ubiiA",
          "commit": {
            "abbreviatedOid": "34a2255"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T01:00:34Z",
          "updatedAt": "2024-01-31T01:00:35Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Richard wanted to make a join flow easy to understand by the WG, get consensus to make it a WG item, then add other join mechanisms. So in this version I think Richard wants to start with the \"member adds non-member\" flow. \r\n\r\nI'm fine (keen even) to add a second flow where a user adds a new client or a user already on a participant list (passively) does an external join, but only if we have strong consensus from the design team. \r\n\r\n@turt2live are you OK with that plan of action?",
              "createdAt": "2024-01-31T01:00:34Z",
              "updatedAt": "2024-01-31T01:00:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85uc25o",
          "commit": {
            "abbreviatedOid": "34a2255"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T07:35:52Z",
          "updatedAt": "2024-01-31T07:35:52Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Thanks for clarifying. I'd be okay to leave it as is for now and touch it again once we know more about how consent works.",
              "createdAt": "2024-01-31T07:35:52Z",
              "updatedAt": "2024-01-31T07:35:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85uc6s4",
          "commit": {
            "abbreviatedOid": "ee93db8"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T07:46:52Z",
          "updatedAt": "2024-01-31T07:46:52Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Something like this? \r\n```suggestion\r\nbecome participants in the room.  The hub provider is responsible for message ordering and distribution, as well as policy enforcement. It also keeps a copy of the room state, which includes the room's policy and participant list, which it can provide to new joiners. Each provider also\r\n```\r\nI wouldn't say it's the \"source of truth\", since the truth is in the MLS group state and the MLS commits. Saying it's the source of truth (to me) implies that it has direct control over it. It stores the group state, but the group state ultimately comes from the clients (even though the hub can reject commits it doesn't like).",
              "createdAt": "2024-01-31T07:46:52Z",
              "updatedAt": "2024-01-31T07:46:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85uc9Rj",
          "commit": {
            "abbreviatedOid": "ee93db8"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T07:54:06Z",
          "updatedAt": "2024-01-31T07:54:06Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "It still sounds a bit weird to me, but I don't want to nitpick too much here. Let's leave it as is for now.",
              "createdAt": "2024-01-31T07:54:06Z",
              "updatedAt": "2024-01-31T07:54:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85uc_Uw",
          "commit": {
            "abbreviatedOid": "ee93db8"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T07:59:34Z",
          "updatedAt": "2024-01-31T07:59:34Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Maybe something like this?\r\n```suggestion\r\nAuthentication\r\n: While MLS provides basic message authentication, users should also be able to (cryptographically) tie the identity of other users to their respective providers. Further authentication such as tying clients to their users (or the user's other clients) may also be desirable.\r\n```",
              "createdAt": "2024-01-31T07:59:34Z",
              "updatedAt": "2024-01-31T07:59:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85ugXXu",
          "commit": {
            "abbreviatedOid": "ee93db8"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T15:08:22Z",
          "updatedAt": "2024-01-31T15:08:23Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "```suggestion\r\nidentifier.  This document provides no mechanism for such resolution.\r\n\r\n```",
              "createdAt": "2024-01-31T15:08:23Z",
              "updatedAt": "2024-01-31T15:08:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85ugk-i",
          "commit": {
            "abbreviatedOid": "7abe231"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T15:20:13Z",
          "updatedAt": "2024-01-31T15:20:14Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nbecome participants in the room. The hub provider is responsible for ordering\r\nand distributing messages, enforcing policy, and authorizing messages. It also\r\nkeeps a copy of the room state, which includes the room policy and participant\r\nlist, which it can provide to new joiners. Each provider also\r\n```",
              "createdAt": "2024-01-31T15:20:13Z",
              "updatedAt": "2024-01-31T15:20:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85umd5-",
          "commit": {
            "abbreviatedOid": "c20adfa"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for making the changes! Looks good to me now.",
          "createdAt": "2024-02-01T06:03:27Z",
          "updatedAt": "2024-02-01T06:03:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO85umfJO",
          "commit": {
            "abbreviatedOid": "ee93db8"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-01T06:05:30Z",
          "updatedAt": "2024-02-01T06:05:30Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "The text looks good now, except that I don't quite get what the difference between \"enforcing policy\" and \"authorizing messages\" is. My understanding was that authorizing messages (or not) is part of policy enforcement.",
              "createdAt": "2024-02-01T06:05:30Z",
              "updatedAt": "2024-02-01T06:05:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85u41J3",
          "commit": {
            "abbreviatedOid": "34a2255"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-02T21:06:01Z",
          "updatedAt": "2024-02-02T21:06:01Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Yeah, we're descoping everything besides the basic flow from this version.  The idea here is to capture the basic moving parts for one use cases, with the idea that the WG can then elaborate them to cover other use cases after adoption.",
              "createdAt": "2024-02-02T21:06:01Z",
              "updatedAt": "2024-02-02T21:06:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85u41qE",
          "commit": {
            "abbreviatedOid": "c20adfa"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-02T21:07:52Z",
          "updatedAt": "2024-02-02T21:08:17Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nstores initial keying material for its own users (who may be offline).\r\n```",
              "createdAt": "2024-02-02T21:07:52Z",
              "updatedAt": "2024-02-02T21:08:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vP_GN",
          "commit": {
            "abbreviatedOid": "65edb48"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "several days late (sorry, FOSDEM), but lgtm - thanks for applying the edits :)",
          "createdAt": "2024-02-06T22:43:29Z",
          "updatedAt": "2024-02-06T22:43:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOKZ8QO85lYKEY",
      "title": "Update terminology section",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/43",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Add reference to MLS for terminology.\r\n* Remove issues.  Everything in this document is open to change.",
      "createdAt": "2024-01-29T21:19:01Z",
      "updatedAt": "2024-10-21T02:37:33Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "af62be86e01834c228d8bfc068fb383c0cdd20b2",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "terms",
      "headRefOid": "1a9ddec906dbd525c3932ea55dc5277420614d18",
      "closedAt": "2024-01-30T17:53:06Z",
      "mergedAt": "2024-01-30T17:53:06Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a488b5950dba565bbcc9e3dc8b87e9b5977bf2bb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85uRgyB",
          "commit": {
            "abbreviatedOid": "1a9ddec"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-30T01:42:20Z",
          "updatedAt": "2024-01-30T01:42:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO85uXh7q",
          "commit": {
            "abbreviatedOid": "1a9ddec"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-30T15:45:21Z",
          "updatedAt": "2024-01-30T15:45:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO85uatHV",
          "commit": {
            "abbreviatedOid": "1a9ddec"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "\u2705 just dropping by to say I've seen this :)",
          "createdAt": "2024-01-30T22:19:48Z",
          "updatedAt": "2024-01-30T22:19:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "PR_kwDOKZ8QO85lYK3Q",
      "title": "Replace example flow with protocol overview",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/44",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Add clearer description of layering model\r\n* Add more detailed protocol flow",
      "createdAt": "2024-01-29T21:21:41Z",
      "updatedAt": "2024-10-21T02:37:37Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "b775606f779086dfb27b93a7bc1dad600ce4a8c1",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "overview",
      "headRefOid": "66a43831a302b2e93f1230fb659fddfd0d4263fa",
      "closedAt": "2024-01-31T16:49:06Z",
      "mergedAt": "2024-01-31T16:49:06Z",
      "mergedBy": "rohan-wire",
      "mergeCommit": {
        "oid": "b5c9bb1d3d1fb866adc2db9c65d08f3fbf3f530b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85uR9i4",
          "commit": {
            "abbreviatedOid": "5c034f6"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-30T04:21:37Z",
          "updatedAt": "2024-01-30T04:29:34Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "```suggestion\r\n> **NOTE:** In the full protocol, it will be necessary to have consent and access\r\n> control on these operations.  We have elided that step here in the interest of\r\n> simplicity.\r\n```",
              "createdAt": "2024-01-30T04:21:37Z",
              "updatedAt": "2024-01-30T04:29:34Z"
            },
            {
              "originalPosition": 438,
              "body": "```suggestion\r\nOne's own user leaving is slightly more complicated than removing another user,\r\nbecause the leaving user cannot remove all of their devices from the MLS group.\r\nInstead, the leave happens in three steps:\r\n```",
              "createdAt": "2024-01-30T04:28:19Z",
              "updatedAt": "2024-01-30T04:29:35Z"
            },
            {
              "originalPosition": 445,
              "body": "```suggestion\r\n2. The leaving client sends these proposals to the hub.  The hub caches the proposals.\r\n```",
              "createdAt": "2024-01-30T04:29:01Z",
              "updatedAt": "2024-01-30T04:29:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85uavnF",
          "commit": {
            "abbreviatedOid": "5c034f6"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I have mostly editorial comments on this one, with +1s for Rohan's comments.",
          "createdAt": "2024-01-30T22:26:52Z",
          "updatedAt": "2024-01-30T22:36:48Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "AppSync should probably get a section or I-D reference. Failing that, some sort of language to denote it's in the process of being defined - this currently reads as though AppSync is already part of MLS.",
              "createdAt": "2024-01-30T22:26:52Z",
              "updatedAt": "2024-01-30T22:36:49Z"
            },
            {
              "originalPosition": 214,
              "body": "```suggestion\r\nof the KeyPackages they handle, so that they can route a Welcome message for\r\n```",
              "createdAt": "2024-01-30T22:32:14Z",
              "updatedAt": "2024-01-30T22:36:49Z"
            },
            {
              "originalPosition": 306,
              "body": "```suggestion\r\nthe same two steps (KeyPackage fetch followed by Add), but this time indirected via the\r\n```",
              "createdAt": "2024-01-30T22:33:22Z",
              "updatedAt": "2024-01-30T22:36:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85uc17e",
          "commit": {
            "abbreviatedOid": "5c034f6"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looks good to me modulo existing comments and the ongoing discussion around the AppSync PR.",
          "createdAt": "2024-01-31T07:33:19Z",
          "updatedAt": "2024-01-31T07:33:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO85uhnh7",
          "commit": {
            "abbreviatedOid": "66a4383"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T16:48:40Z",
          "updatedAt": "2024-01-31T16:48:40Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Agreed. We'll add that once PR #45 is merged (possibly with that PR)",
              "createdAt": "2024-01-31T16:48:40Z",
              "updatedAt": "2024-01-31T16:48:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 45,
      "id": "PR_kwDOKZ8QO85lYOM_",
      "title": "Add the MLS AppSync mechanism",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/45",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-01-29T21:31:42Z",
      "updatedAt": "2024-10-21T02:37:35Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "af62be86e01834c228d8bfc068fb383c0cdd20b2",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "appsync",
      "headRefOid": "c8f5e18209f9d18f563e213fed44940a834e6816",
      "closedAt": "2024-02-02T20:54:36Z",
      "mergedAt": "2024-02-02T20:54:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7a6a998aac6726255a51ed3d597107e02e365216"
      },
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Do I understand correctly, that there can be only one ApplicationState per appliction_id? In that case, each application can only have one map/array/etc.? What if the application needs different data structures or multiple of one kind?\r\n\r\nEach application_id contains one top-level map/array/etc. An application can have multiple application_ids (each representing a specific type of application state). In barnes-mimi-protocol we proposed two application_ids (participant list, and room base policy). If an application _id needs a complex structure, the top level data structure for each application_id could be a map (which can contain arbitrarily complex data structures below it) or it could be an irreducible blob.\r\n\r\n> More generally, I'm a bit concerned about the introduction of the application_id since it's not part of MLS negotiation mechanism. It's not relevant to MLS interop, because the semantics of the application are outside of MLS, but it seems relevant that clients can signal support for a given application, or that a group can require that an application be supported. I guess what I'm trying to say is that either there is agreement between clients on the application that runs on top of MLS in which case we don't need an application_id, or there isn't, in which case we need a negotiation mechanism.\r\n\r\nI would say the later, but do we need that negotiation in MLS? I was thinking that existence of specific application IDs in the GroupContext means that that state does exist in the group. I think adding a new application ID to the GroupContext would require agreement in a GroupContextExtension proposal or out of band, but I think that negotiation is ok at the app level. I could be convinced otherwise however.\r\n\r\n> \r\n> Regarding opaque vs. non-opaque state, I think I have a slight preference for letting the application handle the AppSync proposals and modify the state itself. The current design seems a bit clunky and limiting.\r\n\r\nI can totally accept that considering I put it together in about 45 minutes. My main motivation was to allow a patch to one element of the participant list or one setting of many to be a small patch instead of, for example, sending the entire participant list of 1000 users just to add or remove one. Anything that accomplishes that goal, or a demonstration that the bandwidth/processing is a non-issue, would make me more comfortable with the opaque blob model.",
          "createdAt": "2024-01-30T16:25:14Z",
          "updatedAt": "2024-01-30T16:25:14Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the clarifications!\r\n\r\nI'm not sure it's a great idea on the one hand for applications to require an application_id per piece of state they want to store and on the other hand have application_id be IANA registered. My suggestion would be that each application use an extension id and then define its own AppSync mechanism. This allows the application to define an arbitrary number of proposals with arbitrary semantics, as well as arbitrary state to store in the group context.",
          "createdAt": "2024-01-31T07:25:33Z",
          "updatedAt": "2024-01-31T07:25:33Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Thanks for the clarifications!\r\n> \r\n> I'm not sure it's a great idea on the one hand for applications to require an application_id per piece of state they want to store and on the other hand have application_id be IANA registered. My suggestion would be that each application use an extension id and then define its own AppSync mechanism. This allows the application to define an arbitrary number of proposals with arbitrary semantics, as well as arbitrary state to store in the group context.\r\n\r\nApplications can still define arbitrary semantics of their state, they just don't get arbitrary patching semantics in AppSync. If the thing that you want to change is irreducible, replace the whole thing. If the thing you want to change is a map, list, or array, you can replace/delete/insert into those oft-used data structures without resending the entire (possibly large) data structure. That's all. If folks only want \"replace the whole thing\" semantics, I can live with that, but I am definitely not ok with having the patch semantics vary per application. I've seen that protocol movie before and it bombed.",
          "createdAt": "2024-01-31T15:03:50Z",
          "updatedAt": "2024-01-31T15:03:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85uR5jr",
          "commit": {
            "abbreviatedOid": "8602a91"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-30T03:58:33Z",
          "updatedAt": "2024-01-30T04:09:19Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n**TODO:** This section should be moved to its own document in the MLS working group.\r\n```",
              "createdAt": "2024-01-30T03:58:33Z",
              "updatedAt": "2024-01-30T04:09:19Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nintegrate their state into this metadata in order to confirm that the members of\r\n```",
              "createdAt": "2024-01-30T03:59:09Z",
              "updatedAt": "2024-01-30T04:09:19Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\n> **NOTE:** This design exposes the high-level structure of the application state\r\n> to MLS.  An alternative design would be to have the application state be opaque\r\n> to MLS.  There is a trade-off between generality and the complexity of the API\r\n> between the MLS implementation and the application.  An opaque design would give\r\n> the application more freedom, but require the MLS stack to call out to the\r\n> application to get the updated state as part of Commit processing.  This design\r\n> allows the updates to happen within the MLS stack, so that no callback is\r\n> needed, at the cost of forcing the application state to fit a certain structure.\r\n> It also potentially can result in smaller state updates in large groups.\r\n```",
              "createdAt": "2024-01-30T04:02:06Z",
              "updatedAt": "2024-01-30T04:09:19Z"
            },
            {
              "originalPosition": 47,
              "body": "```suggestion\r\n~~~ tls\r\nenum {\r\n    irreducible(0),\r\n    map(1),\r\n    unorderedList(2),\r\n    orderedArray(3),\r\n    (255)\r\n} StateType;\r\n\r\nstruct {\r\n```",
              "createdAt": "2024-01-30T04:06:04Z",
              "updatedAt": "2024-01-30T04:09:19Z"
            },
            {
              "originalPosition": 139,
              "body": "```suggestion\r\nAppSync proposals do not need to contain an UpdatePath. An AppSync proposal can\r\nbe sent by an authorized external sender.\r\n```",
              "createdAt": "2024-01-30T04:08:45Z",
              "updatedAt": "2024-01-30T04:09:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85uXha9",
          "commit": {
            "abbreviatedOid": "8602a91"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Do I understand correctly, that there can be only one ApplicationState per appliction_id? In that case, each application can only have one map/array/etc.? What if the application needs different data structures or multiple of one kind?\r\n\r\nMore generally, I'm a bit concerned about the introduction of the application_id since it's not part of MLS negotiation mechanism. It's not relevant to MLS interop, because the semantics of the application are outside of MLS, but it seems relevant that clients can signal support for a given application, or that a group can require that an application be supported. I guess what I'm trying to say is that either there is agreement between clients on the application that runs on top of MLS in which case we don't need an application_id, or there isn't, in which case we need a negotiation mechanism.\r\n\r\nRegarding opaque vs. non-opaque state, I think I have a slight preference for letting the application handle the AppSync proposals and modify the state itself. The current design seems a bit clunky and limiting.",
          "createdAt": "2024-01-30T15:44:32Z",
          "updatedAt": "2024-01-30T15:44:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO85ua2Lj",
          "commit": {
            "abbreviatedOid": "8602a91"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm, though I'm not an MLS expert. Some of the system design characteristics might change over time, I suspect.",
          "createdAt": "2024-01-30T22:45:55Z",
          "updatedAt": "2024-01-30T22:46:22Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Should this get the same quoted TODO treatment as the others?",
              "createdAt": "2024-01-30T22:45:55Z",
              "updatedAt": "2024-01-30T22:46:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85ua6Yn",
          "commit": {
            "abbreviatedOid": "8602a91"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-30T22:57:41Z",
          "updatedAt": "2024-01-30T22:57:41Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Clarifying question: can the server see the contents of the application state?",
              "createdAt": "2024-01-30T22:57:41Z",
              "updatedAt": "2024-01-30T22:57:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85ubkJz",
          "commit": {
            "abbreviatedOid": "8602a91"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T01:08:51Z",
          "updatedAt": "2024-01-31T01:08:52Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "The hub sees everything, all the servers see all the changes sent in AppState proposals or in GroupContextExtension proposals. We haven't specified if the complete application state needs to be conveyed to other providers at the time a Welcome is received. ",
              "createdAt": "2024-01-31T01:08:52Z",
              "updatedAt": "2024-01-31T01:08:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85ugOOB",
          "commit": {
            "abbreviatedOid": "8602a91"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T14:53:25Z",
          "updatedAt": "2024-01-31T14:53:26Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "```suggestion\r\n> **TODO:** IANA registry for `application_id`; register extension and proposal types\r\n>as safe extensions\r\n```",
              "createdAt": "2024-01-31T14:53:25Z",
              "updatedAt": "2024-01-31T14:57:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 47,
      "id": "PR_kwDOKZ8QO85mMnXU",
      "title": "Add sections introducing layering",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/47",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-06T22:36:43Z",
      "updatedAt": "2024-10-21T02:38:34Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "0186460b95b5977bd0b850948a4010b93e62cdd6",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/layer-sections",
      "headRefOid": "c0d8f83455effb0c7a3f43fe2e4c574cf1c315c4",
      "closedAt": "2024-02-09T22:28:04Z",
      "mergedAt": "2024-02-09T22:28:04Z",
      "mergedBy": "rohan-wire",
      "mergeCommit": {
        "oid": "36ad4767944db62e4b270460f06f2e6dfd98adef"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85vQAGz",
          "commit": {
            "abbreviatedOid": "77cd1b7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "generally lgtm - mostly clarifying comments contained within. Thanks!",
          "createdAt": "2024-02-06T22:47:25Z",
          "updatedAt": "2024-02-06T22:51:55Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "The `From` header I think needs further discussion with the working group - it feels like abuse of the header to me. Ideally we don't try to wedge ourselves into a header if that header isn't capable of clearly and semantically representing our use case - a new header or mechanism may be required, which is fine imo.",
              "createdAt": "2024-02-06T22:47:25Z",
              "updatedAt": "2024-02-06T22:51:55Z"
            },
            {
              "originalPosition": 34,
              "body": "Every message meaning user/instant message, or MLS Message? (please clarify in text)",
              "createdAt": "2024-02-06T22:48:42Z",
              "updatedAt": "2024-02-06T22:51:55Z"
            },
            {
              "originalPosition": 51,
              "body": "should this be converted to the quoted comment style we seem to have adopted elsewhere?",
              "createdAt": "2024-02-06T22:50:18Z",
              "updatedAt": "2024-02-06T22:51:55Z"
            },
            {
              "originalPosition": 68,
              "body": "`fetch-key-material` looks like it's supposed to be a link?",
              "createdAt": "2024-02-06T22:51:06Z",
              "updatedAt": "2024-02-06T22:51:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vQdzJ",
          "commit": {
            "abbreviatedOid": "77cd1b7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-06T23:59:30Z",
          "updatedAt": "2024-02-06T23:59:31Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "it was, but it relies on PR #48 ",
              "createdAt": "2024-02-06T23:59:31Z",
              "updatedAt": "2024-02-06T23:59:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vQfRW",
          "commit": {
            "abbreviatedOid": "77cd1b7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-07T00:00:56Z",
          "updatedAt": "2024-02-07T00:00:56Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nEvery application message sent within a room is authenticated and confidentiality-protected\r\nby virtue of being encapsulated in an MLS PrivateMessage object.\r\n```",
              "createdAt": "2024-02-07T00:00:56Z",
              "updatedAt": "2024-02-07T00:00:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vQf1p",
          "commit": {
            "abbreviatedOid": "77cd1b7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-07T00:01:25Z",
          "updatedAt": "2024-02-07T00:01:25Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "```suggestion\r\n> **TODO**: A little more needs to be said here about how MLS is used.  For\r\nexample: What types of credential are required / allowed?  If servers are going\r\nto be allowed to introduce room changes, how are their keys provisioned as\r\nexternal signers?\r\n```",
              "createdAt": "2024-02-07T00:01:25Z",
              "updatedAt": "2024-02-07T00:01:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vpzie",
          "commit": {
            "abbreviatedOid": "77cd1b7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T21:33:37Z",
          "updatedAt": "2024-02-09T21:33:37Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "```suggestion\r\n`keyMaterial` endpoint discussed in fetch-key-material [TODO: link].  To support this\r\n```",
              "createdAt": "2024-02-09T21:33:37Z",
              "updatedAt": "2024-02-09T21:33:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vpzvV",
          "commit": {
            "abbreviatedOid": "77cd1b7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T21:34:22Z",
          "updatedAt": "2024-02-09T21:34:23Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I agree that `From` is an awkward fit.  But if we agree that *some* HTTP header is OK, then we can leave this as a stub and let the WG opine on how to make it better.",
              "createdAt": "2024-02-09T21:34:22Z",
              "updatedAt": "2024-02-09T21:34:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vp0ce",
          "commit": {
            "abbreviatedOid": "68e9356"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T21:36:14Z",
          "updatedAt": "2024-02-09T21:36:14Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n* The source provider is indicated using a From header {{!RFC9110}}.  The\r\n  `mailbox` production in the From header MUST use the `addr-spec` variant, and\r\n  the `local-part` of the address MUST contain the fixed string `mimi`.  Thus,\r\n  the content of the From header will be `mimi@a.example`, where `a.example` is\r\n  the domain name of the source provider.\r\n  \r\n[[ NOTE: The use of the From header field here is not really well-aligned with its\r\nintended use.  The WG should consider whether this is correct, or whether a new\r\nheader field would be better.  Perhaps something like \"From-Host\" to match Host? ]]\r\n```",
              "createdAt": "2024-02-09T21:36:14Z",
              "updatedAt": "2024-02-09T21:36:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vp0hY",
          "commit": {
            "abbreviatedOid": "68e9356"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-09T21:36:32Z",
          "updatedAt": "2024-02-09T21:36:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 48,
      "id": "PR_kwDOKZ8QO85mM8pi",
      "title": "Incorporate the basic mechanism described in the example flows.",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/48",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-06T23:50:23Z",
      "updatedAt": "2024-10-21T02:37:40Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "0186460b95b5977bd0b850948a4010b93e62cdd6",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/basic-mechanism",
      "headRefOid": "db2fbf28327aa020b69dcf3ad063f7e3657561d7",
      "closedAt": "2024-02-09T19:30:17Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This is a partial review based on the diff presented. It looks like something went very sideways with the diff though - would you be able to restructure the changes to make the diff parsable please?\r\n\r\nIf we had support for stacked diffs this would be easier. I suppose I could redo a new equivalent PR with individual commits: one commit deleting, one commit adding, then one or more commits modifying things that reference the new content. I find it hard to get a clean diff from git for large markdown changes. Git way too aggressively looks for one common word dozens of lines in the middle of a replacement.\r\n\r\nIf you have any concrete suggestions @turt2live @bifurcation please let me know.\r\n",
          "createdAt": "2024-02-07T20:00:16Z",
          "updatedAt": "2024-02-07T20:00:16Z"
        },
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "It appears as though Git is getting confused with which text is \"first\", which commonly happens when new text is added above modified text. It may help to put the net-new sections below the modified/deleted sections of the existing text.",
          "createdAt": "2024-02-08T19:48:17Z",
          "updatedAt": "2024-02-08T19:48:17Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It appears as though Git is getting confused with which text is \"first\", which commonly happens when new text is added above modified text. It may help to put the net-new sections below the modified/deleted sections of the existing text.\r\n\r\nReplaced with PR #50 . I'll close this one in favor of the other.",
          "createdAt": "2024-02-09T19:30:17Z",
          "updatedAt": "2024-02-09T19:30:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85vX2lP",
          "commit": {
            "abbreviatedOid": "17f9300"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is a partial review based on the diff presented. It looks like something went very sideways with the diff though - would you be able to restructure the changes to make the diff parsable please?",
          "createdAt": "2024-02-07T18:37:04Z",
          "updatedAt": "2024-02-07T18:51:38Z",
          "comments": [
            {
              "originalPosition": 236,
              "body": "```suggestion\r\nThe target user's identifier is listed in the request path. KeyPackages\r\n```",
              "createdAt": "2024-02-07T18:37:04Z",
              "updatedAt": "2024-02-07T18:51:38Z"
            },
            {
              "originalPosition": 270,
              "body": "I think we ideally generify the identifier shape for now, at least until the working group has identifier discussions (and more specifically, URI shape/use).\r\n\r\nFor now we can probably just call this `Identifier` with an `opaque id<V>; // TODO: Define shape` property",
              "createdAt": "2024-02-07T18:39:20Z",
              "updatedAt": "2024-02-07T18:51:38Z"
            },
            {
              "originalPosition": 439,
              "body": "```suggestion\r\nits `KeyPackageRef` with the target provider. This ensures that Welcome messages\r\n```",
              "createdAt": "2024-02-07T18:40:39Z",
              "updatedAt": "2024-02-07T18:51:38Z"
            },
            {
              "originalPosition": 597,
              "body": "why would the hub be unresponsive? this isn't a client-server endpoint, so there's no feedback to provide with respect to the error here.",
              "createdAt": "2024-02-07T18:43:39Z",
              "updatedAt": "2024-02-07T18:51:38Z"
            },
            {
              "originalPosition": 768,
              "body": "consistency:\r\n\r\n```suggestion\r\n      MLSMessage appMessage;\r\n```",
              "createdAt": "2024-02-07T18:44:11Z",
              "updatedAt": "2024-02-07T18:51:38Z"
            },
            {
              "originalPosition": 970,
              "body": "(yes, I think we do, but that's a different PR/issue's concern imo)",
              "createdAt": "2024-02-07T18:45:15Z",
              "updatedAt": "2024-02-07T18:51:38Z"
            },
            {
              "originalPosition": 978,
              "body": "```suggestion\r\nparticipants in the room and all local clients which are active members.\r\n```",
              "createdAt": "2024-02-07T18:45:36Z",
              "updatedAt": "2024-02-07T18:51:38Z"
            },
            {
              "originalPosition": 1125,
              "body": "There should something to this effect somewhere: \"the Hub MUST NOT accept changes which are non-compliant with the room's policy, and similarly MUST NOT decline changes which are compliant with the room's policy\"\r\n\r\nThis is to prevent arbitrary rules from being created/enforced by the hub.",
              "createdAt": "2024-02-07T18:49:09Z",
              "updatedAt": "2024-02-07T18:51:38Z"
            },
            {
              "originalPosition": 1152,
              "body": "sorry, it took me until this line to realize that the diff is really weird and broken. Would you be able to structure the changes so the diff is usable?",
              "createdAt": "2024-02-07T18:50:48Z",
              "updatedAt": "2024-02-07T18:51:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vYdQt",
          "commit": {
            "abbreviatedOid": "17f9300"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-07T20:05:09Z",
          "updatedAt": "2024-02-07T20:05:10Z",
          "comments": [
            {
              "originalPosition": 270,
              "body": "Is there any reason _NOT_ to use a URI?  A URI allows us to encapsulate existing and new identifiers without collisions, and we can trivially include a URI into certificates and into MLS data structures. I think this first property is absolutely essential. I also can't think of any other solution which gives us that property and can be included in X.509 certificates which already work with RFC5280.\r\n\r\nTo be clear, there is no need to agree on a specific URI scheme or schemes.",
              "createdAt": "2024-02-07T20:05:09Z",
              "updatedAt": "2024-02-07T20:05:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vYfBw",
          "commit": {
            "abbreviatedOid": "17f9300"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-07T20:07:56Z",
          "updatedAt": "2024-02-07T20:07:56Z",
          "comments": [
            {
              "originalPosition": 597,
              "body": "many of these provider interfaces will be decomposed, especially in a high availability environment. This would be the case if the ingress is functioning and the specific service or even the database was not working.  Think of this as analogous to a 503 HTTP response.",
              "createdAt": "2024-02-07T20:07:56Z",
              "updatedAt": "2024-02-07T20:07:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vYhWm",
          "commit": {
            "abbreviatedOid": "17f9300"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-07T20:14:20Z",
          "updatedAt": "2024-02-07T20:14:20Z",
          "comments": [
            {
              "originalPosition": 1152,
              "body": "@turt2live \r\nYou were nearly though the PR by this point. Maybe you would be able to review the remaining 5 paragraphs and bullet list changes to the Acknowledgements? Perhaps using the rich diff mode?",
              "createdAt": "2024-02-07T20:14:20Z",
              "updatedAt": "2024-02-07T20:14:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vYkSv",
          "commit": {
            "abbreviatedOid": "17f9300"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-07T20:21:37Z",
          "updatedAt": "2024-02-07T20:21:37Z",
          "comments": [
            {
              "originalPosition": 1125,
              "body": "> There should something to this effect somewhere: \"the Hub MUST NOT accept changes which are non-compliant with the room's policy, and similarly MUST NOT decline changes which are compliant with the room's policy\"\r\n> \r\n> This is to prevent arbitrary rules from being created/enforced by the hub.\r\n\r\nI think normative language like this should be in the `/update` endpoint section. \r\n\r\nI would be wary of the \"MUST NOT decline\" for things like rate limiting and spam/abuse prevention. As well, the hub may have sent a valid external AppSync proposal which crossed an otherwise valid commit on the wire. I think it should be up to the hub whether it a) accepts the valid commit and resends its proposal, or b) rejects the commit with suitable information (incorporate proposal ref xyz)  and have the provider's client retry.\r\n\r\n",
              "createdAt": "2024-02-07T20:21:37Z",
              "updatedAt": "2024-02-07T20:21:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vhtrX",
          "commit": {
            "abbreviatedOid": "17f9300"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-08T19:34:57Z",
          "updatedAt": "2024-02-08T19:34:57Z",
          "comments": [
            {
              "originalPosition": 270,
              "body": "There are certainly good reasons to use a URI, but I don't feel we've sufficiently discussed the concept to consider it having consensus yet. In the interest of progress, we should remove the mention here and talk about it as a working group post-adoption.",
              "createdAt": "2024-02-08T19:34:57Z",
              "updatedAt": "2024-02-08T19:34:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vhuXF",
          "commit": {
            "abbreviatedOid": "17f9300"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-08T19:36:11Z",
          "updatedAt": "2024-02-08T19:36:11Z",
          "comments": [
            {
              "originalPosition": 597,
              "body": "why can't we use HTTP 503 then? I'd be a bit surprised if folks configured their reverse proxies to return MIMI-specific error codes in this case.",
              "createdAt": "2024-02-08T19:36:11Z",
              "updatedAt": "2024-02-08T19:36:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vhyqA",
          "commit": {
            "abbreviatedOid": "17f9300"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-08T19:45:26Z",
          "updatedAt": "2024-02-08T19:45:27Z",
          "comments": [
            {
              "originalPosition": 1125,
              "body": "This section sounds normative too - should it be in both?\r\n\r\nThere's certainly wording adjustments to be made to account for rate limiting, of course, though I don't think we should be allowing the hub to declare something is spam to get out of a policy obligation (for example). For the AppSync example, this sounds like a problem for sequencing: if the commit comes through before the proposal exists (even if the server knows it's generating that proposal), then it's a legitimate commit that *must* be accepted. The next commit will be required to incorporate the proposal. If the proposal is appended first though, the commit will be required to incorporate it at that time. This is all dependent on whether the protocol document actually requires the hub server's external proposals to be incorporated though - this is not something that should be an implementation detail.",
              "createdAt": "2024-02-08T19:45:27Z",
              "updatedAt": "2024-02-08T19:45:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vhzHg",
          "commit": {
            "abbreviatedOid": "17f9300"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-08T19:46:40Z",
          "updatedAt": "2024-02-08T19:46:41Z",
          "comments": [
            {
              "originalPosition": 1152,
              "body": "The side-by-side diff unfortunately doesn't really help either. I usually approach these sorts of diffs with multiple passes, but I'm finding it incredibly hard to do those passes over this PR, sorry.",
              "createdAt": "2024-02-08T19:46:41Z",
              "updatedAt": "2024-02-08T19:46:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85viTQT",
          "commit": {
            "abbreviatedOid": "17f9300"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-08T21:10:39Z",
          "updatedAt": "2024-02-08T21:10:39Z",
          "comments": [
            {
              "originalPosition": 270,
              "body": "> There are certainly good reasons to use a URI, but I don't feel we've sufficiently discussed the concept to consider it having consensus yet. In the interest of progress, we should remove the mention here and talk about it as a working group post-adoption.\r\n\r\nWe had strong guidance from the to make our proposal concrete. Nobody has proposed an alternative identifier as good as a URI or any reason not to use one, so in the interest of concreteness, I'd like to leave it a URI.",
              "createdAt": "2024-02-08T21:10:39Z",
              "updatedAt": "2024-02-08T21:10:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85viTao",
          "commit": {
            "abbreviatedOid": "17f9300"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-08T21:11:05Z",
          "updatedAt": "2024-02-08T21:11:05Z",
          "comments": [
            {
              "originalPosition": 597,
              "body": "> why can't we use HTTP 503 then? I'd be a bit surprised if folks configured their reverse proxies to return MIMI-specific error codes in this case.\r\n\r\nSure.",
              "createdAt": "2024-02-08T21:11:05Z",
              "updatedAt": "2024-02-08T21:11:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85viVx8",
          "commit": {
            "abbreviatedOid": "17f9300"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-08T21:17:41Z",
          "updatedAt": "2024-02-08T21:17:42Z",
          "comments": [
            {
              "originalPosition": 1125,
              "body": "> This section sounds normative too - should it be in both?\r\n> \r\n> There's certainly wording adjustments to be made to account for rate limiting, of course, though I don't think we should be allowing the hub to declare something is spam to get out of a policy obligation (for example). For the AppSync example, this sounds like a problem for sequencing: if the commit comes through before the proposal exists (even if the server knows it's generating that proposal), then it's a legitimate commit that _must_ be accepted. The next commit will be required to incorporate the proposal. If the proposal is appended first though, the commit will be required to incorporate it at that time. This is all dependent on whether the protocol document actually requires the hub server's external proposals to be incorporated though - this is not something that should be an implementation detail.\r\n\r\nThe hub decides what arrives first. From the hub's perspective, its external proposal was sent and fanned out and on the wire. It receives the commit later, so that commit according to the ordering policy of mimi is invalid because it does not include all valid pending proposals. The same thing could happen if Alice sends a commit to add Carol and Bob sends a proposal to remove himself. If Bob's proposal arrives first *from the hub's perspective*, Alice's Commit is invalid.\r\n\r\nIf the hub sends an otherwise valid proposal from a valid `external_sender`, the proposal needs to be incorporated. The policy remedy if a group/room doesn't want that is to configure the group without an `external_sender` for the hub and/or only join rooms without an `external_sender` configured in the corresponding room.",
              "createdAt": "2024-02-08T21:17:41Z",
              "updatedAt": "2024-02-08T21:17:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vi9gp",
          "commit": {
            "abbreviatedOid": "17f9300"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-08T23:29:21Z",
          "updatedAt": "2024-02-08T23:29:21Z",
          "comments": [
            {
              "originalPosition": 270,
              "body": "There hasn't been a proposal because, to my knowledge, it's not been considered by people yet. If we have a strong proposal to use URIs, that can remain as a PR and discussed at IETF 119, but not part of the document itself for now.",
              "createdAt": "2024-02-08T23:29:21Z",
              "updatedAt": "2024-02-08T23:29:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vi9yq",
          "commit": {
            "abbreviatedOid": "17f9300"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-08T23:30:44Z",
          "updatedAt": "2024-02-08T23:30:44Z",
          "comments": [
            {
              "originalPosition": 1125,
              "body": "I'm failing to see how that contradicts my original suggested wording, sorry.",
              "createdAt": "2024-02-08T23:30:44Z",
              "updatedAt": "2024-02-08T23:30:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vpNWN",
          "commit": {
            "abbreviatedOid": "17f9300"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T19:33:14Z",
          "updatedAt": "2024-02-09T19:33:15Z",
          "comments": [
            {
              "originalPosition": 597,
              "body": "fixed in a commit in PR #50 . resolving",
              "createdAt": "2024-02-09T19:33:15Z",
              "updatedAt": "2024-02-09T19:33:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 49,
      "id": "PR_kwDOKZ8QO85mM9Yk",
      "title": "Longer security considerations section",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/49",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-06T23:55:00Z",
      "updatedAt": "2024-10-21T02:37:42Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "0186460b95b5977bd0b850948a4010b93e62cdd6",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/security",
      "headRefOid": "f14d5b14d287e7da36376b02f1ddac933bafdf2f",
      "closedAt": "2024-02-09T22:18:48Z",
      "mergedAt": "2024-02-09T22:18:48Z",
      "mergedBy": "rohan-wire",
      "mergeCommit": {
        "oid": "5a89e4eefd3af0e16fdce155d4944553d373425d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85vX9ao",
          "commit": {
            "abbreviatedOid": "f52763d"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "otherwise lgtm",
          "createdAt": "2024-02-07T18:54:06Z",
          "updatedAt": "2024-02-07T18:54:13Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "we may need to add a note that the hub-and-spoke model allows the hub to be a threat actor itself, but is deemed appropriate for simplicity. ",
              "createdAt": "2024-02-07T18:54:06Z",
              "updatedAt": "2024-02-07T18:54:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vY75L",
          "commit": {
            "abbreviatedOid": "f52763d"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-07T21:12:19Z",
          "updatedAt": "2024-02-07T21:12:20Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "good point",
              "createdAt": "2024-02-07T21:12:19Z",
              "updatedAt": "2024-02-07T21:12:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vpyqL",
          "commit": {
            "abbreviatedOid": "f52763d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T21:30:13Z",
          "updatedAt": "2024-02-09T21:30:13Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nEach room has an authorization policy that dictates which protocol actors can\r\nperform which actions in the room.  This policy is enforced by the hub server\r\nfor the room.  The actors for whom the policy is being evaluated authenticate\r\ntheir identities to the hub server using the MLS PublicMessage signed object\r\nformat, together with the identity credentials presented in MLS.  This design\r\nmeans that the hub is trusted to correctly enforce the room's policy, but this \r\ncost is offset by the simplicity of not having multiple policy enforcement points.\r\n```",
              "createdAt": "2024-02-09T21:30:13Z",
              "updatedAt": "2024-02-09T21:30:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85vpzHM",
          "commit": {
            "abbreviatedOid": "f52763d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-09T21:31:57Z",
          "updatedAt": "2024-02-09T21:31:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 50,
      "id": "PR_kwDOKZ8QO85mg0xP",
      "title": "Incorporate the basic mechanism described in the example flows (take 2)",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/50",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As requested by Travis, this is a replacement for PR #48 which has cleaner diffs (via individual commits).",
      "createdAt": "2024-02-09T19:24:51Z",
      "updatedAt": "2024-10-21T02:38:33Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "36ad4767944db62e4b270460f06f2e6dfd98adef",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/basic-mechanism2",
      "headRefOid": "395e200a9d871d2607b1fca76f4db2409d695aba",
      "closedAt": "2024-02-20T14:23:08Z",
      "mergedAt": "2024-02-20T14:23:08Z",
      "mergedBy": "rohan-wire",
      "mergeCommit": {
        "oid": "d72db4b7a23c05d02048dfbbd50d97843a153d9a"
      },
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi, I've been through the 120 comments on this PR, created 30 commits, and created 4 new issues. Thanks to @turt2live @kkohbrok and @bifurcation for all the comments. At this point I think I have addressed all substantive comments in some way or another. Here are four specific areas where I had some doubt if I correctly interpreted one of your intentions. \r\n\r\n@turt2live I used language regarding what the hub can do as needing to be consistent with the then-current room policy and part of being consistent is presumably that you can't change it unless you had permission to change it. \r\n\r\n@turt2live one of your comments where you requested changes is blocking this, so I'm going to select \"Dismiss review\". I'm very sorry if I dropped one of your comments, but I think I incorporated all your suggestions in letter or spirit. \r\n\r\n@kkohbrok I believe removing MIMI DS but doing something that allowed clients and providers to implement a very similar MIMI DS \"API\" is what I was asked to do. If that's not what was intended, please open a separate issue or PR.\r\n\r\n@kkohbrok regarding client lifetime handling, I think this is a client issue already handled in RFC9420. If you think MIMI still needs to say something here, please open a PR or issue and I will fix it post-merge.\r\n\r\nClicking merge here in a moment. See you on the other side of this PR.\r\n",
          "createdAt": "2024-02-19T21:37:28Z",
          "updatedAt": "2024-02-19T21:37:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85v0ODV",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "DISMISSED",
          "body": "This is a first pass of the PR, trying to cover as much of the content as possible. I'll aim to do further passes over the next few days and week.\r\n\r\nSee comments contained within for details. There's a mix of editorial comments and functional changes.",
          "createdAt": "2024-02-12T18:54:11Z",
          "updatedAt": "2024-02-19T21:43:06Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "the protocol version also allows us to change the endpoints in future, making it more of a MIMI version than an encryption (MLS) version, imo. We should still be ensuring that the encryption itself is supported by all involved servers, but I think we also need a way to ratchet the MIMI stuff independent of the encryption.\r\n\r\nI think this means `Protocol` below either becomes  2 enums or has `mimi10_mls10` (for example) to denote MIMI 1.0 using MLS 1.0. Either is fine, imo.",
              "createdAt": "2024-02-12T18:54:11Z",
              "updatedAt": "2024-02-12T20:33:04Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nThe syntax of the MIMI protocol messages are described using the TLS\r\npresentation language format ({{Section 3 of RFC8446}}).\r\n\r\n> **Note**: The encoding used is extremely notional.\r\n```\r\n\r\n... or something to remind the reader that we're not actually seriously considering TLS-PL (given it has near-zero library support, but we don't want to get caught up on 'which format' debates at this stage).",
              "createdAt": "2024-02-12T18:56:08Z",
              "updatedAt": "2024-02-12T20:33:04Z"
            },
            {
              "originalPosition": 236,
              "body": "```suggestion\r\nThe target user's identifier is listed in the request path. KeyPackages\r\n```",
              "createdAt": "2024-02-12T18:57:08Z",
              "updatedAt": "2024-02-12T20:33:04Z"
            },
            {
              "originalPosition": 248,
              "body": "```suggestion\r\n(see {{mimi-endpoints-and-framing}}), and the requesting user. The request SHOULD include\r\n```\r\n\r\n(or however a section reference is done - sorry, not in front of an editor right now)",
              "createdAt": "2024-02-12T18:58:09Z",
              "updatedAt": "2024-02-12T20:33:04Z"
            },
            {
              "originalPosition": 256,
              "body": "> The `lastResortAllowed` field SHOULD be false.\r\n\r\nExpansion on the reasoning for this would be appreciated. It's obvious for those who are familiar with what last resort keys do, but that may not be every reader of the document.",
              "createdAt": "2024-02-12T18:59:40Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 270,
              "body": "re-raising thread on URIs here. I really think we should keep this as `identifier` for now, and maybe leave a note that it is most likely best represented by a URI in the doc. \r\n\r\n```suggestion\r\n    opaque identifer<V>;  /* most likely a URI */\r\n} Identifier;\r\n```",
              "createdAt": "2024-02-12T19:01:22Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 270,
              "body": "It's also not clear to me why we'd hide this away in a struct. We use it for multiple purposes, but it still only has a single field. Does TLS-PL support type aliasing? ",
              "createdAt": "2024-02-12T19:02:45Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 370,
              "body": "we should define the difference between user unknown and deleted, and when a provider is [not] allowed to use that code.",
              "createdAt": "2024-02-12T19:05:27Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 490,
              "body": "```suggestion\r\nIn MIMI 1.0, any change to the room base policy document or to the participant\r\n```",
              "createdAt": "2024-02-12T19:06:40Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 498,
              "body": "Another `SHOULD` without a why.",
              "createdAt": "2024-02-12T19:07:51Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 502,
              "body": "still has clients where? In general or in the MLS group?",
              "createdAt": "2024-02-12T19:08:36Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 504,
              "body": "```suggestion\r\nfrom sending Commit messages; and MUST prevent them from sending any proposals\r\n```",
              "createdAt": "2024-02-12T19:08:54Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 505,
              "body": "reference needed for `SelfRemove`",
              "createdAt": "2024-02-12T19:09:13Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 522,
              "body": "is this some MLS thing? Can we get a cited reference please?",
              "createdAt": "2024-02-12T19:10:07Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 560,
              "body": "This paragraph feels out of place. If the intention is to describe the example flow in a bit more detail, there should be code blocks demonstrating what those requests/responses look like.",
              "createdAt": "2024-02-12T19:11:49Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 629,
              "body": "```suggestion\r\nEnd-to-end encrypted (application) messages are submitted to the hub for\r\n```",
              "createdAt": "2024-02-12T19:12:05Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 949,
              "body": "```suggestion\r\n      SubmitResponseCode statusCode;\r\n```\r\n\r\n(consistency)",
              "createdAt": "2024-02-12T19:13:00Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 1099,
              "body": "Should the hub provider wait for a response before sending the next batch?",
              "createdAt": "2024-02-12T19:16:04Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 972,
              "body": "Applies to `/notify`, `/submitMessage`, and `/update`: when the sender doesn't see a response, or gets a timeout error, it will retry the request. Should the receiving server respond with an error when it sees duplicate requests?\r\n\r\nIt feels more kind to have the server respond with the same status/object it intended to the first time, regardless of whether that made it over to the sender. The endpoints should get a transaction ID to allow providers to quickly identify duplicate requests (as these may be handled at a reverse proxy rather than application level).",
              "createdAt": "2024-02-12T19:20:55Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 1124,
              "body": "re-raising: allowing the hub provider to enact arbitrary rules at a protocol level is unsafe. We need language to say that a hub provider *must* behave in accordance with the policy and protocol at all times.",
              "createdAt": "2024-02-12T19:22:54Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 1126,
              "body": "```suggestion\r\npolicy conformance before they are forwarded to any follower servers and local clients.\r\n```",
              "createdAt": "2024-02-12T19:23:28Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 972,
              "body": "Does the follower server which sent the original change need to wait until it's fanned back to them, or can they optimize and send the object to their local clients ahead of the hub processing the request? (applies to state changes and application messages)",
              "createdAt": "2024-02-12T19:24:30Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 1137,
              "body": "This might need a sequence diagram to back it up.",
              "createdAt": "2024-02-12T19:25:27Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 1151,
              "body": "I thought we were pulling the details of that document into here? Is there anything the DS document describes which hasn't already been covered by this PR?",
              "createdAt": "2024-02-12T19:31:09Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 1258,
              "body": "`ralston-policy` and `mahy-group-chat` are *not* consolidated into this document. The only portion of `ralston-policy` which was incorporated was the notion of participation state, which seems to have gone missing under this PR - that needs to be reinstated in some capacity.\r\n\r\nI'd suggest reinstating the \"Aspects of ralston-policy...\" paragraph, and either clarify how `mahy-group-chat` has had an impact on this document or remove it. ",
              "createdAt": "2024-02-12T20:26:32Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 1,
              "body": "I think we also need an example showing how 2 servers negotiate the encryption being used for a room, and how that applies when a third server is trying to become involved.",
              "createdAt": "2024-02-12T20:28:20Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 451,
              "body": "policy changes or policy *configuration*? It shouldn't be possible to change the policy envelope.",
              "createdAt": "2024-02-12T20:31:55Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            },
            {
              "originalPosition": 492,
              "body": "what is the appropriate `applicationId`?",
              "createdAt": "2024-02-12T20:32:26Z",
              "updatedAt": "2024-02-12T20:33:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v3P1_",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T01:57:56Z",
          "updatedAt": "2024-02-13T01:57:56Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Why isn't configuration sufficient?  We are probably talking about a handful of manually configured providers per hub.",
              "createdAt": "2024-02-13T01:57:56Z",
              "updatedAt": "2024-02-13T01:57:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v3QPx",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T01:59:33Z",
          "updatedAt": "2024-02-13T01:59:34Z",
          "comments": [
            {
              "originalPosition": 451,
              "body": "why not? If an admin role has the permissions to change a room from unmoderated to moderated or from member-only to auditorium-style, why is this a problem?",
              "createdAt": "2024-02-13T01:59:33Z",
              "updatedAt": "2024-02-13T01:59:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v3Qjh",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T02:01:20Z",
          "updatedAt": "2024-02-13T02:01:20Z",
          "comments": [
            {
              "originalPosition": 492,
              "body": "the appropriate applicationId for the base policy document is the MIMI base policy application ID. The appropriate applicationId for the participation list is the MIMI participation list application ID.",
              "createdAt": "2024-02-13T02:01:20Z",
              "updatedAt": "2024-02-13T02:01:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v3Q3z",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T02:03:13Z",
          "updatedAt": "2024-02-13T02:03:13Z",
          "comments": [
            {
              "originalPosition": 236,
              "body": "In the interest of concreteness, and consistency with the content format, let's keep it URI. If you have a concrete proposal of an alternative family of identifiers, I'm happy to reconsider.",
              "createdAt": "2024-02-13T02:03:13Z",
              "updatedAt": "2024-02-13T02:03:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v3RVa",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T02:05:57Z",
          "updatedAt": "2024-02-13T02:05:57Z",
          "comments": [
            {
              "originalPosition": 1151,
              "body": "I don't think that is very clear. Does the client that talks to the hub as a local provider need to implement MIMI DS, or just use compatible MLS objects and signatures?  For example, the hub needs some way to get all components of the commit bundle, but the specific struct used to convey those components doesn't have to be the same.",
              "createdAt": "2024-02-13T02:05:57Z",
              "updatedAt": "2024-02-13T02:05:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v3Rip",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T02:07:14Z",
          "updatedAt": "2024-02-13T02:07:14Z",
          "comments": [
            {
              "originalPosition": 1258,
              "body": "How about \"Concepts from the following documents motivated the contents of this document...\"?\r\n",
              "createdAt": "2024-02-13T02:07:14Z",
              "updatedAt": "2024-02-13T02:07:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v390v",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T06:17:29Z",
          "updatedAt": "2024-02-13T06:17:29Z",
          "comments": [
            {
              "originalPosition": 1151,
              "body": "I'm not following, sorry. Clients aren't providers - they belong to providers. What information is missing in this PR which ensures MLS is reliable for users of providers?",
              "createdAt": "2024-02-13T06:17:29Z",
              "updatedAt": "2024-02-13T06:17:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v3-cI",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T06:20:05Z",
          "updatedAt": "2024-02-13T06:20:05Z",
          "comments": [
            {
              "originalPosition": 1258,
              "body": "I'm not sure either of the policy documents have really provided enough inspiration to be listed, honestly. The participation state enum was defined well before the policy documents existed, and should be returned to this PR somewhere (I can work on wording, if helpful). \r\n\r\nWhat parts of `mahy-group-chat` were incorporated?",
              "createdAt": "2024-02-13T06:20:05Z",
              "updatedAt": "2024-02-13T06:20:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v3--j",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T06:21:56Z",
          "updatedAt": "2024-02-13T06:21:56Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "I think that needs to be made clearer in the document. I was under the impression that we're trying to connect providers regardless of the DMA legal framework, where any random messaging provider could approach another MIMI-compatible provider on the open internet.",
              "createdAt": "2024-02-13T06:21:56Z",
              "updatedAt": "2024-02-13T06:21:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v3_I2",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T06:22:37Z",
          "updatedAt": "2024-02-13T06:22:37Z",
          "comments": [
            {
              "originalPosition": 451,
              "body": "That's configuration of the policy, not fundamentally changing the policy rules which exist.",
              "createdAt": "2024-02-13T06:22:37Z",
              "updatedAt": "2024-02-13T06:22:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v3_PU",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T06:23:02Z",
          "updatedAt": "2024-02-13T06:23:02Z",
          "comments": [
            {
              "originalPosition": 492,
              "body": "I'm not following, sorry. Can we get verbiage in the document please?",
              "createdAt": "2024-02-13T06:23:02Z",
              "updatedAt": "2024-02-13T06:23:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v-DQ-",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T17:15:12Z",
          "updatedAt": "2024-02-13T17:15:12Z",
          "comments": [
            {
              "originalPosition": 1151,
              "body": "What I am saying is that there are two things being described by MIMI DS. One is a list of expected behaviors related to MLS, including many of things described in the \"Operational Considerations\" section of the MLS architecture document. This is largely aligned. The second is almost an API to access the KeyPackages, handle Commits, access GroupInfo, etc. A provider that implemented what is in this PR, could then use an \"API\" very similar to the endpoints in MIMI DS to accomplish what the MIMI provider needs to implement the related to MLS actions. \r\n\r\nThere are three main differences:\r\n- this document assumes that the MIMI provider knows about users (which could include pseudonymous users) and can determine if a given client \"belongs to\" that user. \r\n- MIMI DS requires the hub to process the whole ratchet tree just like a client (which could be a scalability concern for large providers), whereas this PR has the `RatchetTreeRepresentation` assuming the simple thing first (the client uploads the ratchet tree), and could optionally do the full server-maintained ratchet tree.\r\n- MIMI DS has certain design decisions based on enabling metadata privacy. we need to tease that out more (which Raphael, Konrad, and I have already committed to do), but for now we want to show the basic case work",
              "createdAt": "2024-02-13T17:15:12Z",
              "updatedAt": "2024-02-13T17:25:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v-E7I",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T17:19:01Z",
          "updatedAt": "2024-02-13T17:19:02Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "That's a good point. Maybe we just make a note in the document and we can discuss it with the WG. for now, it is a nice placeholder.",
              "createdAt": "2024-02-13T17:19:02Z",
              "updatedAt": "2024-02-13T17:19:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v-Fcx",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T17:20:19Z",
          "updatedAt": "2024-02-13T17:20:19Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I think that is well understood by the working group at this point. This point has been discussed at 3 IETFs now. ",
              "createdAt": "2024-02-13T17:20:19Z",
              "updatedAt": "2024-02-13T17:20:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v-G55",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T17:23:39Z",
          "updatedAt": "2024-02-13T17:23:40Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "Let's leave these stylistic editorial improvements for another PR once this merges please. I think it is great to have a PR that adds internal references, but only after a merge. I already have a TODO link in another place.",
              "createdAt": "2024-02-13T17:23:40Z",
              "updatedAt": "2024-02-13T17:23:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v-JJR",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T17:28:03Z",
          "updatedAt": "2024-02-13T17:28:03Z",
          "comments": [
            {
              "originalPosition": 1258,
              "body": "I think we are just acknowledging other work that came before us. Describing exactly what came from where or was even ultimately included sounds like a non-goal at this stage.",
              "createdAt": "2024-02-13T17:28:03Z",
              "updatedAt": "2024-02-13T17:28:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v-JxE",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T17:29:27Z",
          "updatedAt": "2024-02-13T17:29:27Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "We agreed to leave out things that don't motivate the basic Alice and Bob flow. In that flow, both sides assume they can use MLS as described here.",
              "createdAt": "2024-02-13T17:29:27Z",
              "updatedAt": "2024-02-13T17:29:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v-KSH",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T17:30:38Z",
          "updatedAt": "2024-02-13T17:30:38Z",
          "comments": [
            {
              "originalPosition": 451,
              "body": "perhaps you could provide a concrete example of this distinction?",
              "createdAt": "2024-02-13T17:30:38Z",
              "updatedAt": "2024-02-13T17:30:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v-LOK",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T17:32:18Z",
          "updatedAt": "2024-02-13T17:32:18Z",
          "comments": [
            {
              "originalPosition": 492,
              "body": "Sure, once this is merged and we have the AppSync extension expanded, I can writeup an IANA section that registers the applicationIds in new PR. That should make it super clear. ",
              "createdAt": "2024-02-13T17:32:18Z",
              "updatedAt": "2024-02-13T17:32:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v_AxU",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T19:48:10Z",
          "updatedAt": "2024-02-13T19:48:10Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "A note would be fine, yea.",
              "createdAt": "2024-02-13T19:48:10Z",
              "updatedAt": "2024-02-13T19:48:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v_A56",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T19:48:28Z",
          "updatedAt": "2024-02-13T19:48:28Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "understanding should be documented, imo. ",
              "createdAt": "2024-02-13T19:48:28Z",
              "updatedAt": "2024-02-13T19:48:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v_CfL",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T19:51:25Z",
          "updatedAt": "2024-02-13T19:51:25Z",
          "comments": [
            {
              "originalPosition": 1151,
              "body": "Including those differences in the document itself would really help understanding, I think. I'm still not fully following the ratchet tree stuff, but will give it another read this week.",
              "createdAt": "2024-02-13T19:51:25Z",
              "updatedAt": "2024-02-13T19:51:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v_C5g",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T19:52:39Z",
          "updatedAt": "2024-02-13T19:52:39Z",
          "comments": [
            {
              "originalPosition": 1258,
              "body": "If we aren't incorporating the work, I don't think we need to reference it here. The working group will need to have discussions about policy as a separate discussion/document, which can and should reference both drafts.\r\n\r\nI'd suggest removing both `ralston-policy` and `mahy-group-chat` from the acknowledgements for now.",
              "createdAt": "2024-02-13T19:52:39Z",
              "updatedAt": "2024-02-13T19:52:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v_I_p",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T20:09:31Z",
          "updatedAt": "2024-02-13T20:09:31Z",
          "comments": [
            {
              "originalPosition": 451,
              "body": "The envelope is the set of rules which form an authorization policy itself. The room may have toggles to steer behaviour, but how those flags work is set in stone through the envelope.\r\n\r\nFor example, the permissions system might define 2 flags:\r\n* `can_ban` - Whether users belonging to the role can ban other users.\r\n* `can_invite` - Whether users belonging to the role can invite other users.\r\n\r\nThe envelope could have a rule which says a user must be unbanned before they can be invited, which implies behaviour upon users which hold `can_invite`. All participating providers have a shared understanding for this envelope, and can locally enforce those operations without having to disturb the hub with needless requests. The actual assignment of the flags is left as a configuration detail for the room, though does still need to be visible to the providers which are locally enforcing policy (for obvious cases that don't require the hub). ",
              "createdAt": "2024-02-13T20:09:31Z",
              "updatedAt": "2024-02-13T20:09:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v_KHe",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T20:12:57Z",
          "updatedAt": "2024-02-13T20:12:57Z",
          "comments": [
            {
              "originalPosition": 492,
              "body": "This PR needs a note about the application IDs in it. The IANA section can be expanded in a future PR, but for this PR to be mergeable the description of what the application ID look like needs to be included.",
              "createdAt": "2024-02-13T20:12:57Z",
              "updatedAt": "2024-02-13T20:12:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v_K1u",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Sending in this review as a checkpoint; I've made it about half-way through.\r\n\r\nOverall, I think this is the right direction, but there are several minor things to fix.",
          "createdAt": "2024-02-13T20:15:09Z",
          "updatedAt": "2024-02-13T20:56:08Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I'm not going to go to the mat on this, but having one endpoint handle multiple versions actually seems quite messy to me.\r\n\r\nSince we have a directory now, we can do versioning there, e.g., by having both `notify` and `notify_v2` endpoints.  Then the actual endpoints only have to handle one version.",
              "createdAt": "2024-02-13T20:15:09Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 21,
              "body": "One thing I notice we lost in the deleted sections was some prose exempting the `.well-known` endpoint from the mutual TLS requirement.  That seems sensible to me even with this change to the `.well-known` endpoint.  The only reason you would need client authentication here is if the server were going to provide different data to different clients (including no data).  I guess you could imagine providing different endpoints to different peered providers, but in general it seems like this information should be public and uniform.",
              "createdAt": "2024-02-13T20:18:45Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 84,
              "body": "```suggestion\r\nLike the ACME protocol (see {{Section 7.1.1 of ?RFC8555}}), the MIMI protocol uses a directory document\r\n```",
              "createdAt": "2024-02-13T20:21:15Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 248,
              "body": "This SHOULD should be a conditional MUST, something like:\r\n\r\n> When the request is being made in the context of adding the target user to a room, the request MUST include ...",
              "createdAt": "2024-02-13T20:27:09Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 249,
              "body": "Room URI?",
              "createdAt": "2024-02-13T20:27:17Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 256,
              "body": "I would also be fine deleting the `lastResortAllowed` flag.  We're not using it, and it's an easy thing to add back later.",
              "createdAt": "2024-02-13T20:29:02Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 270,
              "body": "This isn't actually hidden; it can be referenced from other sections.  TLS-PL is more of a human-readable documentation language (with unambiguous encoding semantics) than a machine-readable language.",
              "createdAt": "2024-02-13T20:30:43Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 270,
              "body": "I agree with @turt2live here that we should remain agnostic on identifiers for the moment.  To make this system hang together, we need unique IDs for rooms and users that map to their hub / home servers respectively.  We should have something detailed, but it doesn't need to be totally nailed down.\r\n\r\nIMO what we should do here is:\r\n* ~Flag identifiers as an open issue~ This is already done\r\n* In this PR, use generic worridng like @turt2live suggests; don't assume that identifiers are URIs.\r\n* In a follow-on PR, add an \"Identifiers\" section:\r\n    * Define a syntax that is simple and obviously wrong:\r\n        * Server: `example.com`\r\n        * Room: `room-name@hub.example.com`\r\n        * User: `user-name@home.example.com`\r\n    * Discuss requirements and design considerations:\r\n        * Requirements: user/room -> home/hub\r\n        * URIs: existing syntax vs. too much complexity\r\n        * Custom: simpler vs. have to ensure all bases covered",
              "createdAt": "2024-02-13T20:42:35Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 280,
              "body": "I'm probably just a type system nerd, but it might be good to distinguish `UserIdentifier` and `RoomIdentifier` types.",
              "createdAt": "2024-02-13T20:43:22Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 337,
              "body": "I don't see `clients` defined anywhere.  Do you mean `clientCapabilities`?  Assuming that's right, the MAY / MUST NOT seems unnecessary here, since the syntax itself forbids the MUST NOT.  I would probably rephrase as \"If `noCompatibleMaterial`, then the `clientCapabilities` field may be used to indicate...\"",
              "createdAt": "2024-02-13T20:45:10Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 339,
              "body": "```suggestion\r\nKey material provided from one response MUST NOT be provided in any other\r\n```",
              "createdAt": "2024-02-13T20:46:31Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 492,
              "body": "Agree with @turt2live here.  This document can just declare that two app IDs exist and what state they correspond to, and then the IANA section can assign them values.",
              "createdAt": "2024-02-13T20:48:31Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 502,
              "body": "I presume \"in the MLS group\", but we should be clear.\r\n\r\nI would probably be stronger than this, and declare that a proposal to removing / banning a user is invalid as long as there are any clients belonging to that user in the MLS group.  The \"hub queues up proposals and requires they be implemented\" model described elsewhere, this can be implemented just fine.",
              "createdAt": "2024-02-13T20:50:54Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 502,
              "body": "(Maybe you still need something like this as a backstop, for the interval in between when a removal is proposed and when it is committed.)",
              "createdAt": "2024-02-13T20:51:36Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 522,
              "body": "I would just delete this and refer to the [representation in RFC 9420](https://rfcs.online/rfcs/rfc9420.html#ratchet-tree-extension).  AFAIK none of these are defined, and defining them would entail more work than we should do in this document (arguably should be an MLS WG project).",
              "createdAt": "2024-02-13T20:53:14Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 543,
              "body": "Presumably this should also omit the `ratchet_tree` extension.",
              "createdAt": "2024-02-13T20:54:02Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            },
            {
              "originalPosition": 560,
              "body": "At least start with \"For example, ...\"",
              "createdAt": "2024-02-13T20:54:40Z",
              "updatedAt": "2024-02-13T20:56:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v_pRI",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T21:28:31Z",
          "updatedAt": "2024-02-13T21:28:31Z",
          "comments": [
            {
              "originalPosition": 256,
              "body": "I included it to tell people not to use last resort keypackages. I'm fine deleting the field and still saying only use single-use keypackages.",
              "createdAt": "2024-02-13T21:28:31Z",
              "updatedAt": "2024-02-13T21:28:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v_rmH",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T21:31:16Z",
          "updatedAt": "2024-02-13T21:31:16Z",
          "comments": [
            {
              "originalPosition": 1151,
              "body": "That is part of the problem. We had documents with various scopes and motivations and the working group asked for a document that was clear with a limited scope. Most of our audience has not read MIMI DS. The comparison isn't necessary IMO. ",
              "createdAt": "2024-02-13T21:31:16Z",
              "updatedAt": "2024-02-13T21:31:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v_rzY",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T21:31:32Z",
          "updatedAt": "2024-02-13T21:31:32Z",
          "comments": [
            {
              "originalPosition": 256,
              "body": "Either works imo. More pointing out that a `SHOULD` needs an attached rationale when used.",
              "createdAt": "2024-02-13T21:31:32Z",
              "updatedAt": "2024-02-13T21:31:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v_vEG",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T21:38:13Z",
          "updatedAt": "2024-02-13T21:38:13Z",
          "comments": [
            {
              "originalPosition": 451,
              "body": "we don't have consensus on the envelope concept you are describing, and this notion you can't change the envelope in a room. In draft-mahy-mimi-group-chat there is a single document that defines the style of conference and the permissions. I've seen at least 4 other variations. \r\n\r\nrather than carve that in stone, why don't we allow the hub to set the rules about what authorization is required to make certain changes. If a hub never gives the change_room_type permission, then nobody will ever be able to.",
              "createdAt": "2024-02-13T21:38:13Z",
              "updatedAt": "2024-02-13T21:38:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v_wrg",
          "commit": {
            "abbreviatedOid": "c077ae6"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T21:42:15Z",
          "updatedAt": "2024-02-13T21:42:15Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I can think of plenty of providers who would like to limit the information about their internal endpoints. Remember, only a handful of providers need to know these URLs as they are not for client use.",
              "createdAt": "2024-02-13T21:42:15Z",
              "updatedAt": "2024-02-13T21:42:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v_yGx",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T21:46:44Z",
          "updatedAt": "2024-02-13T21:46:44Z",
          "comments": [
            {
              "originalPosition": 492,
              "body": "That's what the document already says. One applicationId is for base policy, the other for the participation list.",
              "createdAt": "2024-02-13T21:46:44Z",
              "updatedAt": "2024-02-13T21:46:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85v_9Sm",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T22:19:16Z",
          "updatedAt": "2024-02-13T22:19:16Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "*unresolving* - this needs to be made clear in the document, sorry. ",
              "createdAt": "2024-02-13T22:19:16Z",
              "updatedAt": "2024-02-13T22:19:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wB36z",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Just a partial review for now. I'll continue over the next few days.",
          "createdAt": "2024-02-14T07:15:57Z",
          "updatedAt": "2024-02-14T07:53:55Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I also don't have a strong opinion on this, as long as anything that's signed (i.e. things where mTLS is not enough) includes both the endpoint and the protocol version in the TBS.",
              "createdAt": "2024-02-14T07:15:57Z",
              "updatedAt": "2024-02-14T07:53:55Z"
            },
            {
              "originalPosition": 41,
              "body": "If we do versioning via the directory, we should remove the version from the paths here.",
              "createdAt": "2024-02-14T07:18:08Z",
              "updatedAt": "2024-02-14T07:53:55Z"
            },
            {
              "originalPosition": 256,
              "body": "I agree with @bifurcation here. Let's discuss usage of last resort separately. ",
              "createdAt": "2024-02-14T07:22:56Z",
              "updatedAt": "2024-02-14T07:53:55Z"
            },
            {
              "originalPosition": 280,
              "body": "Yes please!",
              "createdAt": "2024-02-14T07:23:59Z",
              "updatedAt": "2024-02-14T07:53:55Z"
            },
            {
              "originalPosition": 108,
              "body": "Even if we have a MUST NOT here, there should be a check on the receiving end, as sender and recipient might not agree on time.",
              "createdAt": "2024-02-14T07:25:51Z",
              "updatedAt": "2024-02-14T07:53:55Z"
            },
            {
              "originalPosition": 370,
              "body": "We shouldn't be too restrictive here. We don't want to require providers to keep lists of deleted user names around.",
              "createdAt": "2024-02-14T07:28:31Z",
              "updatedAt": "2024-02-14T07:53:55Z"
            },
            {
              "originalPosition": 128,
              "body": "We should really leave the handling of last resort stuff for a later date.",
              "createdAt": "2024-02-14T07:29:43Z",
              "updatedAt": "2024-02-14T07:53:55Z"
            },
            {
              "originalPosition": 451,
              "body": "I don't have a strong opinion here, but we I agree with @rohan-wire that we shouldn't be restrictive where we don't have to be.",
              "createdAt": "2024-02-14T07:31:51Z",
              "updatedAt": "2024-02-14T07:53:55Z"
            },
            {
              "originalPosition": 502,
              "body": "I think this PR removes a section where the hub state was described as the combination of queued proposals and (commited) MLS group state. I haven't quite finished the review, but this needs to be described somewhere. Ideally at some point before this section.",
              "createdAt": "2024-02-14T07:36:40Z",
              "updatedAt": "2024-02-14T07:53:55Z"
            },
            {
              "originalPosition": 522,
              "body": "Agreed. This is something we can handle at a later date.",
              "createdAt": "2024-02-14T07:38:06Z",
              "updatedAt": "2024-02-14T07:53:55Z"
            },
            {
              "originalPosition": 244,
              "body": "We should either discuss the semantics of each of those, or leave them out for the moment. The same goes for the other status codes below.",
              "createdAt": "2024-02-14T07:41:12Z",
              "updatedAt": "2024-02-14T07:53:55Z"
            },
            {
              "originalPosition": 972,
              "body": "For state changes it definitely needs to wait for a response for the hub, as another commit might have been faster. For application messages it's less bad, but it still alters the view of the conversation. For overall consistency, I'd suggest we don't optimize here.",
              "createdAt": "2024-02-14T07:46:43Z",
              "updatedAt": "2024-02-14T07:53:55Z"
            },
            {
              "originalPosition": 335,
              "body": "Do we really need two timestamps in this struct?",
              "createdAt": "2024-02-14T07:48:53Z",
              "updatedAt": "2024-02-14T07:53:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wFscH",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T15:03:44Z",
          "updatedAt": "2024-02-14T16:06:34Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "@turt2live Can you say more about what you expect here?  (Also, I assume we are talking about E2E encryption, not transport.)  It seems to me that any sort of negotiation is an advanced feature, and thus not suitable for this initial draft.  \r\n\r\nRoom creation also entails establishment of the E2E security context for the room, covering the initial membership (e.g., Alice's devices).  Room creation is also out of scope for this protocol.  So by the time this protocol has any work to do, the E2E security context is already fixed.  In principle, the context can then be changed (e.g., by re-initializing the MLS group to a new ciphersuite), but that operation is going to be expensive, complicated, and rare, thus an advanced feature.\r\n\r\nThe absolute maximum I would do here is note in the group creation section that if some set of prospective members are known at the time of group creation, then the hub may proactively fetch key material for those prospective members and use it to select the parameters for the MLS group.",
              "createdAt": "2024-02-14T15:03:44Z",
              "updatedAt": "2024-02-14T16:06:34Z"
            },
            {
              "originalPosition": 41,
              "body": "The provider can choose whatever endpoints they want, that's the point of the directory.  So if the provider wants to say `v1`, they can.  They could even say `v1` for the `v2` endpoint!",
              "createdAt": "2024-02-14T15:34:26Z",
              "updatedAt": "2024-02-14T16:06:34Z"
            },
            {
              "originalPosition": 451,
              "body": "Recall that one of the principles discussed and agreed by the WG was that the hub defines the policy envelope.  That discussion did not say that the policy envelope was immutable. ",
              "createdAt": "2024-02-14T15:47:29Z",
              "updatedAt": "2024-02-14T16:06:34Z"
            },
            {
              "originalPosition": 502,
              "body": "Agree that we need to describe that.  I thought this was covered, but I'm not seeing it in the document.  Maybe file an issue to make sure it's covered in a follow-on.",
              "createdAt": "2024-02-14T15:51:01Z",
              "updatedAt": "2024-02-14T16:06:34Z"
            },
            {
              "originalPosition": 823,
              "body": "If we push protocol versioning to the directory, we can save on these `If the protocol is...` caveats.",
              "createdAt": "2024-02-14T15:53:12Z",
              "updatedAt": "2024-02-14T16:06:34Z"
            },
            {
              "originalPosition": 972,
              "body": "I agree that deduplication is necessary, but would be tempted to punt ~= treat as a known issue, rather than something to fix here.",
              "createdAt": "2024-02-14T15:54:36Z",
              "updatedAt": "2024-02-14T16:06:34Z"
            },
            {
              "originalPosition": 972,
              "body": "I think the question is whether the hub's acceptance is enough, or whether the follower also needs to get it fanout'ed back to them.  I would tend toward the former, viewing the acceptance by the hub as a commitment that the message/update will be distributed appropriately.  But I could also understand an argument that there's some simplicity and conservatism to waiting for the fanout.\r\n\r\nEither way, it seems like we can make a provisional choice here and adapt later.  Might even be good to have a note in the text about whichever alternative we don't select.",
              "createdAt": "2024-02-14T15:58:18Z",
              "updatedAt": "2024-02-14T16:06:34Z"
            },
            {
              "originalPosition": 1099,
              "body": "It seems like this would simplify processing on the receive side, at least for Commit messages.",
              "createdAt": "2024-02-14T16:02:07Z",
              "updatedAt": "2024-02-14T16:06:34Z"
            },
            {
              "originalPosition": 1124,
              "body": "The hub provider MUST do whatever we state as MUSTs in this specification.  But the hub is allowed to have local policy.  What else do you think the hub provider MUST do?",
              "createdAt": "2024-02-14T16:03:23Z",
              "updatedAt": "2024-02-14T16:06:34Z"
            },
            {
              "originalPosition": 1151,
              "body": "The citation to mimi-ds is out of place.  We should not cite that document, but instead pull any necessary mechanism in here.",
              "createdAt": "2024-02-14T16:05:00Z",
              "updatedAt": "2024-02-14T16:06:34Z"
            },
            {
              "originalPosition": 1181,
              "body": "Similar comments here about \"DS protocol\".  We don't really have a DS sub-protocol any more.  Just say \"MIMI\".",
              "createdAt": "2024-02-14T16:06:20Z",
              "updatedAt": "2024-02-14T16:06:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wG_WQ",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T17:33:16Z",
          "updatedAt": "2024-02-14T17:33:16Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "\"unresolving - this needs to be made clear in the document, sorry.\"\r\n\r\nI'm not sure what you think is unclear. This document is defining a mechanism that supports the basic Alice and Bob flow with *MLS*. You have *personally* asked to remove otherwise useful features that will almost certainly be required in the MLS case based on this minimalist approach. Protocol negotiation is not even remotely required. It is **100% OUT OF SCOPE**.  Resolving.",
              "createdAt": "2024-02-14T17:33:16Z",
              "updatedAt": "2024-02-14T17:33:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wHCAV",
          "commit": {
            "abbreviatedOid": "c077ae6"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T17:39:33Z",
          "updatedAt": "2024-02-14T17:39:34Z",
          "comments": [
            {
              "originalPosition": 335,
              "body": "> Do we really need two timestamps in this struct?\r\n\r\nWe need the time the hub accepts the message as discussed at the post-MIMI WG meeting lunch in Prague. What is the other timestamp you are referring to?",
              "createdAt": "2024-02-14T17:39:33Z",
              "updatedAt": "2024-02-14T17:39:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wHJIA",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T17:55:07Z",
          "updatedAt": "2024-02-14T17:55:08Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Please give me a chance to reply before resolving :/\r\n\r\nI'm asking for the document to clarify the mechanism by which providers determine they are capable of participating in the room, and by extension their clients too. At group creation time, there needs to be a check that Alice's clients and Bob's clients are actually capable of encrypting for each other *and* that both providers (if we assume they're on separate providers) can track the appropriate state.\r\n\r\nThis is further complicated when a third user on a net-new provider is aiming to become involved. The inviter and hub server need to once again check client compatibility and provider compatibility. If the client or provider can't participate, then they should not be allowed to.\r\n\r\nCurrently, the mechanism by which this is performed is not clear in the document. It may very well be a function of MLS. If it is, text needs to be added to point to it please.\r\n\r\nWhat I am *not* asking for is scope creep or for an explicit create operation in our protocol. Creation is done locally on the provider, and then invites/adds go out to future members. Those invited providers provision whatever resources they need for their clients to interact with the room, effectively creating or mirroring the room onto their systems. None of this is an operation which needs technical definition in this document.",
              "createdAt": "2024-02-14T17:55:08Z",
              "updatedAt": "2024-02-14T17:55:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wHJ9V",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T17:56:55Z",
          "updatedAt": "2024-02-14T17:56:56Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "(is the versioning comment on the wrong thread?)",
              "createdAt": "2024-02-14T17:56:55Z",
              "updatedAt": "2024-02-14T17:56:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wHLSZ",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T18:00:09Z",
          "updatedAt": "2024-02-14T18:00:09Z",
          "comments": [
            {
              "originalPosition": 972,
              "body": "yea, +1 as recorded known issue rather than trying to solve now.",
              "createdAt": "2024-02-14T18:00:09Z",
              "updatedAt": "2024-02-14T18:00:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wHMAL",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T18:01:52Z",
          "updatedAt": "2024-02-14T18:01:53Z",
          "comments": [
            {
              "originalPosition": 1124,
              "body": "I'm worried that the language here gives leeway for the hub provider to enact custom and arbitrary rules. We use very few MUSTs to limit this behaviour currently.\r\n\r\nStrengthening the overall text is likely the best direction here, rather than fixing one specific line.",
              "createdAt": "2024-02-14T18:01:52Z",
              "updatedAt": "2024-02-14T18:01:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wHMbN",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T18:02:51Z",
          "updatedAt": "2024-02-14T18:02:52Z",
          "comments": [
            {
              "originalPosition": 972,
              "body": "what @bifurcation said :)",
              "createdAt": "2024-02-14T18:02:51Z",
              "updatedAt": "2024-02-14T18:02:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wHNJa",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T18:04:35Z",
          "updatedAt": "2024-02-14T18:04:35Z",
          "comments": [
            {
              "originalPosition": 451,
              "body": "right, I'll resolve this for now pending more policy discussions with the working group. It's not something which prevents merging this PR - more of a nitpick on the language.",
              "createdAt": "2024-02-14T18:04:35Z",
              "updatedAt": "2024-02-14T18:04:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wHWlS",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T18:23:46Z",
          "updatedAt": "2024-02-14T18:23:47Z",
          "comments": [
            {
              "originalPosition": 493,
              "body": "```suggestion\r\nIn MLS 1.0, changes to the room's policy and participant list are done with `AppSync`\r\nproposals. A distinct `applicationId` contains the room's policy while another contains\r\nthe participant list. When adding a user, the participant list change MUST happen \r\neither before or simultaneously with the corresponding MLS operation.\r\n```",
              "createdAt": "2024-02-14T18:23:46Z",
              "updatedAt": "2024-02-14T18:23:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wHXYd",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T18:25:50Z",
          "updatedAt": "2024-02-14T18:25:51Z",
          "comments": [
            {
              "originalPosition": 492,
              "body": "I've attempted to clear up the confusion here: https://github.com/bifurcation/ietf-mimi-protocol/pull/50/files#r1489894427\r\n\r\nThe current text is unclear about whether a new application ID is needed for each proposal, if it's an identifier the client needs to populate (`com.whatsapp.web`, for example), or if it's a canonical identifier in the room to consistently store the information. I believe it's the last one.",
              "createdAt": "2024-02-14T18:25:50Z",
              "updatedAt": "2024-02-14T18:25:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wHjt-",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T18:54:28Z",
          "updatedAt": "2024-02-14T18:54:29Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "> Please give me a chance to reply before resolving :/\r\n> \r\n> I'm asking for the document to clarify the mechanism by which providers determine they are capable of participating in the room, and by extension their clients too. At group creation time, there needs to be a check that Alice's clients and Bob's clients are actually capable of encrypting for each other _and_ that both providers (if we assume they're on separate providers) can track the appropriate state.\r\n\r\nIf they implement what is in this PR merged into this document there is no issue. Group creation is out of scope. MIMI specs only cover MLS. In MLS, Alice can see via Bob's KeyPackage if Bob supports the necessary features.\r\n\r\nAs for adding future negotiation for other encryption or MIMI extensions, for MLS the KeyPackages can contain extensions; support can be statically configured (quite appropriate for a non-standard encryption binding); and the discovery mechanism can be extended. And no, we do not need to say that in the document.\r\n\r\n> This is further complicated when a third user on a net-new provider is aiming to become involved. The inviter and hub server need to once again check client compatibility and provider compatibility. If the client or provider can't participate, then they should not be allowed to.\r\n>\r\n> Currently, the mechanism by which this is performed is not clear in the document. It may very well be a function of MLS. If it is, text needs to be added to point to it please.\r\n\r\nThen once this PR is merged, I would be delighted to see issues and PRs which point out specific use cases or problemss. Until then I would advise you to carefully read the sections in RFC 9420 (section 13 - especially 13.4) and draft-ietf-mls-architecture (sections 6.8, 7, and 8.2.4) on MLS extensibility.\r\n \r\n> What I am _not_ asking for is scope creep or for an explicit create operation in our protocol. Creation is done locally on the provider, and then invites/adds go out to future members. Those invited providers provision whatever resources they need for their clients to interact with the room, effectively creating or mirroring the room onto their systems. None of this is an operation which needs technical definition in this document.\r\n\r\nRespectfully, you are asking for a generic extensibility negotiation mechanism, and/or a lot of text that does not fit the current scope of this PR and the target draft. That is not appropriate. It is out of scope.",
              "createdAt": "2024-02-14T18:54:28Z",
              "updatedAt": "2024-02-14T18:54:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wHmRT",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T19:00:34Z",
          "updatedAt": "2024-02-14T19:00:34Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "> I would advise you to carefully read the sections in RFC 9420 (section 13 - especially 13.4) and draft-ietf-mls-architecture (sections 6.8, 7, and 8.2.4) on MLS extensibility.\r\n\r\nPlease add these references to the document if they address the concern. It is not clear as a reader that these sections are required reading.\r\n\r\nI do not agree that people reading this document/PR will inherently know that the mechanism for ensuring compatibility is in MLS.",
              "createdAt": "2024-02-14T19:00:34Z",
              "updatedAt": "2024-02-14T19:00:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wHrro",
          "commit": {
            "abbreviatedOid": "beefc67"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T19:13:48Z",
          "updatedAt": "2024-02-14T19:13:49Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "To reiterate though: I'm really just looking for a sentence or two *somewhere* to show we've thought about this, because clearly we have. The scope of this PR is not clear to me, but from the title I would consider Alice fetching Bob's KeyPackage and deciding that communication is impossible as a 'basic flow'.",
              "createdAt": "2024-02-14T19:13:48Z",
              "updatedAt": "2024-02-14T19:13:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wIi7k",
          "commit": {
            "abbreviatedOid": "467dea7"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T20:51:12Z",
          "updatedAt": "2024-02-14T20:51:13Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "If we think it's out of scope for this PR, please consider https://github.com/bifurcation/ietf-mimi-protocol/pull/51",
              "createdAt": "2024-02-14T20:51:13Z",
              "updatedAt": "2024-02-14T20:51:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wK0iX",
          "commit": {
            "abbreviatedOid": "c077ae6"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-15T06:18:06Z",
          "updatedAt": "2024-02-15T06:18:06Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "That's fair, but if the `v1` in the path is not relevant, we might want to choose a less confusing example.",
              "createdAt": "2024-02-15T06:18:06Z",
              "updatedAt": "2024-02-15T06:18:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wK1-5",
          "commit": {
            "abbreviatedOid": "c077ae6"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-15T06:21:46Z",
          "updatedAt": "2024-02-15T06:21:46Z",
          "comments": [
            {
              "originalPosition": 335,
              "body": "The first field of this struct is labeled `timestamp` and then there's another one on the line this comment is on. I do agree that we generally need a timestamp. I was just confused by the presence of two timestamps.",
              "createdAt": "2024-02-15T06:21:46Z",
              "updatedAt": "2024-02-15T06:21:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85wHq_z",
          "commit": {
            "abbreviatedOid": "395e200"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T19:11:52Z",
          "updatedAt": "2024-02-19T21:39:46Z",
          "comments": [
            {
              "originalPosition": 1258,
              "body": "OK. I just removed the entire Acknowledgements section as not needed for the bare minimum.",
              "createdAt": "2024-02-14T19:11:52Z",
              "updatedAt": "2024-02-19T21:39:46Z"
            },
            {
              "originalPosition": 1181,
              "body": "I just created a new commit to remove all vestiges of MIMI-DS so this document is self-contained.  We can revert it if that is not what we wanted.",
              "createdAt": "2024-02-14T19:38:51Z",
              "updatedAt": "2024-02-19T21:39:47Z"
            },
            {
              "originalPosition": 1151,
              "body": "OK, I think this is addressed now with one of my recent commits.\r\n@kkohbrok does that commit look ok to you?",
              "createdAt": "2024-02-14T19:50:59Z",
              "updatedAt": "2024-02-19T21:39:46Z"
            },
            {
              "originalPosition": 1124,
              "body": "How about I make the last phrase read as follows?\r\n\r\n\"the Hub is the arbiter that decides if a state change is valid, consistent with the room's then current policy.\"",
              "createdAt": "2024-02-14T19:54:19Z",
              "updatedAt": "2024-02-19T21:39:46Z"
            },
            {
              "originalPosition": 1099,
              "body": "I don't think we can or should wait for a response to a fanout. We can't meet the needs of a large provider if we have a one-RTT delay between fanout messages. With a 10ms RTT, our max throughput on a single TLS connection would be 6000 messages per minute. Even a 100-person company can fanout more than 6000 messages per minute (reactions, read-receipts, maybe isTyping notificiations, ...) pretty easily.\r\n\r\nOn the receive side, it is just a queue of messages (and the order can be reconstructed trivially from the (hub accepted time) timestamp in the message.",
              "createdAt": "2024-02-15T05:39:00Z",
              "updatedAt": "2024-02-19T21:39:46Z"
            },
            {
              "originalPosition": 335,
              "body": "Ah, not enough context in the conversation diff. Fixed.",
              "createdAt": "2024-02-15T05:44:41Z",
              "updatedAt": "2024-02-19T21:39:47Z"
            },
            {
              "originalPosition": 543,
              "body": "fixed",
              "createdAt": "2024-02-15T06:07:58Z",
              "updatedAt": "2024-02-19T21:39:47Z"
            },
            {
              "originalPosition": 24,
              "body": "placeholder in issue #52 ",
              "createdAt": "2024-02-19T19:34:07Z",
              "updatedAt": "2024-02-19T21:39:46Z"
            },
            {
              "originalPosition": 270,
              "body": "raised in issue #53",
              "createdAt": "2024-02-19T19:44:26Z",
              "updatedAt": "2024-02-19T21:39:46Z"
            },
            {
              "originalPosition": 370,
              "body": "agreed. that wasn't my intention. just to provide a set of response with clear semantics that the providers can use. Added a commit which clarifies.",
              "createdAt": "2024-02-19T20:09:56Z",
              "updatedAt": "2024-02-19T21:39:46Z"
            },
            {
              "originalPosition": 522,
              "body": "Left a placeholder that allows us to support other solutions, such as the hub reconstructing most of the GroupInfo from Commits. ",
              "createdAt": "2024-02-19T20:23:29Z",
              "updatedAt": "2024-02-19T21:39:46Z"
            },
            {
              "originalPosition": 972,
              "body": " #54 ",
              "createdAt": "2024-02-19T20:36:16Z",
              "updatedAt": "2024-02-19T21:39:46Z"
            },
            {
              "originalPosition": 972,
              "body": "Added paragraph covering this. ",
              "createdAt": "2024-02-19T20:50:10Z",
              "updatedAt": "2024-02-19T21:39:46Z"
            },
            {
              "originalPosition": 249,
              "body": "covered in issue #53",
              "createdAt": "2024-02-19T20:58:54Z",
              "updatedAt": "2024-02-19T21:39:46Z"
            },
            {
              "originalPosition": 492,
              "body": "pretended we already had two specific applicationIds: `mimiRoomPolicy` and `mimiParticipantList`",
              "createdAt": "2024-02-19T21:00:22Z",
              "updatedAt": "2024-02-19T21:39:46Z"
            },
            {
              "originalPosition": 280,
              "body": "issue #53",
              "createdAt": "2024-02-19T21:02:24Z",
              "updatedAt": "2024-02-19T21:39:47Z"
            },
            {
              "originalPosition": 337,
              "body": "search for this vector. it's there\r\n`ClientKeyMaterial clients<V>;`",
              "createdAt": "2024-02-19T21:04:08Z",
              "updatedAt": "2024-02-19T21:39:47Z"
            },
            {
              "originalPosition": 339,
              "body": "There are tons of uses of both key material and keying material. we can decide later which of these we want to use. for now i will ignore this.",
              "createdAt": "2024-02-19T21:05:27Z",
              "updatedAt": "2024-02-19T21:39:47Z"
            },
            {
              "originalPosition": 823,
              "body": "#52 ",
              "createdAt": "2024-02-19T21:21:22Z",
              "updatedAt": "2024-02-19T21:39:47Z"
            },
            {
              "originalPosition": 41,
              "body": "discussed in #52 ",
              "createdAt": "2024-02-19T21:39:11Z",
              "updatedAt": "2024-02-19T21:39:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85woMVp",
          "commit": {
            "abbreviatedOid": "395e200"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for making the changes @rohan-wire! I'd say let's get this merged and then we can see what issue we want to follow up with.",
          "createdAt": "2024-02-20T06:28:16Z",
          "updatedAt": "2024-02-20T06:28:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 51,
      "id": "PR_kwDOKZ8QO85m56LK",
      "title": "Clarify that KeyPackages *are* the negotiation mechanism for support",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/51",
      "state": "CLOSED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "ref https://github.com/bifurcation/ietf-mimi-protocol/pull/50/files#r1486736385",
      "createdAt": "2024-02-14T20:50:57Z",
      "updatedAt": "2024-03-02T23:43:11Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "36ad4767944db62e4b270460f06f2e6dfd98adef",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "travis/negotiate",
      "headRefOid": "4b24bca596e91a5f6af863424111a42fab42118e",
      "closedAt": "2024-03-02T23:43:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the spirit of this PR, but it is not technically correct. The requester asks ahead of time for KeyPackages with whatever the required extensions, proposals, and credentials are. \r\n\r\nFrom PR #50, note the `RequiredCapabilities` line from the struct below and the text about what it is for.\r\n```\r\nstruct {\r\n    Protocol protocol;\r\n    IdentifierUri requestingUser;\r\n    IdentifierUri targetUser;\r\n    IdentifierUri roomId;\r\n    select (protocol) {\r\n        case mls10:\r\n            CipherSuite acceptableCiphersuites<V>;\r\n            RequiredCapabilities requiredCapabilities;\r\n            bool lastResortAllowed;\r\n    };\r\n} KeyMaterialRequest;\r\n```\r\n\r\n\"For MLS, the request includes a non-empty list of acceptable MLS ciphersuites, and an MLS RequiredCapabilities object (which contains credential types, non-default proposal types, and extensions) required by the requesting provider (these lists can be an empty).\"",
          "createdAt": "2024-02-15T04:45:50Z",
          "updatedAt": "2024-02-15T04:45:50Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "DT call 2024-02-28: \r\n* @rohanmahy's concern is expressing the `required_capabilities` part\r\n* @bifurcation suggests this is good in the key material fetch section\r\n* @turt2live will look on Friday, @rohanmahy may look at it sooner",
          "createdAt": "2024-02-28T16:08:56Z",
          "updatedAt": "2024-02-28T16:08:56Z"
        },
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favour of https://github.com/bifurcation/ietf-mimi-protocol/pull/63",
          "createdAt": "2024-03-02T23:43:08Z",
          "updatedAt": "2024-03-02T23:43:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 57,
      "id": "PR_kwDOKZ8QO85oOpqQ",
      "title": "fix link to fetch-key-material",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/57",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-28T23:04:10Z",
      "updatedAt": "2024-10-21T02:38:32Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "d72db4b7a23c05d02048dfbbd50d97843a153d9a",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/fix-link",
      "headRefOid": "6925f7c1f261e265f785428031ebce23afb0a285",
      "closedAt": "2024-02-29T02:26:49Z",
      "mergedAt": "2024-02-29T02:26:49Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a0972f8be15588efd6dea9bea757ec1f1edaf8e0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85xtvqH",
          "commit": {
            "abbreviatedOid": "6925f7c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-29T02:26:44Z",
          "updatedAt": "2024-02-29T02:26:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "PR_kwDOKZ8QO85oOrVh",
      "title": "Add accepted timestamp to update and submit primitives",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/58",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- add accepted timestamp to `UpdateRoomResponse` and `SubmitMessageResponse` and adjust related structs\r\n- add missing error codes and semantics to submit primitive",
      "createdAt": "2024-02-28T23:11:29Z",
      "updatedAt": "2024-10-21T02:38:31Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "d72db4b7a23c05d02048dfbbd50d97843a153d9a",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/return-timestamp",
      "headRefOid": "8ef92827af3106de15b84618c2360693cc475c5a",
      "closedAt": "2024-02-29T06:41:41Z",
      "mergedAt": "2024-02-29T06:41:41Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "8b79f9275b6254723084f88ddfedf9bc86874e7b"
      },
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Addresses issue #56 ",
          "createdAt": "2024-02-28T23:13:20Z",
          "updatedAt": "2024-02-28T23:13:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85xugF2",
          "commit": {
            "abbreviatedOid": "8ef9282"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good, thanks for taking care of the issue @rohanmahy!",
          "createdAt": "2024-02-29T05:47:36Z",
          "updatedAt": "2024-02-29T05:47:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 59,
      "id": "PR_kwDOKZ8QO85oO6bs",
      "title": "Add MIMI URI scheme",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/59",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Add basic description of new MIMI URI scheme under example actors\r\n- Adjust Bob and Alice flow messages to use the URI\r\n\r\nAddresses issue #53 ",
      "createdAt": "2024-02-29T00:20:03Z",
      "updatedAt": "2024-10-21T02:38:22Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "d72db4b7a23c05d02048dfbbd50d97843a153d9a",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/identifiers",
      "headRefOid": "11bda8b78f918c8efedf014a2216b22d73a48de2",
      "closedAt": "2024-02-29T16:20:05Z",
      "mergedAt": "2024-02-29T16:20:05Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e6cb4ec7787e81dac4cb2f2870bc129df2272504"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85xugSo",
          "commit": {
            "abbreviatedOid": "11bda8b"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-29T05:48:27Z",
          "updatedAt": "2024-02-29T05:48:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO85xzewO",
          "commit": {
            "abbreviatedOid": "11bda8b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-29T16:19:57Z",
          "updatedAt": "2024-02-29T16:19:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 60,
      "id": "PR_kwDOKZ8QO85oPUkw",
      "title": "Describe retries, deduplication and trade-offs",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/60",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #54 ",
      "createdAt": "2024-02-29T02:26:16Z",
      "updatedAt": "2024-03-01T00:26:43Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "d72db4b7a23c05d02048dfbbd50d97843a153d9a",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "dedup",
      "headRefOid": "499bbfaac9b6fcc49f9856c9aa4e8e60711251a6",
      "closedAt": "2024-03-01T00:26:19Z",
      "mergedAt": "2024-03-01T00:26:19Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "5e1cd5892cd61f3392df4041c80921e54d3bcf48"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85xugzG",
          "commit": {
            "abbreviatedOid": "3f78626"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-29T05:50:35Z",
          "updatedAt": "2024-02-29T05:50:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO85xuxCL",
          "commit": {
            "abbreviatedOid": "3f78626"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-29T06:45:10Z",
          "updatedAt": "2024-02-29T06:45:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 61,
      "id": "PR_kwDOKZ8QO85oQs3-",
      "title": "Add new External join flow for new client and related mechanism",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/61",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Add a flow for Cathy's adding a new client ClientC3 to the Alice, Bob, Cathy flow. \r\n- Add GroupInfo fetching mechanism",
      "createdAt": "2024-02-29T07:55:54Z",
      "updatedAt": "2024-10-21T02:38:19Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "5e1cd5892cd61f3392df4041c80921e54d3bcf48",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/groupinfo",
      "headRefOid": "4ff7140bb37e16bf5f4714c27da998629972f120",
      "closedAt": "2024-03-01T23:14:35Z",
      "mergedAt": "2024-03-01T23:14:35Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "7e1719f65858e08594367a221f7c7cb49b1d5c83"
      },
      "comments": [
        {
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "body": "@rohanmahy were @bifurcation's comments incorporated somewhere?",
          "createdAt": "2024-03-02T23:39:50Z",
          "updatedAt": "2024-03-02T23:39:50Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "> @rohanmahy were @bifurcation's comments incorporated somewhere?\r\n\r\nThe first and second comments I provided some specific comments. I don't believe there needs to be a change. I'm fine with removing \"or reconstruct\". \r\n\r\nFor his last comment, I kept consistency with the current order (order these are introduced). If someone suggests a different ordering that's fine, but I would like to understand the premise of the ordering, or if there is a desire for the *section* to come earlier. When we address the versioning issue would be an excellent time to resolve this.",
          "createdAt": "2024-03-02T23:55:10Z",
          "updatedAt": "2024-03-02T23:55:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85xvciY",
          "commit": {
            "abbreviatedOid": "b299d3a"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the PR! Looks good with a few comments.",
          "createdAt": "2024-02-29T08:32:51Z",
          "updatedAt": "2024-02-29T10:52:23Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nIn MLS in order to initiate joining a group the joining client needs to get the current GroupInfo\r\n```",
              "createdAt": "2024-02-29T08:32:51Z",
              "updatedAt": "2024-02-29T10:52:23Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nFor Cathy's new client (ClientC3) to join the MLS group and therefore fully participate\r\n```",
              "createdAt": "2024-02-29T08:35:16Z",
              "updatedAt": "2024-02-29T10:52:23Z"
            },
            {
              "originalPosition": 117,
              "body": "We should probably elaborate a bit on the authentication story here, i.e. point out that the hub needs to validate the `requestingCredential` against the sender's guest server, as well as the fact that the credential is somehow bound to the `requestingSignatureKey`.",
              "createdAt": "2024-02-29T08:55:35Z",
              "updatedAt": "2024-02-29T10:52:23Z"
            },
            {
              "originalPosition": 118,
              "body": "For clarity, I'd refactor this slightly include the sender type (participant vs. non-participant) and then have a select statement that includes the authentication info needed to authenticate that particular sender type.",
              "createdAt": "2024-02-29T08:57:27Z",
              "updatedAt": "2024-02-29T10:52:23Z"
            },
            {
              "originalPosition": 150,
              "body": "Isn't all of this already in the GroupInfo?\r\n\r\nAlso, I would add the `hub_sender` that ends up signing the `GroupInfoTBS` s.t. the HPKE ciphertext is bound to the signer.",
              "createdAt": "2024-02-29T09:04:19Z",
              "updatedAt": "2024-02-29T10:52:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85x-gSC",
          "commit": {
            "abbreviatedOid": "4ff7140"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks OK to me with a couple minor comments.",
          "createdAt": "2024-03-01T22:58:38Z",
          "updatedAt": "2024-03-01T23:01:42Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nthe hub keeps a copy of the GroupInfo, assuming that other\r\n```\r\n\r\nThe hub cannot create a valid GroupInfo, since it has to be signed by a member of the group.  ",
              "createdAt": "2024-03-01T22:58:38Z",
              "updatedAt": "2024-03-01T23:01:42Z"
            },
            {
              "originalPosition": 62,
              "body": "It would be good to show how a GroupInfo gets populated.  Maybe it should be added to the add flows above?",
              "createdAt": "2024-03-01T23:00:16Z",
              "updatedAt": "2024-03-01T23:01:42Z"
            },
            {
              "originalPosition": 92,
              "body": "Nit: I would move this up to be after `update`.",
              "createdAt": "2024-03-01T23:00:46Z",
              "updatedAt": "2024-03-01T23:01:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 62,
      "id": "PR_kwDOKZ8QO85odNNm",
      "title": "Introduce very lightweight notion of role-based access control",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/62",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-03-01T22:13:40Z",
      "updatedAt": "2024-10-21T02:38:15Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "5e1cd5892cd61f3392df4041c80921e54d3bcf48",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/rbac",
      "headRefOid": "d6eae33af63136dca0ddefdfd1cc543d78ae18fd",
      "closedAt": "2024-03-03T06:47:37Z",
      "mergedAt": "2024-03-03T06:47:37Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "615b710af6d5cface7856b885a132e3ca5cbe8c2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85yArZ7",
          "commit": {
            "abbreviatedOid": "990742b"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-02T23:43:45Z",
          "updatedAt": "2024-03-02T23:43:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO85yAvDR",
          "commit": {
            "abbreviatedOid": "990742b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-03T01:01:41Z",
          "updatedAt": "2024-03-03T01:07:12Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Suggest enclosing the permissions in double quotes as well.  Or removing them from the label name.  Maybe something like:\r\n\r\n```\r\nadmin = [canAddUser, canRemoveUser, canSetUserRole]\r\n```",
              "createdAt": "2024-03-03T01:01:41Z",
              "updatedAt": "2024-03-03T01:07:12Z"
            },
            {
              "originalPosition": 43,
              "body": "What are the semantics of Add with respect to roles?  I assume every user has to have an assigned role.  Are new users assigned a default role, or does the Add need to specify a role?\r\n\r\nUpdate has an unfortunate resonance with the MLS operation of the same name (and different semantic).  I would suggest using `SetRole` for this, which aligns well with the example permissions above.",
              "createdAt": "2024-03-03T01:05:03Z",
              "updatedAt": "2024-03-03T01:07:12Z"
            },
            {
              "originalPosition": 38,
              "body": "You need to elaborate a little more here and above.\r\n\r\n* The base policy is probably where the role definitions go\r\n* The participation list has a list of participants and their roles (cf. \"permissions\" now)\r\n* The participation list can be modified by adding users, removing users, **or setting a user's role**\r\n\r\nAlso, \"participant list\" seems more natural to me than \"participation list\"",
              "createdAt": "2024-03-03T01:06:58Z",
              "updatedAt": "2024-03-03T01:07:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85yBHrQ",
          "commit": {
            "abbreviatedOid": "990742b"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-03T06:46:57Z",
          "updatedAt": "2024-03-03T06:46:57Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "OK updated.",
              "createdAt": "2024-03-03T06:46:57Z",
              "updatedAt": "2024-03-03T06:46:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85yBHsY",
          "commit": {
            "abbreviatedOid": "990742b"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-03T06:47:30Z",
          "updatedAt": "2024-03-03T06:47:30Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "ok modified as suggested",
              "createdAt": "2024-03-03T06:47:30Z",
              "updatedAt": "2024-03-03T06:47:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 63,
      "id": "PR_kwDOKZ8QO85odWyx",
      "title": "Add explanation of KP capabilities",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/63",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "alternate to PR #51 ",
      "createdAt": "2024-03-01T22:55:47Z",
      "updatedAt": "2024-10-21T02:38:16Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "5e1cd5892cd61f3392df4041c80921e54d3bcf48",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/kp-nego",
      "headRefOid": "4569228392b8e98576822278bfca9bd236084572",
      "closedAt": "2024-03-02T23:56:16Z",
      "mergedAt": "2024-03-02T23:56:16Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "e44c1f073b0c7211852bfb614e98698ff8e6c815"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85yArY4",
          "commit": {
            "abbreviatedOid": "14a8df2"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "thanks!",
          "createdAt": "2024-03-02T23:42:50Z",
          "updatedAt": "2024-03-02T23:42:55Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n`RequiredCapabilites` to ensure the new joiner is compatible with and\r\n```",
              "createdAt": "2024-03-02T23:42:50Z",
              "updatedAt": "2024-03-02T23:42:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOKZ8QO85odYiV",
      "title": "Update CODEOWNERS",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/64",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "add all authors/contributors as CODEOWNERS",
      "createdAt": "2024-03-01T23:02:49Z",
      "updatedAt": "2024-10-21T02:38:18Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "5e1cd5892cd61f3392df4041c80921e54d3bcf48",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "fix-codeowners",
      "headRefOid": "042ac23fc20c3867f440b313ce18039957a149d9",
      "closedAt": "2024-03-02T16:39:46Z",
      "mergedAt": "2024-03-02T16:39:46Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "b9aae386ea4b374de1973f9c1d0d80b4bdd0ef52"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85yAU9F",
          "commit": {
            "abbreviatedOid": "042ac23"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-02T16:25:53Z",
          "updatedAt": "2024-03-02T16:25:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 65,
      "id": "PR_kwDOKZ8QO85odgR6",
      "title": "Add Richard as editor move Rohan to an author",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/65",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-03-01T23:37:48Z",
      "updatedAt": "2024-10-21T02:38:16Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "7e1719f65858e08594367a221f7c7cb49b1d5c83",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "authors",
      "headRefOid": "0b4f0bbcf3195d733c933711d3735c596f33664d",
      "closedAt": "2024-03-02T16:40:06Z",
      "mergedAt": "2024-03-02T16:40:06Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "04c6913770a4adbe603f2dc84248fdd51f5ac59a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85yAU8O",
          "commit": {
            "abbreviatedOid": "0b4f0bb"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-02T16:25:32Z",
          "updatedAt": "2024-03-02T16:25:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 66,
      "id": "PR_kwDOKZ8QO85odr9w",
      "title": "Fix ASCII art / AASVG diagrams",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/66",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Send responses as soon as feasible in \"Alice Adds Bob\" flow\r\n\r\nFor Bob Adds Cathy flow \r\n- make ASCII art fit in 72 characters (only done so far for Bob Adds Cathy flow)\r\n- show fanout to multiple servers and clients closer/tighter in time \r\n\r\nShow fanouts to Clients of final commits for Bob leaves room flow\r\n",
      "createdAt": "2024-03-02T00:26:22Z",
      "updatedAt": "2024-10-21T02:38:09Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "7e1719f65858e08594367a221f7c7cb49b1d5c83",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/fix-diagrams",
      "headRefOid": "25b8cff7a40269ff289ad4a0d0b3e0acfb20a813",
      "closedAt": "2024-03-04T16:56:44Z",
      "mergedAt": "2024-03-04T16:56:44Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "cfe2d6d8ce148bf11af9a214e5dc765dc0b7507d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85yIT5O",
          "commit": {
            "abbreviatedOid": "311c71b"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-04T16:34:20Z",
          "updatedAt": "2024-03-04T16:34:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 67,
      "id": "PR_kwDOKZ8QO85omxTh",
      "title": "Update author list",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/67",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Remove `editor` role from Barnes\r\n* Put authors in alphabetical order by last name",
      "createdAt": "2024-03-04T15:35:41Z",
      "updatedAt": "2024-10-21T02:38:13Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "615b710af6d5cface7856b885a132e3ca5cbe8c2",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "author-tweak",
      "headRefOid": "78a711485a7ea4164e25aa717235975b409eba04",
      "closedAt": "2024-03-04T16:04:49Z",
      "mergedAt": "2024-03-04T16:04:49Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f885208a79044e9882289efa031178444466156a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85yHx5M",
          "commit": {
            "abbreviatedOid": "78a7114"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-04T15:36:52Z",
          "updatedAt": "2024-03-04T15:36:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO85yIBpT",
          "commit": {
            "abbreviatedOid": "78a7114"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-04T16:03:30Z",
          "updatedAt": "2024-03-04T16:03:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 69,
      "id": "PR_kwDOKZ8QO85onf54",
      "title": "Add missing status semantics",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/69",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add missing status semantics for:\r\n- KeyMaterialClientCode\r\n- GroupInfoCode\r\n",
      "createdAt": "2024-03-04T17:17:42Z",
      "updatedAt": "2024-10-21T02:38:08Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "cfe2d6d8ce148bf11af9a214e5dc765dc0b7507d",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/missing-status",
      "headRefOid": "36781c9a90ea9ccea81c94693b135895b113ef99",
      "closedAt": "2024-03-04T17:30:15Z",
      "mergedAt": "2024-03-04T17:30:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a872090b97512cd4a1a0021a5cc35f6681659dcb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85yIr80",
          "commit": {
            "abbreviatedOid": "36781c9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-04T17:18:59Z",
          "updatedAt": "2024-03-04T17:18:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 71,
      "id": "PR_kwDOKZ8QO85onzCf",
      "title": "Appease idnits: replace non-ascii characters",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/71",
      "state": "MERGED",
      "author": "turt2live",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes https://github.com/bifurcation/ietf-mimi-protocol/issues/70\r\n\r\nNot critical for submission, given it was posted with these \"errors\" anyways.",
      "createdAt": "2024-03-04T18:07:26Z",
      "updatedAt": "2024-03-04T18:30:05Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "a872090b97512cd4a1a0021a5cc35f6681659dcb",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "travis/ascii",
      "headRefOid": "2d7bad8ef131b73ab76b84e93d9bed034a3a39e2",
      "closedAt": "2024-03-04T18:28:09Z",
      "mergedAt": "2024-03-04T18:28:09Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "353cc7e612b6de148df168fc0a9b6b58acae6c36"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85yJLFa",
          "commit": {
            "abbreviatedOid": "2d7bad8"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-04T18:26:39Z",
          "updatedAt": "2024-03-04T18:26:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 72,
      "id": "PR_kwDOKZ8QO85pc4Ih",
      "title": "Add consent discussion and mechanism",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/72",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WG reviewed"
      ],
      "body": "",
      "createdAt": "2024-03-13T02:11:04Z",
      "updatedAt": "2024-10-21T02:38:06Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "353cc7e612b6de148df168fc0a9b6b58acae6c36",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/consent",
      "headRefOid": "dd9199ea036c66081e1a251cbf17746efeb7860e",
      "closedAt": "2024-04-29T15:49:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Konrad,\r\nThanks for the fast review.\r\n\r\nRegarding the first suggestion, I always wanted providers to be able\r\nrestrict KeyPackage usage to a specific room, but I didn't want to make it\r\nmandatory, since some providers have other implicit consent mechanisms. I'm\r\nhappy to discuss with you and see how we can improve the text.\r\n\r\nI would love to see a PR improving the privacy as you described.I think\r\nsomewhere it says that at least that the user identiifiers can be\r\npseudonymous user IDs only used for a single room.\r\n\r\nThanks,\r\n-rohan\r\n\r\n\r\nOn Wed, Mar 13, 2024, 16:38 Konrad Kohbrok ***@***.***> wrote:\r\n\r\n> ***@***.**** commented on this pull request.\r\n>\r\n> Thanks for writing this up! Sounds generally like a good mechanism to me.\r\n> Two thoughts:\r\n>\r\n> Getting hold of a KeyPackage is generally pretty easy (e.g. just pluck it\r\n> from a tree in some group you're in), so it might be worth restricting\r\n> their use a bit. As I understand this proposal, it's mostly about the\r\n> decision whether the a provider will hand out KeyPackages for its users.\r\n> However, we could extend it by generally requiring that when adding a new\r\n> user to a room (with one or more initial clients), the adder has to prove\r\n> that the target user (or at least the target user's provider) has\r\n> consented, in which case the scoping with the room id becomes enforcable.\r\n>\r\n> I'm also wondering if we can avoid leaking the identity of the KeyPackage\r\n> requester to the target's provider, i.e. prove that consent was previously\r\n> obtained in zero knowledge of the requester's identity. We could use\r\n> anonymous credentials or something like Privacy Pass to that end.\r\n>\r\n> If either of those suggestions sounds reasonable I'd be happy to\r\n> contribute either to this PR or in a follow-up.\r\n> ------------------------------\r\n>\r\n> In draft-ralston-mimi-protocol.md\r\n> <https://github.com/bifurcation/ietf-mimi-protocol/pull/72#discussion_r1522593005>\r\n> :\r\n>\r\n> > @@ -1246,6 +1245,98 @@ key. The GroupInfo in another context might be sufficiently sensitive that\r\n>  it should be encrypted from the end client to the hub provider (unreadable\r\n>  by the local provider).\r\n>\r\n> +## Convey explicit consent\r\n> +\r\n> +As discussed in {{consent}}, there are many ways that a provider could\r\n> +implicitly determine consent. This section describes a mechanism by which providers can explicitly request consent from a user of another provider,\r\n> +cancel such a request, convey that consent was granted, or convey that\r\n> +consent was revoked or preemptively denied.\r\n> +\r\n> +~~~\r\n> +POST /requestConsent/{targetDomain}\r\n> +POST /updateConsent/{requesterDomain}\r\n> +~~~\r\n> +\r\n> +A `requestContent` request is used by one provider to request explicit\r\n>\r\n> \u2b07\ufe0f Suggested change\r\n>\r\n> -A `requestContent` request is used by one provider to request explicit\r\n> +A `requestConsent` request is used by one provider to request explicit\r\n>\r\n> ------------------------------\r\n>\r\n> In draft-ralston-mimi-protocol.md\r\n> <https://github.com/bifurcation/ietf-mimi-protocol/pull/72#discussion_r1522594624>\r\n> :\r\n>\r\n> > +  IdentifierUri targetUri;\r\n> +  optional<RoomId> roomId;\r\n> +  select (consentOperation) {\r\n> +      case grant:\r\n> +          KeyPackage clientKeyPackages<V>;\r\n> +  };\r\n> +} ConsentEntry;\r\n> +\r\n> +struct {\r\n> +  IdentifierUri requesterUri;\r\n> +  IdentifierUri targetUri;\r\n> +  optional<RoomId> roomId;\r\n> +} ConsentScope;\r\n> +~~~\r\n> +\r\n> +An `updateContent` request is used by one provider to provide explicit\r\n>\r\n> \u2b07\ufe0f Suggested change\r\n>\r\n> -An `updateContent` request is used by one provider to provide explicit\r\n> +An `updateConsent` request is used by one provider to provide explicit\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/bifurcation/ietf-mimi-protocol/pull/72#pullrequestreview-1933245780>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AADSQPWHAE6SGALCPEHN6WLYX7X5VAVCNFSM6AAAAABETJSQPGVHI2DSMVQWIX3LMV43YUDVNRWFEZLROVSXG5CSMV3GSZLXHMYTSMZTGI2DKNZYGA>\r\n> .\r\n> You are receiving this because you authored the thread.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2024-03-13T08:58:35Z",
          "updatedAt": "2024-03-13T08:58:35Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "There's not need to make the scoping mandatory. However, it would be a bit more involved than just changing the text a little bit. Here's what I roughly had in mind:\r\n\r\n- Whenever a provider responds with a KeyPackage, it also provides as proof of consent a signature over the KeyPackage (or hash thereof), as well as a over the scope of the consent and the validity period of the proof of consent. The scope might include the name of the requester (or a pseudonym or similar) and optionally a room id.\r\n- If the consent mechanism is implicit, the provider can just sign the KeyPackage without additional information\r\n- Whenever a KeyPackage is used to add someone to a group, the adder has to provide the signature and scope of consent. - Other group members can then verify that the adder is actually allowed to use the KeyPackage in this context by verifying that the senders name/pseudonym, the room id and the validity period.\r\n\r\nWe could also use this mechanism to ensure that a requester always adds all clients of a given user: When a user requests KeyPackages for a user, the provider would provide a signature over all of the KeyPackages in the response.\r\n\r\nI'll try to come up with a proposal for how we can hide requester Metadata in a follow-up PR.",
          "createdAt": "2024-03-13T10:41:16Z",
          "updatedAt": "2024-03-13T10:41:16Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2024-04-10:\r\n* Clear to merge once conflicts are resolved.",
          "createdAt": "2024-04-10T16:20:26Z",
          "updatedAt": "2024-04-10T16:20:26Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaced by #78 . Closing.",
          "createdAt": "2024-04-29T15:49:08Z",
          "updatedAt": "2024-04-29T15:49:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85zOv1U",
          "commit": {
            "abbreviatedOid": "9278c90"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for writing this up! Sounds generally like a good mechanism to me. Two thoughts:\r\n\r\nGetting hold of a KeyPackage is generally pretty easy (e.g. just pluck it from a tree in some group you're in), so it might be worth restricting their use a bit. As I understand this proposal, it's mostly about the decision whether the a provider will hand out KeyPackages for its users. However, we could extend it by generally requiring that when adding a new user to a room (with one or more initial clients), the adder has to prove that the target user (or at least the target user's provider) has consented, in which case the scoping with the room id becomes enforcable.\r\n\r\nI'm also wondering if we can avoid leaking the identity of the KeyPackage requester to the target's provider, i.e. prove that consent was previously obtained in zero knowledge of the requester's identity. We could use anonymous credentials or something like Privacy Pass to that end.\r\n\r\nIf either of those suggestions sounds reasonable I'd be happy to contribute either to this PR or in a follow-up.",
          "createdAt": "2024-03-13T06:22:21Z",
          "updatedAt": "2024-03-13T06:37:56Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nA `requestConsent` request is used by one provider to request explicit\r\n```",
              "createdAt": "2024-03-13T06:22:21Z",
              "updatedAt": "2024-03-13T06:37:56Z"
            },
            {
              "originalPosition": 101,
              "body": "```suggestion\r\nAn `updateConsent` request is used by one provider to provide explicit\r\n```",
              "createdAt": "2024-03-13T06:24:03Z",
              "updatedAt": "2024-03-13T06:37:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85zUqpp",
          "commit": {
            "abbreviatedOid": "9278c90"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "overall this looks like a great starting point for a larger conversation. I'm still pondering the safety implications of such a system, but the basics do seem to be covered.",
          "createdAt": "2024-03-13T17:27:48Z",
          "updatedAt": "2024-03-13T17:39:55Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Block means neither user can communicate with the other, and both users are aware of that fact. To prevent a user from communicating with you, but them not being aware of that fact, a \"mute\" is used instead. These terms are defined by the UK Online Safety Act and similar proposed legislation in the EU, US, and Canada.\r\n\r\nOr in other words, privacy sensitivity is covered by mutes, not blocks.",
              "createdAt": "2024-03-13T17:27:48Z",
              "updatedAt": "2024-03-13T17:39:56Z"
            },
            {
              "originalPosition": 103,
              "body": "It feels a bit awkward that a server needs to round trip another request to decline consent, if it already knows at the point of request that it will be declined. For example, the target user has muted/blocked the requesting user or the server has a safety policy which denies consent requests from the requesting server. Could we add an error code/indication that consent is not possible to `requestConsent` to short circuit the need for `requestConsent->201, updateConsent`?",
              "createdAt": "2024-03-13T17:32:27Z",
              "updatedAt": "2024-03-13T17:39:56Z"
            },
            {
              "originalPosition": 86,
              "body": "These fields likely need a condition to say they belong to the respective server. Namely, the requester belongs to the requesting server and the target belongs to the receiving server. Otherwise, 400 Bad Request for making an improper request.",
              "createdAt": "2024-03-13T17:39:07Z",
              "updatedAt": "2024-03-13T17:39:56Z"
            },
            {
              "originalPosition": 42,
              "body": "Do these endpoints get routed through the hub?",
              "createdAt": "2024-03-13T17:39:22Z",
              "updatedAt": "2024-03-13T17:39:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85zsIPv",
          "commit": {
            "abbreviatedOid": "4bfe00b"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-16T04:34:31Z",
          "updatedAt": "2024-03-16T04:34:31Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Thanks for asking. I think they do not. Alice's domain would need to have a consent relationship of some type directly with the domain of the target client.\r\n\r\nThe KeyPackage request gets routed through the hub, so it can route the subsequent Welcome.",
              "createdAt": "2024-03-16T04:34:31Z",
              "updatedAt": "2024-03-16T04:34:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85zsIay",
          "commit": {
            "abbreviatedOid": "4bfe00b"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-16T04:39:32Z",
          "updatedAt": "2024-03-16T04:39:32Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "OK, I think I can say that in prose. How about?\r\n\r\n\"For a `requestContent`, the `targetUri` needs to be in one of the domains of the receiving server, and the `requesterUri` needs to be in one of the domains of the sending server. \r\n\r\nFor `updateConsent` the `requesterUri` needs to be in one of the domains of the receiving server, and the `targetUri` needs to be in one of the domains of the sending server.\"",
              "createdAt": "2024-03-16T04:39:32Z",
              "updatedAt": "2024-03-16T04:39:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85zsIsx",
          "commit": {
            "abbreviatedOid": "4bfe00b"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-16T04:48:57Z",
          "updatedAt": "2024-03-16T04:48:58Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Thanks for pointing that out. I think there is a lot of usage of these terms predating the [2023 UK Online Safety Act](https://www.legislation.gov.uk/ukpga/2023/50/enacted). Block is used by XMPP and WhatsApp, and I think mute could be confused for audio/video muting, muting notifications, or revoking voice in a group chat. I don't have a strong feeling about which set terms we use.\r\n\r\nI'll make a slide.",
              "createdAt": "2024-03-16T04:48:57Z",
              "updatedAt": "2024-03-16T04:48:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85ztiSS",
          "commit": {
            "abbreviatedOid": "9278c90"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-16T20:23:56Z",
          "updatedAt": "2024-03-16T20:23:56Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "I think the way several of these systems work, the requester never finds out if consent was rejected or the user just never responded (for privacy reasons). I think it is fine to say that a server can just come right out and say no, you don't get consent if this is consistent with their privacy policies. However the most likely case seems that they never get an answer.\r\n\r\nI expect in some systems updateConsent with a reject will only be used to remove consent after it had been previously granted.",
              "createdAt": "2024-03-16T20:23:56Z",
              "updatedAt": "2024-03-19T21:41:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85z5aQf",
          "commit": {
            "abbreviatedOid": "9278c90"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T23:11:37Z",
          "updatedAt": "2024-03-18T23:11:38Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "hmm, good point. Most requests would be ignored - given the rarity, two requests seems fine.\r\n\r\nThanks for working through the suggestion. Resolving.",
              "createdAt": "2024-03-18T23:11:38Z",
              "updatedAt": "2024-03-18T23:11:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85z5axp",
          "commit": {
            "abbreviatedOid": "9278c90"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T23:12:29Z",
          "updatedAt": "2024-03-18T23:12:29Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Looks good to me, though the plural of \"domains\" is a bit scary - not sure we've discussed a provider having multiple domains yet.",
              "createdAt": "2024-03-18T23:12:29Z",
              "updatedAt": "2024-03-18T23:12:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85z5a_A",
          "commit": {
            "abbreviatedOid": "9278c90"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T23:12:51Z",
          "updatedAt": "2024-03-18T23:12:51Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "(this makes sense - it should be clarified in the text)",
              "createdAt": "2024-03-18T23:12:51Z",
              "updatedAt": "2024-03-18T23:12:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO850E9hv",
          "commit": {
            "abbreviatedOid": "9278c90"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T21:46:56Z",
          "updatedAt": "2024-03-19T21:46:56Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "OK, changed \"Blocking\" to \"Revoking consent\".",
              "createdAt": "2024-03-19T21:46:56Z",
              "updatedAt": "2024-03-19T21:46:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO850FADv",
          "commit": {
            "abbreviatedOid": "9278c90"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T21:54:24Z",
          "updatedAt": "2024-03-19T21:54:24Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "OK, add a short paragraph in https://github.com/bifurcation/ietf-mimi-protocol/pull/72/commits/dd9199ea036c66081e1a251cbf17746efeb7860e . Hopefully that does the trick.",
              "createdAt": "2024-03-19T21:54:24Z",
              "updatedAt": "2024-03-19T21:54:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 73,
      "id": "PR_kwDOKZ8QO85pgb0g",
      "title": "Add basic abuse reporting mechanism",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/73",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WG reviewed"
      ],
      "body": "",
      "createdAt": "2024-03-13T13:26:24Z",
      "updatedAt": "2024-10-21T02:38:07Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "353cc7e612b6de148df168fc0a9b6b58acae6c36",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/abuse",
      "headRefOid": "5c6223f4ddaa59e636c95e7746bdc059f716211b",
      "closedAt": "2024-07-22T17:01:23Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "In the case where the abuse comes from the abuser's provider (such as when the \"abuser\" is a fake identity created by the abuser's provider in order to achieve abusive outcomes like spam or phishing), sending an abuse complaint verbatim to the abuser's provider is exactly the wrong thing to do.\r\n\r\nThe abuser's provider may need to get told that sanctions have been imposed against his user, but telling him why feeds into machine learning on how to avoid anti-abuse mechanisms.\r\n\r\n",
          "createdAt": "2024-03-16T21:50:20Z",
          "updatedAt": "2024-03-16T21:50:20Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion about the potential for a reporter to forge an abusive message at interim meeting 10-Apr-2024:\r\n\r\n- Travis says the abuse reports should go to the reporter's provider, while the hub provider is specified in the PR currently. Harald says you shouldn't reveal abuse reports to the alleged abuser's provider.\r\n- The situation is better than if we only have AEAD, but we still may need some additional franking (by the hub using a symmetric algorithm)\r\n- There is a risk of \"outing\" a pseudonymized user.\r\n",
          "createdAt": "2024-04-10T16:36:59Z",
          "updatedAt": "2024-04-10T16:36:59Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2024-04-10\r\n* Need to address risk of forgery by reporter\r\n    * Deployed state of the art is \"franking\"\r\n    * MLS signature could help obviate the need for franking\r\n    * Even in metadata-limited case, signature keys are used, but they're not linked to the real identity\r\n        * Might not be able to rely much on signature here; might need franking\r\n        * Or might need to deanonymize a participant in the event of abuse\r\n    * Would be good to protect reporter identity in this process \r\n* Should abuse reports go to the hub?\r\n    * Reporter provider, hub, abuser's provider, other providers?\r\n    * Could also augment a standard thing with out-of-band mechanisms\r\n    * Reporter provider will get it through the submission process\r\n    * Should not provide it to abuser's provider\r\n    * So the question reduces to whether to provide to the hub\r\n    * Might need more review of use cases, maybe a generic \"send report to provider\", irrespective of room topology\r\n* Conclusions:\r\n    * If we have a reporting mechanism, need to address reporter forgery\r\n    * We should define an abuse endpoint for providing inputs to anti-abuse processes\r\n* TODO: @rohanmahy will revise to reflect discussion, bring back to the group\r\n\r\n\r\n\r\n",
          "createdAt": "2024-04-10T16:56:53Z",
          "updatedAt": "2024-04-10T16:56:53Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Replacing with franking based proposal in #83 ",
          "createdAt": "2024-07-22T17:01:23Z",
          "updatedAt": "2024-07-22T17:01:23Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85zU26i",
          "commit": {
            "abbreviatedOid": "5c6223f"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-13T17:52:08Z",
          "updatedAt": "2024-03-13T17:52:08Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Feels a bit weird that abuse would only be reported to the hub. The provider which sent the content should receive that report, and there may need to be redirection from the server to the moderators of the room.\r\n\r\nThere's also a whole can of worms opened here regarding safety legislation, including reversible actions, reporting, appeals, suspension, and notification of action taken (both to the reporter and affected user). ",
              "createdAt": "2024-03-13T17:52:08Z",
              "updatedAt": "2024-03-13T17:52:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85zsJFb",
          "commit": {
            "abbreviatedOid": "5c6223f"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-16T05:04:20Z",
          "updatedAt": "2024-03-16T05:04:20Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": ">Feels a bit weird that abuse would only be reported to the hub. \r\nWhat does the MIMI protocol need to provide at minimum?  Let's consider the reporting client, the reporting provider, the hub, the abuser's provider, and the abuser's client.\r\n\r\nThe clients don't run the MIMI protocol. The reporting provider got informed using a provider-specific protocol, the hub (especially in it's role of policy enforcer) definitely needs to get this information. So that leaves the abuser's provider.\r\n\r\n>The provider which sent the content should receive that report, and there may need to be redirection from the server to the moderators of the room.\r\n\r\nI will argue that the abuser provider shouldn't automatically get the report, and in some cases should never get the (unredacted) report. The peering relationship between the hub and the abuser provider should specify the details of what the abuser's provider gets. Also, after the report is sent, the hub may do all kinds of analysis and/or send the content to a human moderator to look at. Only after the hub provider decides something is or is not in their policy would they have any cause to send something to another provider. In any case, I think this need not be part of a real-time protocol in MIMI. \r\n\r\nI think all the actions you listed in your can of worms refer to a subset of the information in the original report. ",
              "createdAt": "2024-03-16T05:04:20Z",
              "updatedAt": "2024-03-16T05:04:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO850NHhp",
          "commit": {
            "abbreviatedOid": "5c6223f"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-20T17:28:47Z",
          "updatedAt": "2024-03-20T17:28:47Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "(the quotes look a bit mangled, ftr)\r\n\r\nI think we're jumping to an edge case here. Reports over federation *should not* contain details of the reporter, for several safety reasons. Following the path of a report:\r\n\r\n* Alice reports Bob's message to their local provider. The local provider receives information about Alice's client, Bob's message, decryption keys, and possibly a user-supplied label/reason for the report, among other details. As this is a provider-local operation, it is out of scope for MIMI.\r\n* Alice's local provider does some filtering and processing on the report. This may be automated, or it may be subject to human review. In this case, the report cannot be handled by Alice's local provider, and so Bob's provider needs to be involved.\r\n* Alice's local provider creates a *minimal* report to send to Bob's server. Specific details include the message identifier which was reported, maybe decryption keys (assuming they don't contain identifying information of the reporter), and optionally a classification label/reason. The label/reason *may* be different from the original report.\r\n* Bob's local provider upon receiving this report processes it, potentially maliciously forwarding it to Bob directly. This is why we don't include information about who did the report, just where it came from. \r\n\r\nI've not indicated which server is the hub here because I don't think it applies. Forwarding all reports to the hub feels like a risk, as the hub provider is then responsible for all abuse mitigation for the room - not something MIMI's consumers are likely to agree with. Instead, reports can be sent directly to the server which emitted the content, removing the need for a platform moderation team to monitor reports on platforms they don't control.",
              "createdAt": "2024-03-20T17:28:47Z",
              "updatedAt": "2024-03-20T17:28:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 74,
      "id": "PR_kwDOKZ8QO85pggWR",
      "title": "Initial stab at finding internal identifiers primitive",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/74",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WG reviewed"
      ],
      "body": "",
      "createdAt": "2024-03-13T13:36:02Z",
      "updatedAt": "2024-07-07T16:04:11Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "50ad85ec9bc33c74a9a09484b19005f48d34d503",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/findInternal",
      "headRefOid": "0056cb61f9bc76c4ab225b893c71821cf08540f4",
      "closedAt": "2024-07-07T16:04:02Z",
      "mergedAt": "2024-07-07T16:04:02Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ac27aa788b6277fbe0001347bbcd2ef35660a16c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85zU1XJ",
          "commit": {
            "abbreviatedOid": "83608cc"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-13T17:49:13Z",
          "updatedAt": "2024-03-13T17:49:13Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "This feature feels like it should be part of the discovery document rather than protocol. It feels distinct enough to be a dedicated document with search capabilities and global directories. ",
              "createdAt": "2024-03-13T17:49:13Z",
              "updatedAt": "2024-03-13T17:49:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85zsJJq",
          "commit": {
            "abbreviatedOid": "83608cc"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-16T05:07:31Z",
          "updatedAt": "2024-03-16T05:07:31Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "The discovery documents are explicitly about discovering _which provider_ is associated with a specific SII. This is entirely about searching inside a provider, instead of finding a provider, so I think it is still in scope. This is a good question for the WG though. ",
              "createdAt": "2024-03-16T05:07:31Z",
              "updatedAt": "2024-03-16T05:07:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO852wOzy",
          "commit": {
            "abbreviatedOid": "83608cc"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-10T17:56:07Z",
          "updatedAt": "2024-04-10T17:56:08Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "concrete example here, would be interesting.\r\n\r\nI liked the visual description of how this might be realized discussed on the call.\r\n\r\n\"Search Messaging Provider\" -> \"Find `alice@vendor.example` on Messaging Provider\" -> get instance of data model needed to start connection...",
              "createdAt": "2024-04-10T17:56:07Z",
              "updatedAt": "2024-04-10T17:56:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO852wP-g",
          "commit": {
            "abbreviatedOid": "83608cc"
          },
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-10T17:59:01Z",
          "updatedAt": "2024-04-10T17:59:01Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "GET is inappropriate since there is a request body. I think POST or the not-yet-quite-standard QUERY methods would work.",
              "createdAt": "2024-04-10T17:59:01Z",
              "updatedAt": "2024-04-10T17:59:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO85473wA",
          "commit": {
            "abbreviatedOid": "83608cc"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-29T16:13:10Z",
          "updatedAt": "2024-04-29T16:13:10Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "The QUERY method is described in https://datatracker.ietf.org/doc/draft-ietf-httpbis-safe-method-w-body/\r\nThe draft has expired twice since becoming a WG item and three times as an individual draft. As of today it has 88 [open issues](https://github.com/httpwg/http-extensions/issues) in the github repo. Even though I think this usage is 100% aligned with QUERY, I don't want to depend on this work which appears to be proceeding slowly.\r\n\r\nI added a commit to just use POST instead of GET.",
              "createdAt": "2024-04-29T16:13:10Z",
              "updatedAt": "2024-04-29T16:13:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO8549iOi",
          "commit": {
            "abbreviatedOid": "83608cc"
          },
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-29T19:22:43Z",
          "updatedAt": "2024-04-29T19:22:43Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I think that's a sensible choice. You might add a note that this POST request is idempotent and safe in the sense defined by [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110#idempotent.methods).",
              "createdAt": "2024-04-29T19:22:43Z",
              "updatedAt": "2024-04-29T19:22:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO859psFG",
          "commit": {
            "abbreviatedOid": "c75a542"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-10T15:09:11Z",
          "updatedAt": "2024-06-10T15:09:22Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nprovider (it does not transit a hub). Note that this POST request is idempotent and safe in the sense defined by {{Section 9.2.2 of RFC9110}}.\r\n```",
              "createdAt": "2024-06-10T15:09:11Z",
              "updatedAt": "2024-06-10T15:09:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86A1rPj",
          "commit": {
            "abbreviatedOid": "f484896"
          },
          "author": "tgeoghegan",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-06T17:04:23Z",
          "updatedAt": "2024-07-06T17:05:05Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "nit: wrap the long line",
              "createdAt": "2024-07-06T17:04:23Z",
              "updatedAt": "2024-07-06T17:05:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 75,
      "id": "PR_kwDOKZ8QO85pgiRV",
      "title": "Add a download files proxy primitive",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/75",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WG reviewed"
      ],
      "body": "",
      "createdAt": "2024-03-13T13:40:11Z",
      "updatedAt": "2025-03-16T07:19:22Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "353cc7e612b6de148df168fc0a9b6b58acae6c36",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/downloadFiles",
      "headRefOid": "5c8b5df60de44db162e3b12ae033111710868648",
      "closedAt": "2025-03-16T07:04:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Once we have more room policy established, we can have attachments policies. One of these could specify if attachments are to be stored in the local sender's provider domain or the hub's domain. The download proxy primitive could then be restricted to only working for URLs in the specified domain, or even restricted to a specific path.",
          "createdAt": "2024-03-20T22:13:55Z",
          "updatedAt": "2024-03-20T22:13:55Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #111 ",
          "createdAt": "2025-03-16T07:04:56Z",
          "updatedAt": "2025-03-16T07:04:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO85zU0pF",
          "commit": {
            "abbreviatedOid": "5c8b5df"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-13T17:48:00Z",
          "updatedAt": "2024-03-13T17:48:00Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "this is a WIP PR, but some design considerations from prior learnings:\r\n\r\n* Files should be linked to a specific message or event, and access controls implemented over the proxyDownload request. Specifically, the requesting server MUST have visibility on the message in order to have the download succeed. This is to prevent the remote server from becoming an open proxy and effective CDN (typically for illegal content).\r\n* The request must include sufficient authorization information to complete the ACL check above. This doesn't require identifying the specific user/client, but must be able to identify the server. (I think we already support this, but noting it anyways just in case).\r\n* The hub server, who is presumably receiving this request, should make use of a [leaky bucket algorithm](https://en.wikipedia.org/wiki/Leaky_bucket#As_a_meter) to minimize bandwidth costs.",
              "createdAt": "2024-03-13T17:48:00Z",
              "updatedAt": "2024-03-13T17:48:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 76,
      "id": "PR_kwDOKZ8QO85rcZnU",
      "title": "Convert to draft-ietf",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/76",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-04-02T14:08:43Z",
      "updatedAt": "2024-04-02T14:13:27Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "353cc7e612b6de148df168fc0a9b6b58acae6c36",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "draft-ietf",
      "headRefOid": "3737de4d3c60704125663081b4457d3320f75d9f",
      "closedAt": "2024-04-02T14:12:04Z",
      "mergedAt": "2024-04-02T14:12:03Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "eddb965307c64078e744573c39d5dffbc5f50bf4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 78,
      "id": "PR_kwDOKZ8QO85stsn8",
      "title": "Add consent primitive and related discussions. Replaces PR #72",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/78",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This replaces PR #72 \r\n\r\nIt was created merely to deal with merge conflicts created when migrating the repo. Otherwise it has identical content to #72 \r\n",
      "createdAt": "2024-04-15T18:43:37Z",
      "updatedAt": "2024-10-21T02:36:51Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "eddb965307c64078e744573c39d5dffbc5f50bf4",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/consent2",
      "headRefOid": "b4a39f0b97042f7eda64c0f3cd57c00e6da75d6b",
      "closedAt": "2024-04-29T15:48:34Z",
      "mergedAt": "2024-04-29T15:48:34Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "b8960de20eb846cb964462c4d18076b8c4f52924"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 79,
      "id": "PR_kwDOKZ8QO85yBtWO",
      "title": "Semi-private handshake messages in Update Room",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/79",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "According to room policy, members could send handshake messages (Commits and Proposals) as PublicMessage or PrivateMessage. When a PrivateMessage the key and nonce used to encrypt the PrivateMessage is HPKE encrypted for the hub and included in the message.\r\nthe HPKE `Seal<Base>` `info` is the hash of the complete MLSMessage that would have been sent.\r\n",
      "createdAt": "2024-06-10T21:05:55Z",
      "updatedAt": "2024-10-21T02:36:47Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "b8960de20eb846cb964462c4d18076b8c4f52924",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/semiPrivateCommit",
      "headRefOid": "0ca0868541e5f1eebd9f0e880a9f554c61a47d80",
      "closedAt": "2024-08-13T19:18:42Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "replaced by PR #80 ",
          "createdAt": "2024-08-13T19:18:42Z",
          "updatedAt": "2024-08-13T19:18:42Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 80,
      "id": "PR_kwDOKZ8QO85yWqtB",
      "title": "Semi-private handshake can use an MLS SemiPrivateMessage ",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/80",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "WIP\r\n\r\nAlternate (to #79 ) way to have a semi-private handshake (private, plus shared encrypted with the hub).",
      "createdAt": "2024-06-13T12:00:32Z",
      "updatedAt": "2024-10-21T02:36:46Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "b8960de20eb846cb964462c4d18076b8c4f52924",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohan/semiPrivateAlt",
      "headRefOid": "878bdb4d3089e05aed1abf428debde919a66c565",
      "closedAt": "2024-08-13T19:14:29Z",
      "mergedAt": "2024-08-13T19:14:29Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "4644c776e12a647792932b6344a91d54599a3e31"
      },
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Per the discussion at IETF120 and the subsequent consensus call, the group will move forward with implementation of SemiPrivateMessage as a baseline mechanism and pseudonyms as an opt-in feature (which should require little or no new mechanism for the hub and other members/participants).\r\n\r\nThis PR replaces #79 ",
          "createdAt": "2024-08-13T19:14:25Z",
          "updatedAt": "2024-08-13T19:14:25Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 81,
      "id": "PR_kwDOKZ8QO850V12e",
      "title": "Fix README to point to correct locations",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/81",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-03T15:17:21Z",
      "updatedAt": "2024-10-21T02:36:50Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "b8960de20eb846cb964462c4d18076b8c4f52924",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "fix-readme",
      "headRefOid": "abe3083eec9c499d063e32434332505a6a06f3d6",
      "closedAt": "2024-07-03T15:17:46Z",
      "mergedAt": "2024-07-03T15:17:46Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "50ad85ec9bc33c74a9a09484b19005f48d34d503"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 82,
      "id": "PR_kwDOKZ8QO850nj39",
      "title": "Move the definition of MLS AppSync to its own spec",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/82",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Rohan and I separately published [draft-barnes-mls-appsync](https://datatracker.ietf.org/doc/draft-barnes-mls-appsync/), which is currently just a copy/paste of the content from this document.  No technical changes, just moving things around.",
      "createdAt": "2024-07-07T18:15:21Z",
      "updatedAt": "2024-10-21T02:37:59Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "ac27aa788b6277fbe0001347bbcd2ef35660a16c",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "no-appsync",
      "headRefOid": "a986cb12599ddca42a9f22cb18116c0b72e1ef3b",
      "closedAt": "2024-07-07T20:21:14Z",
      "mergedAt": "2024-07-07T20:21:14Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "da9fa250389b16a3bf2ab39a11b54d9a6c6bff9e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO86A3D8s",
          "commit": {
            "abbreviatedOid": "a986cb1"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-07T20:20:58Z",
          "updatedAt": "2024-07-07T20:20:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 83,
      "id": "PR_kwDOKZ8QO852Bhho",
      "title": "Add abuse reporting mechanism with message franking",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/83",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-21T21:30:03Z",
      "updatedAt": "2024-12-16T17:23:06Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9fa250389b16a3bf2ab39a11b54d9a6c6bff9e",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "abuse2",
      "headRefOid": "817e964c5810b21c23d01ef78fda0494883ba36b",
      "closedAt": "2024-10-21T20:16:44Z",
      "mergedAt": "2024-10-21T20:16:44Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "33614cdb50ccd6aea0524b5da874fdd70674a681"
      },
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation @rohanmahy as per IETF 120, some refs to Hecate, more advanced approaches to franking: \r\nhttps://eprint.iacr.org/2021/1686\r\nhttps://www.usenix.org/system/files/sec22-issa.pdf",
          "createdAt": "2024-07-23T20:52:09Z",
          "updatedAt": "2024-07-23T20:52:09Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Dierdre mentioned using Hecate during IETF 120. After looking at the spec, I realized that it requires a number of extra round trips between the client and the hub (possibly through a separate local provider), which would be a non-starter for MIMI high-volume applications.",
          "createdAt": "2024-08-13T19:36:06Z",
          "updatedAt": "2024-08-13T19:36:06Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "I just merged a change which makes the franking_context safe from metadata inspection by follower providers. It uses a secret derived using the \"Associated Parties key schedule\" documented in draft-kohbrok-mls-associated-parties. I think this closes the last open issue with the franking mechanism.",
          "createdAt": "2024-10-20T22:43:54Z",
          "updatedAt": "2024-10-20T22:43:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO86C05Ol",
          "commit": {
            "abbreviatedOid": "0e0e971"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The idea looks good, though I can't speak to the cryptography/franking specifics. +1 to franking for sure.\r\n\r\nI also have the ongoing (and outstanding) concern about what use cases we're applying to the abuse reporting mechanisms.",
          "createdAt": "2024-07-23T19:33:04Z",
          "updatedAt": "2024-07-23T19:39:51Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n    target: https://about.fb.com/wp-content/uploads/2016/07/messenger-secret-conversations-technical-whitepaper.pdf\r\n```",
              "createdAt": "2024-07-23T19:33:04Z",
              "updatedAt": "2024-07-23T19:39:51Z"
            },
            {
              "originalPosition": 235,
              "body": "What is the intended scope of this reporting mechanism? Sending things to the hub feels improper when trying to report platform-level concerns (\"Alice has a pattern of disruptive behaviour\"), but would be fine when aiming to report messages without a broad pattern of abuse. \r\n\r\nWe may need two (or more) mechanisms to cover the use cases. Each mechanism should describe which use case(s) they cover specifically. ",
              "createdAt": "2024-07-23T19:38:27Z",
              "updatedAt": "2024-07-23T19:39:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86C1f9G",
          "commit": {
            "abbreviatedOid": "0e0e971"
          },
          "author": "turt2live",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-23T20:55:51Z",
          "updatedAt": "2024-07-23T20:55:51Z",
          "comments": [
            {
              "originalPosition": 235,
              "body": "From IETF120: this mechanism is specifically to allow the hub to enforce policy at the room/group level. Broad patterns of abuse (\"provider A's terms of service are being violated\") would be handled elsewhere. \r\n\r\nExamples of policy would be \"no cursing\", where the hub can then handle the report as needed.\r\n\r\nClarifying this in the PR is appreciated. ",
              "createdAt": "2024-07-23T20:55:51Z",
              "updatedAt": "2024-07-23T20:55:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86N6LQy",
          "commit": {
            "abbreviatedOid": "cf5eb2b"
          },
          "author": "dconnolly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T03:34:10Z",
          "updatedAt": "2024-10-21T03:34:11Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "How is this done, exactly? `draft-kohbrok-mls-associated-parties` has no mention of `franking_context_secret` or non-explicit derivations in its key schedule",
              "createdAt": "2024-10-21T03:34:10Z",
              "updatedAt": "2024-10-21T03:34:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86N6bjm",
          "commit": {
            "abbreviatedOid": "cf5eb2b"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T04:37:28Z",
          "updatedAt": "2024-10-21T04:37:28Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "In Figure 1 of Associated Parties, the ap_exporter_secret is derived from the ap_epoch_secret for the Hub. `franking_context_secret` is derived from `ap_exporter_secret` using the label \"franking_context\" (just added the label). See lines 1174 to 1178 for the discussion of the derivation.",
              "createdAt": "2024-10-21T04:37:28Z",
              "updatedAt": "2024-10-21T04:37:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86N_JO6",
          "commit": {
            "abbreviatedOid": "9925e43"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T13:36:25Z",
          "updatedAt": "2024-10-21T13:36:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO86OAWFv",
          "commit": {
            "abbreviatedOid": "cf5eb2b"
          },
          "author": "dconnolly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T15:19:50Z",
          "updatedAt": "2024-10-21T15:19:50Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "OK; I may submit a PR to this one just to clarify the derivation even more; I wonder if Associated Parties can/should provide explicit guidance on how to do this sort of thing 'in general'",
              "createdAt": "2024-10-21T15:19:50Z",
              "updatedAt": "2024-10-21T15:19:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86OCml6",
          "commit": {
            "abbreviatedOid": "cf5eb2b"
          },
          "author": "dconnolly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T18:39:13Z",
          "updatedAt": "2024-10-21T18:39:14Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Done here: https://github.com/ietf-wg-mimi/mimi-protocol/pull/87",
              "createdAt": "2024-10-21T18:39:13Z",
              "updatedAt": "2024-10-21T18:39:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86ODM1i",
          "commit": {
            "abbreviatedOid": "817e964"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T20:04:31Z",
          "updatedAt": "2024-10-21T20:08:06Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "```suggestion\r\nstruct {\r\n  MLSMessage commit;\r\n  optional<Welcome> welcome;\r\n  GroupInfo group_info;\r\n  RatchetTreeOption ratchet_tree_option;\r\n} CommitBundle;\r\n\r\nstruct {\r\n  MLSMessage proposals<V>;\r\n  optional<CommitBundle> commit_bundle;\r\n} HandshakeBundle;\r\n```",
              "createdAt": "2024-10-21T20:04:31Z",
              "updatedAt": "2024-10-21T20:08:06Z"
            },
            {
              "originalPosition": 123,
              "body": "```suggestion\r\n      IdentifierURI sending_uri;\r\n```\r\n\r\nNit: The style in TLS syntax is to use `snake_case` for these identifiers.",
              "createdAt": "2024-10-21T20:05:58Z",
              "updatedAt": "2024-10-21T20:08:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86ODRaJ",
          "commit": {
            "abbreviatedOid": "3dfd222"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T20:15:26Z",
          "updatedAt": "2024-10-21T20:15:26Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "I'll do a massive case realignment PR either before or after WGLC",
              "createdAt": "2024-10-21T20:15:26Z",
              "updatedAt": "2024-10-21T20:15:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 85,
      "id": "PR_kwDOKZ8QO85_QKBz",
      "title": "Support more efficient ways to upload ratchet_tree and GroupInfo",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/85",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-21T03:08:34Z",
      "updatedAt": "2024-12-16T17:23:11Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "4644c776e12a647792932b6344a91d54599a3e31",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "update-without-ratchettree",
      "headRefOid": "95befe1fa451cd704aafd980cd20d3f8f3cc3c19",
      "closedAt": "2024-10-21T20:11:41Z",
      "mergedAt": "2024-10-21T20:11:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5d11d9bac9c336cd609f4cd577b279f65bb77865"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO86N7TGE",
          "commit": {
            "abbreviatedOid": "95befe1"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good. We can discuss details in the context of mahy-mls-ratchet-tree-options.",
          "createdAt": "2024-10-21T07:13:57Z",
          "updatedAt": "2024-10-21T07:13:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO86ODPk-",
          "commit": {
            "abbreviatedOid": "95befe1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T20:11:02Z",
          "updatedAt": "2024-10-21T20:11:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 86,
      "id": "PR_kwDOKZ8QO85_QRnH",
      "title": "Encrypt GroupInfo and ratchet_tree in repsonse to /groupInfo endpoint",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/86",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026 for better metadata privacy",
      "createdAt": "2024-10-21T03:31:39Z",
      "updatedAt": "2024-12-16T17:23:07Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "4644c776e12a647792932b6344a91d54599a3e31",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "encrypted-groupinfo",
      "headRefOid": "2aab12989dbf8c7add41025550aa9fad2825cf86",
      "closedAt": "2024-10-21T19:59:29Z",
      "mergedAt": "2024-10-21T19:59:29Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ade20e2035ca2d247ee9e770ad3f28a565d9c3b0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO86N7RfO",
          "commit": {
            "abbreviatedOid": "2aab129"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T07:10:50Z",
          "updatedAt": "2024-10-21T07:10:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO86ODJPh",
          "commit": {
            "abbreviatedOid": "2aab129"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T19:57:38Z",
          "updatedAt": "2024-10-21T19:59:07Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I'm OK letting this go for now, but:\r\n\r\nAt this point, you could just send a KeyPackage and have the response be a Welcome with either a Welcome extension or a PrivateMessage.\r\n\r\nAlternatively, you could just use OHAI.",
              "createdAt": "2024-10-21T19:57:38Z",
              "updatedAt": "2024-10-21T19:59:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 87,
      "id": "PR_kwDOKZ8QO85_XJZO",
      "title": "Diagram the extended Associated Parties Key Schedule to derive franking_context_secret",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/87",
      "state": "MERGED",
      "author": "dconnolly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@rohan-wire @kkohbrok ",
      "createdAt": "2024-10-21T18:36:12Z",
      "updatedAt": "2024-10-21T20:07:33Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "abuse2",
      "baseRefOid": "9925e431ec7fbb7986742a4f4a62751738e20d21",
      "headRepository": "dconnolly/mimi-protocol",
      "headRefName": "abuse2",
      "headRefOid": "50a53c8559e580e9717ebcc50c31bcb19955b222",
      "closedAt": "2024-10-21T20:07:33Z",
      "mergedAt": "2024-10-21T20:07:33Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "817e964c5810b21c23d01ef78fda0494883ba36b"
      },
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@rohanmahy I think the workflow run needs to be approved and then this can be merged into the message franking branch `abuse2`",
          "createdAt": "2024-10-21T19:59:33Z",
          "updatedAt": "2024-10-21T19:59:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO86OC0rk",
          "commit": {
            "abbreviatedOid": "50a53c8"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T19:11:55Z",
          "updatedAt": "2024-10-21T19:11:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO86ODOAA",
          "commit": {
            "abbreviatedOid": "50a53c8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T20:07:24Z",
          "updatedAt": "2024-10-21T20:07:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 90,
      "id": "PR_kwDOKZ8QO86BifZI",
      "title": "Update Franking scheme to include integrity from follower mauling",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/90",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed at IETF 121 meeting last week, issue #89 means that a malicious follower could destroy a frank and the receiver would never find out until they presented an invalid frank when reporting abuse.\r\n\r\nThis PR adds a second associated parties exported key for a general purpose integrity check over all the hub-provided values in a fanout message.",
      "createdAt": "2024-11-11T17:37:13Z",
      "updatedAt": "2024-12-16T17:23:03Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "33614cdb50ccd6aea0524b5da874fdd70674a681",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "frank-integrity",
      "headRefOid": "28db3038f82701f02ab02734e799fda1a13f3f29",
      "closedAt": "2024-11-21T17:36:19Z",
      "mergedAt": "2024-11-21T17:36:19Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "9531ff4c247b990bc2ac53770a5a57124eaa934a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 92,
      "id": "PR_kwDOKZ8QO86DggGu",
      "title": "SignWithLabel was missing signature keys",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/92",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Two instances of SignWithLabel did not specify the signature key to use. Fixed one, and left a TODO in place for the other.",
      "createdAt": "2024-11-28T20:40:11Z",
      "updatedAt": "2024-12-16T17:22:57Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "9531ff4c247b990bc2ac53770a5a57124eaa934a",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "rohanmahy-patch-1",
      "headRefOid": "3ab02b3d5fc9ef4c23b7935ac9ffda570174f28f",
      "closedAt": "2024-11-28T20:46:43Z",
      "mergedAt": "2024-11-28T20:46:43Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "ae0ded70689a5249c386d886c8743af73d5d79ad"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 94,
      "id": "PR_kwDOKZ8QO86FZ2DX",
      "title": "Allow searches for multiple fields",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/94",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Allow searches for multiple fields (with AND semantics)\r\n- Clarify the semantics of SearchIdentifierType enum\r\n\r\nPartially addresses Issue #91 \r\n",
      "createdAt": "2024-12-16T19:47:37Z",
      "updatedAt": "2024-12-20T22:35:06Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "ae0ded70689a5249c386d886c8743af73d5d79ad",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "multisearch",
      "headRefOid": "fc669e5285a2e32ceca5119b538952307b02e813",
      "closedAt": "2024-12-20T22:34:47Z",
      "mergedAt": "2024-12-20T22:34:47Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "be0f6b9b57b23b19f3eb27c5425b792e6838f298"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO86VxXc1",
          "commit": {
            "abbreviatedOid": "0401abf"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T19:54:39Z",
          "updatedAt": "2024-12-18T19:59:11Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Nit: I would put this `select` above the `searchValue`, since the colloquial order is `(key, value)`.",
              "createdAt": "2024-12-18T19:54:39Z",
              "updatedAt": "2024-12-18T19:59:11Z"
            },
            {
              "originalPosition": 40,
              "body": "What is the semantic of having multiple query elements?  Are you asking for a profile that matches all of them?  Any of them?",
              "createdAt": "2024-12-18T19:57:13Z",
              "updatedAt": "2024-12-18T19:59:11Z"
            },
            {
              "originalPosition": 58,
              "body": "Case-insensitivity us normally never a good idea, but here I think you might not be loose enough.  For example, if the query contains `Mathtew`, is the responding provider allowed to spell-check that to `Matthew`?  I would probably be inclined to be very loose about the request semantics, and instead have the response provide the attributes that the responding provider thought matched, so that then the requesting provider / user can decide if the match is valid.",
              "createdAt": "2024-12-18T19:59:04Z",
              "updatedAt": "2024-12-18T19:59:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86VxafY",
          "commit": {
            "abbreviatedOid": "0401abf"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T20:02:15Z",
          "updatedAt": "2024-12-18T20:02:16Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "All of them. there was text somewhere but I can restate here",
              "createdAt": "2024-12-18T20:02:16Z",
              "updatedAt": "2024-12-18T20:02:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86VxavJ",
          "commit": {
            "abbreviatedOid": "0401abf"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T20:02:51Z",
          "updatedAt": "2024-12-18T20:02:51Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "fair enough ",
              "createdAt": "2024-12-18T20:02:51Z",
              "updatedAt": "2024-12-18T20:02:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 96,
      "id": "PR_kwDOKZ8QO86FaS87",
      "title": "Make franking_integrity_hash cover context; deprecate franking_context_hash ",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/96",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "combine functionality of franking_integrity_hash and franking_context_hash into a single franking_integrity_hash",
      "createdAt": "2024-12-16T20:57:50Z",
      "updatedAt": "2024-12-20T22:16:09Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "ae0ded70689a5249c386d886c8743af73d5d79ad",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "simplify-franking",
      "headRefOid": "9197c3c324ee76c6fddd9e2bfb367d1de06926fd",
      "closedAt": "2024-12-18T19:28:03Z",
      "mergedAt": "2024-12-18T19:28:03Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "21d96b25b36edbc7dae5d55f4e2704819aa1a77d"
      },
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Relates to Issue #95 ",
          "createdAt": "2024-12-17T01:50:34Z",
          "updatedAt": "2024-12-17T01:50:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 97,
      "id": "PR_kwDOKZ8QO86F9iWW",
      "title": "Fix type of encrypted_groupinfo_and_tree",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/97",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "was `opaque`, should have been `HPKECiphertext`.",
      "createdAt": "2024-12-20T23:17:12Z",
      "updatedAt": "2025-02-25T05:11:25Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "be0f6b9b57b23b19f3eb27c5425b792e6838f298",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "hpkeciphertext",
      "headRefOid": "ec55300ba8f01c33b87d2a8d109e58196c26b189",
      "closedAt": "2024-12-20T23:17:22Z",
      "mergedAt": "2024-12-20T23:17:22Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "41df7674220d7fb6711185e581e5d85d1924b968"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 98,
      "id": "PR_kwDOKZ8QO86F9kVK",
      "title": "Update CODEOWNERS",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/98",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "remove Raphael until we have a valid email address associated with his github account.",
      "createdAt": "2024-12-20T23:26:57Z",
      "updatedAt": "2025-02-25T05:11:06Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "41df7674220d7fb6711185e581e5d85d1924b968",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "codeowners1",
      "headRefOid": "2b4f8a9590942b49930428350293c24e3e3d9201",
      "closedAt": "2024-12-20T23:27:06Z",
      "mergedAt": "2024-12-20T23:27:06Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "a7bb90ec1a03e9d1386f12d2a36729bd21c75ff5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 99,
      "id": "PR_kwDOKZ8QO86F_r4v",
      "title": "Add Raphael's correct git email",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/99",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-12-21T17:10:01Z",
      "updatedAt": "2025-02-25T05:11:07Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "a7bb90ec1a03e9d1386f12d2a36729bd21c75ff5",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "add-raphael-git",
      "headRefOid": "118fc960968508b32314db8da227cc397be4239a",
      "closedAt": "2024-12-21T17:10:15Z",
      "mergedAt": "2024-12-21T17:10:15Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "11cd0b3395bc73d593959a1ccdcf77a86dc4dd34"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 100,
      "id": "PR_kwDOKZ8QO86GDFaA",
      "title": "Make franking section consistent with mimi-content per-message salt",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/100",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-12-23T07:20:44Z",
      "updatedAt": "2025-02-25T05:10:13Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "11cd0b3395bc73d593959a1ccdcf77a86dc4dd34",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "franking-salt",
      "headRefOid": "8426cd8f76794e35267968c3a8e75ae1f24bca5c",
      "closedAt": "2024-12-23T07:30:14Z",
      "mergedAt": "2024-12-23T07:30:14Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "291f60313025445b7c32434a81f7681de7adab36"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 101,
      "id": "PR_kwDOKZ8QO86HfehY",
      "title": "Add section on minimal metadata rooms",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/101",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR introduces the notion of pseudonymous credentials for MIMI by introducing a new room type \"Minimal Metadata Rooms\". We could also make that a configuration flag and/or use another name. I'm open to suggestions in that regard. There are still a few TODOs/open questions, though:\r\n\r\n- Encryption of `identity_link_keys`: We intend to solve this via the TreeWrap mechanism we proposed, but we haven't quite finished writing up the spec for that. For now it's a simple static key.\r\n- External joins: There's still a small issue with external joins. In theory, new joiners just need the `identity_link_wrapper_key` to join the group, but if we start rotating that, we run into race conditions. How we solve that depends a bit on the situations in which we need external joins. Maybe we can discuss this in a future interim.\r\n- Connections: For Minimal Metadata Rooms to work, users need to learn the `connection_key` of other users they want to add to a group. Since we probably also want a notion of \"connection\" for other things such as consent, this PR only expresses the requirement for connection key exchange for now.",
      "createdAt": "2025-01-13T07:35:44Z",
      "updatedAt": "2025-03-16T07:18:38Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "ca463fed74f03e7a05ba2ff3b62158f02312035e",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "konrad/metadata_privacy",
      "headRefOid": "7b047ad15141ba93fef1163d073a67e443cc78fc",
      "closedAt": "2025-03-03T13:34:06Z",
      "mergedAt": "2025-03-03T13:34:06Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "61a1488cc44efe1096e6227ca1f7186ab889563c"
      },
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "After the MIMI interim, I think I like the idea of accepting this PR up to line 1821 and adding a note that the key exchange is going to be addressed separately. Then we can try a few keying solutions and see how will they fit our requirements (either for credentials only, or also for sensitive data in the GroupContext, like room metadata).",
          "createdAt": "2025-02-26T20:51:05Z",
          "updatedAt": "2025-02-26T20:51:05Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "One other issue that occurred to me is that the Hub could enforce some membership changes based on a member giving the pseudonym a role, but Preauthorization would be useless since the credentials are all or nothing. Selective disclosure or ZKPs in credentials would be more flexible.",
          "createdAt": "2025-02-28T21:12:08Z",
          "updatedAt": "2025-02-28T21:12:08Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "body": "After a quick discussion OOB, I've cut the key management portion of the PR and replaced it with a TODO. I hope this reduces the PR to the portion we have agreement on s.t. we can merge before cutting the next draft version.",
          "createdAt": "2025-03-03T12:54:26Z",
          "updatedAt": "2025-03-03T12:54:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO86dSC6K",
          "commit": {
            "abbreviatedOid": "ded2324"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T00:05:46Z",
          "updatedAt": "2025-02-25T00:05:46Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\r\nIn any given room, the `user_pseudonym` of a client MUST be the same across all\r\n```",
              "createdAt": "2025-02-25T00:05:46Z",
              "updatedAt": "2025-02-25T00:05:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86dSGzy",
          "commit": {
            "abbreviatedOid": "ded2324"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T00:11:38Z",
          "updatedAt": "2025-02-25T00:11:38Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "shouldn't this section heading move to before line 1821?",
              "createdAt": "2025-02-25T00:11:38Z",
              "updatedAt": "2025-02-25T00:11:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86dSIBf",
          "commit": {
            "abbreviatedOid": "ded2324"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T00:13:34Z",
          "updatedAt": "2025-02-25T00:13:34Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "what happens with blank leaves. is the `identity_link_key` an empty <V>?",
              "createdAt": "2025-02-25T00:13:34Z",
              "updatedAt": "2025-02-25T00:13:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86dSJ0w",
          "commit": {
            "abbreviatedOid": "ded2324"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T00:20:07Z",
          "updatedAt": "2025-02-25T00:20:08Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "If the key is static, then a former member (even one who was banned) could collude with the hub to decrypt the real identities of members who joined well after the former member left.",
              "createdAt": "2025-02-25T00:20:08Z",
              "updatedAt": "2025-02-25T00:20:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86dSMHV",
          "commit": {
            "abbreviatedOid": "ded2324"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T00:27:24Z",
          "updatedAt": "2025-02-25T00:27:25Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "I didn't really understand this paragraph. \r\n```suggestion\r\nWhen a user wants to add another user to an MMR, it fetches one KeyPackage for each of that user's clients, such that each of the clients keypackages has a PseudonymousCredential that shares a single user pseudonym (see\r\n{{pseudonymous-keypackages}}). The adder then derives the `identity_link_key`\r\nfor all the added client's KeyPackages and re-encrypts those keys under the MMR's\r\n`identity_link_wrapper_key`. When adding the user to the MMR, it includes the\r\nAddAAD as described in {{identity-link-keys}}.\r\n```",
              "createdAt": "2025-02-25T00:27:25Z",
              "updatedAt": "2025-02-25T00:27:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86dSMkp",
          "commit": {
            "abbreviatedOid": "ded2324"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T00:29:17Z",
          "updatedAt": "2025-02-25T00:29:18Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "I'm guessing using an AddAAD is so external joins work? For adds originated by a member, they could use GCE or some similar mechanism to update the identity_link_key_ciphertext directly, right?",
              "createdAt": "2025-02-25T00:29:17Z",
              "updatedAt": "2025-02-25T00:29:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86dSRws",
          "commit": {
            "abbreviatedOid": "ded2324"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Overall, there are really two mechanisms:\r\n\r\nA) to provide a pseudonym, encrypting the real credential from the Hub, and so another member with the real credential can verify the real credential and the pseudonym was signed by the same signature key.\r\n\r\nB) key management for distributing keys, eventually allowing members to decrypt the real credentials.\r\n\r\n----\r\nSome comments and questions:\r\nDoes this work with external joiners or not? That seemed ambiguous.\r\n\r\nIMO there is not enough explanation of why a particular technical choice was selected (ex: AddAAD vs some other mechanism). This should be either motivated in the main text or in the (absent) security considerations.\r\n\r\nIt would be useful to walk the reader through the process to follow roughly the steps a client executes each join method (for example, a member creating a group, a member adding a new user to a group, a user adding themself via external commit, a user processing a welcome, and a member validating a commit).\r\n\r\nIs there anything the MIMI hub or other providers need to do to find KeyPackages with suitable properties?\r\n\r\nThat the key for protecting the individual keys is shared for the whole group lifetime seems unsatisfactory.",
          "createdAt": "2025-02-25T00:44:43Z",
          "updatedAt": "2025-02-25T00:44:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKZ8QO86dtRLx",
          "commit": {
            "abbreviatedOid": "ded2324"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-26T20:47:15Z",
          "updatedAt": "2025-02-26T20:47:16Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "```suggestion\r\nThe `identity_link_ciphertext` is created by encrypting the IdentityLinkTBE.\r\nThe IdentityLinkTBE contains the client's real credential, and a signature over the\r\nPseudonymousCredentialTBS signed with the client credential's `signature_public_key`.\r\n```",
              "createdAt": "2025-02-26T20:47:15Z",
              "updatedAt": "2025-02-26T20:47:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86duo6h",
          "commit": {
            "abbreviatedOid": "ded2324"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-27T00:21:45Z",
          "updatedAt": "2025-02-27T00:21:46Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Is it really necessary to have a client_pseudonym? Couldn't we use a thumbprint of the signature key? Alternatively, one of the possible forms of a MIMI client identifier is to use `mimi://example.com/d/alice-smith/0003`, such that the d is for deice and when there are two more path segments after the \"d\", the first is a \"user\" identifier, and the second is a client discriminator.",
              "createdAt": "2025-02-27T00:21:46Z",
              "updatedAt": "2025-02-27T00:21:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86eJUte",
          "commit": {
            "abbreviatedOid": "012aecf"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the review! I've addressed a few of the issues and tried to answer some of your questions. Please take a look.",
          "createdAt": "2025-03-03T07:18:00Z",
          "updatedAt": "2025-03-03T07:34:01Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "The signature key isn't necessarily static, but maybe that's okay. Sure, we could also combine user and client pseudonym into a single identifier if you'd prefer that. No strong opinion here.",
              "createdAt": "2025-03-03T07:18:00Z",
              "updatedAt": "2025-03-03T07:34:01Z"
            },
            {
              "originalPosition": 103,
              "body": "Yes, that's why it's `optional`. We could save those `None` bytes and pack the `identity_link_keys` tight, but I thought lining them up with the leaf indices would be more intuitive.",
              "createdAt": "2025-03-03T07:25:23Z",
              "updatedAt": "2025-03-03T07:34:01Z"
            },
            {
              "originalPosition": 124,
              "body": "Yes. Somehow I thought the `identity_link_ciphertexts` would be stored outside the group, but storing them in the group context is probably better. I guess there's no reason not to use AppSync here. What do you think?",
              "createdAt": "2025-03-03T07:26:48Z",
              "updatedAt": "2025-03-03T07:34:01Z"
            },
            {
              "originalPosition": 133,
              "body": "Yes, that's not ideal. We're working on a mechanism that gives us nice FS and PCS guarantees that line up with those we get from MLS.",
              "createdAt": "2025-03-03T07:33:24Z",
              "updatedAt": "2025-03-03T07:34:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86eMwWL",
          "commit": {
            "abbreviatedOid": "7b047ad"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-03T13:33:54Z",
          "updatedAt": "2025-03-03T13:33:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 102,
      "id": "PR_kwDOKZ8QO86K3p1w",
      "title": "Move Participant List and Room Metadata in",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/102",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Move Participant List and Room Metadata over from draft-mahy-mimi-app-components",
      "createdAt": "2025-02-11T21:58:48Z",
      "updatedAt": "2025-03-16T07:18:26Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "a0d82da4e1f227a6acd2f25524960ff0ba454ec9",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "plist-metadata",
      "headRefOid": "f021143de960ec9d69bdcd353a8cba40aa875a0f",
      "closedAt": "2025-02-28T21:38:45Z",
      "mergedAt": "2025-02-28T21:38:45Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "53de480f986a0a887e70a13aea420290c7507680"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO86eD0RJ",
          "commit": {
            "abbreviatedOid": "315f871"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-28T21:25:54Z",
          "updatedAt": "2025-02-28T21:26:39Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nflows where a user can \"knock\" to ask to enter a room, nor does it\r\n```",
              "createdAt": "2025-02-28T21:25:54Z",
              "updatedAt": "2025-02-28T21:26:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 104,
      "id": "PR_kwDOKZ8QO86MZKpC",
      "title": "fanout HandshakeBundle of multiple proposals as a single atomic fanout message",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/104",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-25T04:42:40Z",
      "updatedAt": "2025-02-25T05:10:02Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "291f60313025445b7c32434a81f7681de7adab36",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "issue-103",
      "headRefOid": "cde42203b6addb5612a37270fbb1e67e6a613b15",
      "closedAt": "2025-02-25T05:04:26Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 105,
      "id": "PR_kwDOKZ8QO86MZOLq",
      "title": "Fix ci",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/105",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "commit make update-files",
      "createdAt": "2025-02-25T04:49:58Z",
      "updatedAt": "2025-02-25T05:10:04Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "291f60313025445b7c32434a81f7681de7adab36",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "fix-ci",
      "headRefOid": "16ddee4fc4e83dfb610b6cfa5697877c5e747d64",
      "closedAt": "2025-02-25T04:50:59Z",
      "mergedAt": "2025-02-25T04:50:59Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "9202a1140e5ba3266c3606c29fc12fe5c3cc3796"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 106,
      "id": "PR_kwDOKZ8QO86MZWHi",
      "title": "fanout HandshakeBundle of multiple proposals as a single atomic fanout message",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/106",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses issue #103 ",
      "createdAt": "2025-02-25T05:07:16Z",
      "updatedAt": "2025-03-16T07:18:27Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "9202a1140e5ba3266c3606c29fc12fe5c3cc3796",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "issue103",
      "headRefOid": "bf9bad3e6cd493b6c2dd56b6763c6d8524c81b8c",
      "closedAt": "2025-02-26T17:30:55Z",
      "mergedAt": "2025-02-26T17:30:55Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "a0d82da4e1f227a6acd2f25524960ff0ba454ec9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO86dqsWY",
          "commit": {
            "abbreviatedOid": "bf9bad3"
          },
          "author": "kkohbrok",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-26T17:03:26Z",
          "updatedAt": "2025-02-26T17:03:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 107,
      "id": "PR_kwDOKZ8QO86M9ahx",
      "title": "Fix inconsistencies in GroupInfoResponse",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/107",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Fix inconsistencies in GroupInfoResponse\r\n- In error response cases, don't require the MLS payload",
      "createdAt": "2025-02-28T16:00:13Z",
      "updatedAt": "2025-03-16T07:18:24Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "a0d82da4e1f227a6acd2f25524960ff0ba454ec9",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "groupinfo-fix",
      "headRefOid": "53a027f18b0c0dec7aba0fca7715e6b91d35a196",
      "closedAt": "2025-02-28T21:43:41Z",
      "mergedAt": "2025-02-28T21:43:41Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "ca463fed74f03e7a05ba2ff3b62158f02312035e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO86eDyMW",
          "commit": {
            "abbreviatedOid": "c40e8b8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-02-28T21:19:52Z",
          "updatedAt": "2025-02-28T21:24:43Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n    case success:\r\n```",
              "createdAt": "2025-02-28T21:19:53Z",
              "updatedAt": "2025-02-28T21:24:43Z"
            },
            {
              "originalPosition": 30,
              "body": "What happens in other cases?  You could add something like:\r\n\r\n```\r\n    default: struct{}\r\n```",
              "createdAt": "2025-02-28T21:24:37Z",
              "updatedAt": "2025-02-28T21:24:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86eD5lH",
          "commit": {
            "abbreviatedOid": "c40e8b8"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-28T21:41:10Z",
          "updatedAt": "2025-02-28T21:41:10Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "```suggestion\r\n      };\r\n  default: struct{};\r\n```",
              "createdAt": "2025-02-28T21:41:10Z",
              "updatedAt": "2025-02-28T21:41:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86eD6TC",
          "commit": {
            "abbreviatedOid": "53a027f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-28T21:43:22Z",
          "updatedAt": "2025-02-28T21:43:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 108,
      "id": "PR_kwDOKZ8QO86NJ9mK",
      "title": "Ready to Submit draft-ietf-mimi-protocol-03",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/108",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-03T13:47:17Z",
      "updatedAt": "2025-03-16T07:18:23Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "61a1488cc44efe1096e6227ca1f7186ab889563c",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "submit-03",
      "headRefOid": "6abd1bc5955650af217d5401cfe299c254c099d2",
      "closedAt": "2025-03-03T13:48:02Z",
      "mergedAt": "2025-03-03T13:48:02Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "5080565278e0949af3425efd8d7381312c9cc1a1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 111,
      "id": "PR_kwDOKZ8QO86Ozy7_",
      "title": "Create new proxyDownload endpoint",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/111",
      "state": "OPEN",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This replaces #75 \r\n\r\nIt adds Oblivious HTTP between the downloading provider and the Hub provider.",
      "createdAt": "2025-03-16T07:04:32Z",
      "updatedAt": "2025-06-04T07:44:57Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "5080565278e0949af3425efd8d7381312c9cc1a1",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "download2",
      "headRefOid": "0c5b489d3d3ae06f571e8a011f574670fbc920d5",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "Previously, the mimi-protocol was mostly about the protocol between user's provider and hub and leaves the exact protocol between client and provider out of scope. The use of OHTTP adds specific requirements to the client in the whole design. \r\n\r\nI think stating that the Hub must provide an HTTP proxy with specific properties that is made available to the provider should be sufficient for the purpose of mimi-protocol: it allows for the client to use any protocol of their choice to instruct their provider to download the file via the hub's HTTP proxy.",
          "createdAt": "2025-03-17T02:56:53Z",
          "updatedAt": "2025-03-17T02:56:53Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "I also think the protocol laid out here allows a provider server to use a hub server (that one of their user is using) as a proxy to any remote server by setting that remote server's domain (temporarily) as their asset server domain.\r\n\r\nI also probably missed how the hub server is supposed to discover the asset server domains of its members: it's not in the directory and even if it was, the hub also can't know which provider's directory to query when requested to download a file.",
          "createdAt": "2025-03-17T03:36:18Z",
          "updatedAt": "2025-03-17T03:36:18Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed during the ietf122 mimi session, I propose to simplify this by making the hub squarely responsible for anything related to attachments:\r\n - the hub hosts attachments\r\n - the hub can enforce quotas\r\n \r\n This makes for a far easier architecture and a more consistent UX.",
          "createdAt": "2025-03-19T03:14:10Z",
          "updatedAt": "2025-03-19T03:14:10Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "In the end in any approach the file has to travel the CSSSC path and given we use HTTPS for message transfer on the S-to-S links, it feels only obvious to use it for the file transfer as well. So the question we're discussing effectively is if the transfer from sending server to hub is via GET or PUT. The architecture doesn't change by a lot.\n\nAlso, the hub in practice won't be able to completely enforce limits, simply because any file can likely be uploaded to an external service and displayed as a link that recipients can access using an external software.",
          "createdAt": "2025-03-19T09:10:51Z",
          "updatedAt": "2025-03-19T09:10:51Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "> As discussed during the ietf122 mimi session, I propose to simplify this by making the hub squarely responsible for anything related to attachments:\r\n> \r\n>     * the hub hosts attachments\r\n>     * the hub can enforce quotas\r\n\r\nI think we can expect near zero adoption from any major provider in that case. What's the motivation for a large provider to act as a hub for other clients?\r\n",
          "createdAt": "2025-04-24T19:39:17Z",
          "updatedAt": "2025-04-24T19:39:17Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think we can expect near zero adoption from any major provider in that case. What's the motivation for a large provider to act as a hub for other clients?\r\n\r\nYou claimed that at IETF122 already, but it would be good to back that claim with some concrete evidence.\r\n\r\nI don't understand why large providers would be treated any differently than small ones. The provider who becomes the hub is decided at room creation. Rooms hosted by a specific provider can only be created by users of that provider. In that moment, a provider can decide\r\n\r\n a) if federating with other users is allowed, and\r\n b) if so, what the quota for the room is (either in total or per user), and\r\n c) what the retention time is.\r\n\r\nI don't understand why there would be a bias towards large providers. And even if there was, providers remain in control of the cost.\r\n\r\n\r\n\r\n",
          "createdAt": "2025-04-25T14:13:28Z",
          "updatedAt": "2025-04-25T14:13:28Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I think we can expect near zero adoption from any major provider in that case. What's the motivation for a large provider to act as a hub for other clients?\r\n> \r\n> You claimed that at IETF122 already, but it would be good to back that claim with some concrete evidence.\r\n\r\nThe cost of storing assets is one of the most expensive parts of a messaging service, assets need to be stored for a longer amount of time and brings a host of other liabilities.\r\n\r\nIf hub A has some user from provider B, we expect provider downtime to be fairly short (minutes or hours) with rare cases of a couple of days. In most cases, messages sent to provider B for participants can be cleaned up within minutes. By contrast the expectation is that assets/attachments are stored for a much longer amount of time, in the 30 days to 1 year time frame. They are also 3-4 orders of magnitude larger than typical messages. \r\n\r\nWe have no proposed mechanism yet to allow a participant from a non-hub provider to upload assets. We know that the balance of authentication, privacy, and policy enforcement is a very hard balance and it is more challenging due to the multiparty nature of this flow.\r\n\r\nNext we have legal liability for assets. If someone reports an asset, there are a variety of legal issues in most jurisdictions. For example for CSAM, the asset needs to be quarantined. In many jurisdictions it can't even be viewed by regular administrative staff without breaking the law. It may need to be kept as evidence for years. These are all accepted costs and risks for the hub's own users, but accepting these costs and risks for others is a disproportionate burden for assets than for messages.\r\n \r\n> I don't understand why large providers would be treated any differently than small ones. The provider who becomes the hub is decided at room creation. Rooms hosted by a specific provider can only be created by users of that provider. In that moment, a provider can decide\r\n\r\nThey are not treated any differently, but all the large providers today are a free service to their users. Any providers who are free (large or small) do not get additional revenue from non-hub users. For text messaging the cost of hosting a room with several non-hub users is relatively low, but much higher if assets need to be supported.\r\n\r\nI could easily imagine some small or medium sized providers that want to offer a paid service where everything is stored on the hub in certain rooms, but absent that there is no motivation to change the default modus operandi of messaging services. MIMI protocol would not need to be changed to support an additional optional endpoint.\r\n\r\nFinally, in our charter we said we were going to try to have a light touch and not design a client to server protocol, nor dictate too much. All commercial messaging services that I know about already have a mechanism to store assets on the client's provider. This seems a pretty big departure for a questionable philosophical argument.\r\n\r\n> a) if federating with other users is allowed, and b) if so, what the quota for the room is (either in total or per user), and c) what the retention time is.\r\n> \r\n> I don't understand why there would be a bias towards large providers. And even if there was, providers remain in control of the cost.\r\nI'm not sure I understand. For MIMI to be successful, it needs to work for both large and small providers. If no large providers can deploy it (or no small providers for that matter), then we have failed. That's not a bias, it is the recognition that a healthy ecosystem needs to contain both.\r\n\r\n",
          "createdAt": "2025-04-25T15:46:42Z",
          "updatedAt": "2025-04-25T15:50:24Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the added context. I feel we are going in circles because I have a hard time discerning what's an assumption in the above and what is an established fact.\r\n\r\nTo make some progress, I propose to zoom out a bit. I think we can agree on the following:\r\n a. The design philosophy has been to empower the hub to be the arbiter and enforcer of policies wherever possible\r\n b. There are concerns about the cost of hosting assets on the hub\r\n\r\nWe have discussed two options so far:\r\n 1. Dismiss b. so that we remain true to a. (Raphael and others)\r\n 2. Make an exception to a. to account for b. (Rohan)\r\n\r\nLet's consider some middle ground, i.e., option 3. Because of the CSSSC architecture, attachments have to transit via the hub anyway. Rather than making the hub just a proxy, we could leave it to the hub whether it wants to cache attachments or not. The hub provider could decide whether it wants the cheapest option (where other providers exclusively store the attachments of their respective users) or whether it prefers to shoulder the hosting costs and provide better attachment availability. In both cases, the hub can still enforce policies regarding assets (e.g. quotas).\r\n\r\nIn a scenario with client A on a.com, client B on b.com, and hub H, the flows would look as follows:\r\n\r\n**Upload**\r\n\r\n - Client A uploads an attachment to a.com\r\n - Client A advertises the attachment to the group via the hub by sharing the attachment id\r\n - Hub H can see (part of) that message and decide whether it wants to a) allow the upload and b) cache the attachment\r\n - In the case of b), the hub H downloads the attachment from a.com\r\n\r\n**Download**\r\n\r\n - Client B has learned about a new attachment\r\n - Client B asks its provider b.com to download the attachment from the hub H by providing its id\r\n - Depending on the hub's policy, it either serves the attachment from its cache or proxies the request to a.com\r\n\r\nAll we need to do for this is to describe the API to upload/download attachments at the hub.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2025-04-27T15:18:15Z",
          "updatedAt": "2025-04-27T15:18:15Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "> Thanks for the added context. I feel we are going in circles because I have a hard time discerning what's an assumption in the above and what is an established fact.\r\n\r\nCould you be more specific about which assertions you don't agree with?\r\n\r\n> To make some progress, I propose to zoom out a bit. I think we can agree on the following: a. The design philosophy has been to empower the hub to be the arbiter and enforcer of policies wherever possible b. There are concerns about the cost of hosting assets on the hub\r\n> \r\n> We have discussed two options so far:\r\n> \r\n>     1. Dismiss b. so that we remain true to a. (Raphael and others)\r\n>     2. Make an exception to a. to account for b. (Rohan)\r\n\r\nI reject this characterization. I don't accept the absolutist statement that the hub is the enforcer of policies \"wherever possible\". Yes, it is central to managing handshake messages and controlling fanout. However it has little policy control over application messages. Policy enforcement of many of the capabilities in role-based access control, processing of expiring messages, validations of tags, handling keys correctly are all aspects of MIMI policy that fall to the clients.\r\n\r\nWe have discussed the storage of assets going back to the earliest MIMI WG meetings. Clients currently upload assets to their own providers. They send a link inside an end-to-end encrypted message. Managing policy of something inside an e2e encrypted message is normally entirely up to the clients. The only reason we are having this discussion is because of the privacy implications of a subsequent download directly from clients hosted by another provider, as was mentioned by dkg the first time I presented draft-mahy-mimi-content.\r\n\r\nWe had a reasonable amount of feedback about making OHTTP and the proxy endpoint optional to use at the last meeting. I propose instead that we make OHTTP gateway mandatory to implement on the hub and OHTTP relay is RECOMMENDED for all providers. We can build a separate mechanism/policy that allows the clients to upload to a hub on a per-room basis, but I think this should be optional.\r\n\r\n",
          "createdAt": "2025-05-28T13:58:03Z",
          "updatedAt": "2025-05-28T13:58:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO86gRZkr",
          "commit": {
            "abbreviatedOid": "0c5b489"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-17T01:02:44Z",
          "updatedAt": "2025-03-17T01:50:34Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I think that you are making stronger claims than you can really justify here.  In particular, I don't think that you can claim that the server doesn't learn about the number of clients.",
              "createdAt": "2025-03-17T01:02:45Z",
              "updatedAt": "2025-03-17T01:50:34Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nThe client consults the intersection of the room policy and its local policy to determine if and how to upload assets, where to upload them, and with which credentials. The details of the upload process are out of scope of this document.\r\n```",
              "createdAt": "2025-03-17T01:16:46Z",
              "updatedAt": "2025-03-17T01:50:34Z"
            },
            {
              "originalPosition": 34,
              "body": "This probably needs to specify where the client gets the hub's configuration.  The key configuration that the client uses is the configuration of the hub.\r\n\r\nThe local provider also needs to be able to setup relay endpoints that point to different hubs.",
              "createdAt": "2025-03-17T01:27:18Z",
              "updatedAt": "2025-03-17T01:50:34Z"
            },
            {
              "originalPosition": 35,
              "body": "You should draw a picture for this.",
              "createdAt": "2025-03-17T01:27:34Z",
              "updatedAt": "2025-03-17T01:50:34Z"
            },
            {
              "originalPosition": 37,
              "body": "I don't understand this bit.  Why do you have it quoted \"> ...\"?\r\n\r\nMore concretely, why are you putting the download URL on the end of /proxyDownload/ ?  That makes no sense to me.\r\n\r\nPresumably, the client is going to make a request to the relay (POST with an encrypted BHTTP payload).  That payload will include a GET request to the URL that was attached to a message.",
              "createdAt": "2025-03-17T01:31:07Z",
              "updatedAt": "2025-03-17T01:50:34Z"
            },
            {
              "originalPosition": 43,
              "body": "This probably needs to be more carefully specified.  There is a case here where the hub gateway (and therefore the relay) is per-room and another where the gateway is global to the hub.  You'll need to decide what works.  It seems to me like the only reason why the hub does this check is so that it doesn't get used as an open relay.  So you could make this a single gateway endpoint for the entire hub.  On the other hand, if this is setup per-room, then you will allow the hub to make finer-grained access control decisions, at the cost of more configuration complexity and lower privacy.",
              "createdAt": "2025-03-17T01:38:13Z",
              "updatedAt": "2025-03-17T01:50:34Z"
            },
            {
              "originalPosition": 46,
              "body": "{{RFC6919}}\r\n\r\nI think that you probably want to explain:\r\n\r\n1. That the hub can cache resources.\r\n2. What the consequences of that caching would be.",
              "createdAt": "2025-03-17T01:39:12Z",
              "updatedAt": "2025-03-17T01:50:34Z"
            },
            {
              "originalPosition": 48,
              "body": "You probably need a more complete analysis of the privacy properties of this system.  Including taking the position that the hub is actively looking to undermine the privacy of room participants.\r\n\r\nConsider the case where the hub selectively forwards messages to participants, for instance, by staggering delivery.  If clients are online, they might hit the gateway immediately after receiving a URL.  In that way, the hub knows both the URL that was in the message, and which client initiated that download.  It also learns how large the asset is.\r\n\r\nThis is likely the best that we can expect to achieve here, in that the hub already has this sort of information available to it.  Though it does create a covert channel from the message originator to the hub, which can be attached to individual recipients.",
              "createdAt": "2025-03-17T01:46:48Z",
              "updatedAt": "2025-03-17T01:50:34Z"
            },
            {
              "originalPosition": 49,
              "body": "\"the provider of the uploader\" probably needs a clear term; it's a little clunky.",
              "createdAt": "2025-03-17T01:49:35Z",
              "updatedAt": "2025-03-17T01:50:34Z"
            },
            {
              "originalPosition": 50,
              "body": "This is through the relay it provides, yes?  Maybe say so.",
              "createdAt": "2025-03-17T01:50:29Z",
              "updatedAt": "2025-03-17T01:50:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86gR9D7",
          "commit": {
            "abbreviatedOid": "0c5b489"
          },
          "author": "raphaelrobert",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-17T03:56:57Z",
          "updatedAt": "2025-03-17T03:59:37Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "So far we have been calling them \"attachments\", including in draft-ietf-mimi-content. We should not introduce a different yet synonymous term.",
              "createdAt": "2025-03-17T03:56:57Z",
              "updatedAt": "2025-03-17T03:59:37Z"
            },
            {
              "originalPosition": 23,
              "body": "Do we have consensus on the fact that we want to support both approaches? I think in past discussions we wanted to focus on the hub-only approach.",
              "createdAt": "2025-03-17T03:58:44Z",
              "updatedAt": "2025-03-17T03:59:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86gufyx",
          "commit": {
            "abbreviatedOid": "0c5b489"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-18T23:57:35Z",
          "updatedAt": "2025-03-18T23:57:35Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "My recollection was that webex and teams supported their equivalent of the system for storage and we wanted to stay agnostic. In any case, the technical solution that restricts the downloads to come from one of the participants' local attachment servers allows any of them to delegate this URL to the hub server. ",
              "createdAt": "2025-03-18T23:57:35Z",
              "updatedAt": "2025-03-18T23:57:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86guf2L",
          "commit": {
            "abbreviatedOid": "0c5b489"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-18T23:57:50Z",
          "updatedAt": "2025-03-18T23:57:50Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "ok. I'll update.",
              "createdAt": "2025-03-18T23:57:50Z",
              "updatedAt": "2025-03-18T23:57:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86gvEn5",
          "commit": {
            "abbreviatedOid": "0c5b489"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-19T01:50:35Z",
          "updatedAt": "2025-03-19T01:56:21Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I honestly like \"assets\" a little better, and I think it's slightly more commonly used in practice.",
              "createdAt": "2025-03-19T01:50:35Z",
              "updatedAt": "2025-03-19T01:56:21Z"
            },
            {
              "originalPosition": 23,
              "body": "AFAIK, neither Webex nor Teams is federated in any sense that would make a good analogy here.  The hub-only approach does seem simpler, though (a) it increases the cost to be a hub and (b) could impede hub transition later.  Given those drawbacks, having some flexibility here seem good.",
              "createdAt": "2025-03-19T01:53:06Z",
              "updatedAt": "2025-03-19T01:56:21Z"
            },
            {
              "originalPosition": 25,
              "body": "Maybe you could if the hub cached assets.  That could be a compromise between the hub-only approach and the flexible approach.",
              "createdAt": "2025-03-19T01:54:02Z",
              "updatedAt": "2025-03-19T01:56:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86mbvUy",
          "commit": {
            "abbreviatedOid": "0c5b489"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-24T19:33:12Z",
          "updatedAt": "2025-04-24T19:33:12Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "@martinthomson  Yes, that was overstating things. \r\n\r\nThe hub can't learn the number of participants from a provider B that are **in a specific room** if that provider has participants in several rooms on that hub. The hub only learns the total number of asset requests coming from the provider's OHTTP relay.  \r\n\r\nAre you ok with some rephrasing of that?",
              "createdAt": "2025-04-24T19:33:12Z",
              "updatedAt": "2025-04-24T19:33:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86mdWbu",
          "commit": {
            "abbreviatedOid": "0c5b489"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-24T23:20:09Z",
          "updatedAt": "2025-04-24T23:20:09Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Yeah, the hub learns the number of requests from each provider, which is <= the number of participants, I expect (unless participants request content multiple times, which I guess is also possible).\r\n\r\nThe hosting entity would learn that someone has requested the content.",
              "createdAt": "2025-04-24T23:20:09Z",
              "updatedAt": "2025-04-24T23:20:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86smCMO",
          "commit": {
            "abbreviatedOid": "0c5b489"
          },
          "author": "Splow95",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-04T07:44:56Z",
          "updatedAt": "2025-06-04T07:44:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 112,
      "id": "PR_kwDOKZ8QO86Oz3AG",
      "title": "Make Key Material requests safer from provider tampering",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/112",
      "state": "OPEN",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "addresses Issue #110 ",
      "createdAt": "2025-03-16T07:45:38Z",
      "updatedAt": "2025-06-28T18:11:25Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "5080565278e0949af3425efd8d7381312c9cc1a1",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "sign-kp-request",
      "headRefOid": "c69c6dc3518f3e0c5917e57f00cdb4fe702d740a",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO86w9jjI",
          "commit": {
            "abbreviatedOid": "c69c6dc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-28T18:11:25Z",
          "updatedAt": "2025-06-28T18:11:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 113,
      "id": "PR_kwDOKZ8QO86PMEAq",
      "title": "Add group_info_response_nonce to prevent replay attacks",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/113",
      "state": "OPEN",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-18T23:46:41Z",
      "updatedAt": "2025-05-12T12:50:08Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "5080565278e0949af3425efd8d7381312c9cc1a1",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "ginfo-resp-nonce",
      "headRefOid": "d4f788196dede7a06d124e4d640f83abd4ddf4ce",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO86guqWu",
          "commit": {
            "abbreviatedOid": "d4f7881"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is not a \"2-time pad\" (terrible phrase; almost never a real thing), this is bounding the replayability of the signature.  You should either:\r\n\r\n1. Put a nonce in the request, which the response signature must include\r\n2. Put a timestamp in the response, which the requester compares to their local time\r\n\r\nClearly (1) would be preferable, because it doesn't require time sync.",
          "createdAt": "2025-03-19T00:48:17Z",
          "updatedAt": "2025-03-19T00:48:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 118,
      "id": "PR_kwDOKZ8QO86T2tYV",
      "title": "Change franking_integrity to use signature",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/118",
      "state": "OPEN",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Change franking_integrity to use signature\r\n- create franking_agent GroupContext component to hold signature public key for validating franking_integrity_signature\r\n- clarify relationship with MIMI content salt, sender_uri, and room_uri\r\n- register all four app components with IANA\r\n- acknowledge Felix Linker for Tamarin formal methods model\r\n- regularize case conventions for franking-related fields",
      "createdAt": "2025-04-25T04:02:45Z",
      "updatedAt": "2025-06-28T18:22:21Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "5080565278e0949af3425efd8d7381312c9cc1a1",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "sign-frank",
      "headRefOid": "c1db4a79ee3b58a198396359f02d91c20581e5fa",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO86oGhR-",
          "commit": {
            "abbreviatedOid": "da7d895"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-07T04:14:33Z",
          "updatedAt": "2025-05-07T04:14:33Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "```suggestion\r\nNote that these assertions do not vouch for the validity of these values,\r\n```",
              "createdAt": "2025-05-07T04:14:33Z",
              "updatedAt": "2025-05-07T04:14:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86oGilt",
          "commit": {
            "abbreviatedOid": "da7d895"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-07T04:17:58Z",
          "updatedAt": "2025-05-07T04:17:58Z",
          "comments": [
            {
              "originalPosition": 354,
              "body": "```suggestion\r\nThis document registers the following four MLS application components per\r\n```",
              "createdAt": "2025-05-07T04:17:58Z",
              "updatedAt": "2025-05-07T04:17:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86w7ZC0",
          "commit": {
            "abbreviatedOid": "417cb6b"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-28T04:35:46Z",
          "updatedAt": "2025-06-28T04:35:46Z",
          "comments": [
            {
              "originalPosition": 375,
              "body": "```suggestion\r\n- Value: TBD2\r\n- Name: franking_signature_key\r\n```",
              "createdAt": "2025-06-28T04:35:46Z",
              "updatedAt": "2025-06-28T04:35:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKZ8QO86w9kzi",
          "commit": {
            "abbreviatedOid": "c1db4a7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Couple of minor comments, overall LGTM.",
          "createdAt": "2025-06-28T18:17:47Z",
          "updatedAt": "2025-06-28T18:22:21Z",
          "comments": [
            {
              "originalPosition": 201,
              "body": "Concatenation here is not good.  Risk of confusion between the two URIs.  Better to do this with something like a TLS-syntax or CBOR struct so that it's length-delimited.  Likewise for the other concatenations here.",
              "createdAt": "2025-06-28T18:17:47Z",
              "updatedAt": "2025-06-28T18:22:21Z"
            },
            {
              "originalPosition": 63,
              "body": "Perhaps this should be a vec, instead of being fixed-size forever?",
              "createdAt": "2025-06-28T18:18:20Z",
              "updatedAt": "2025-06-28T18:22:21Z"
            },
            {
              "originalPosition": 70,
              "body": "I'm not thrilled that we're using Credential for a whole bunch of things that are not MLS clients.  But I don't have a great alternative in mind.",
              "createdAt": "2025-06-28T18:19:34Z",
              "updatedAt": "2025-06-28T18:22:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 120,
      "id": "PR_kwDOKZ8QO86V1bb7",
      "title": "Make sure a new version of the hub's own invalidated pending proposals is stapled to an external commit",
      "url": "https://github.com/ietf-wg-mimi/mimi-protocol/pull/120",
      "state": "OPEN",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-12T13:03:01Z",
      "updatedAt": "2025-06-28T19:36:28Z",
      "baseRepository": "ietf-wg-mimi/mimi-protocol",
      "baseRefName": "main",
      "baseRefOid": "5080565278e0949af3425efd8d7381312c9cc1a1",
      "headRepository": "ietf-wg-mimi/mimi-protocol",
      "headRefName": "fanout-ext-props",
      "headRefOid": "994e9ef64df26c7b7287d017618c252b5f77b146",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "> This needs more prose to describe what you're doing here. It seems like the workflow you have in mind is:\r\n> \r\n>     * Hub generates some proposals, cues those up\r\n> \r\n>     * Someone comes along and does an external Commit\r\n> \r\n>     * Unfortunately, that external Commit can't include the hub's proposals\r\n> \r\n>     * So the Hub regenerates the proposals in the new epoch and distributes them\r\n> \r\n> \r\n> Assuming I have that right, \r\n\r\nyou've got that right.\r\n\r\n>I'm not clear on why you're sending the new proposals out like this. (Same with the `moreProposals` field above.) Is the expectation that a follower server or client is keeping a copy of the hub's proposal queue? If that's the case, shouldn't we just send the whole proposal queue in these cases? Wouldn't it be better just to send the proposal queue to a committer at the time they try to commit?\r\n\r\nUnless those proposals are legal inside an external commit (SelfRemove, AppDataUpdate, AppEphemeral), the client cannot just get a copy of the proposal queue, because their external commit would fail validation.",
          "createdAt": "2025-06-28T19:36:27Z",
          "updatedAt": "2025-06-28T19:36:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKZ8QO86w9nHQ",
          "commit": {
            "abbreviatedOid": "994e9ef"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This needs more prose to describe what you're doing here.  It seems like the workflow you have in mind is:\r\n\r\n* Hub generates some proposals, cues those up\r\n* Someone comes along and does an external Commit\r\n* Unfortunately, that external Commit can't include the hub's proposals\r\n* So the Hub regenerates the proposals in the new epoch and distributes them\r\n\r\nAssuming I have that right, I'm not clear on why you're sending the new proposals out like this.  (Same with the `moreProposals` field above.)  Is the expectation that a follower server or client is keeping a copy of the hub's proposal queue?   If that's the case, shouldn't we just send the whole proposal queue in these cases?  Wouldn't it be better just to send the proposal queue to a committer at the time they try to commit?",
          "createdAt": "2025-06-28T18:37:38Z",
          "updatedAt": "2025-06-28T18:37:38Z",
          "comments": []
        }
      ]
    }
  ]
}